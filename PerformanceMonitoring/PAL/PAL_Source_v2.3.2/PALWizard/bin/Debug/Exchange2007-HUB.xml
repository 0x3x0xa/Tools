<?xml version="1.0" encoding="utf-8"?>
<PAL NAME="Microsoft Exchange 2007 - HUB" DESCRIPTION="Use this for general analysis of the Exchange 2007 Hub Role. For the latest XML updates for this tool, go to http://blogs.technet.com/mikelag/archive/2008/08/20/xml-updates-for-the-pal-tool.aspx&#xD;&#xA;" CONTENTOWNERS="Mike Lagase" FEEDBACKEMAILADDRESS="paltool@microsoft.com;mikelag@microsoft.com" VERSION="1.0" LANGUAGE="English" LANGUAGECODE="en">
  <INHERITANCE FILEPATH="QuickSystemOverview.xml" />
  <INHERITANCE FILEPATH="IIS.xml" />
  <QUESTION DATATYPE="string" DEFAULTVALUE="4" QUESTIONVARNAME="NumberOfProcessors">How many processors (physical and virtual) does the server have?</QUESTION>
  <QUESTION DATATYPE="boolean" DEFAULTVALUE="True" QUESTIONVARNAME="SixtyFourBit">Was the computer 64-bit?</QUESTION>
  <QUESTION DATATYPE="string" DEFAULTVALUE="4" QUESTIONVARNAME="TotalMemory">How much memory did the server have in gigabytes?</QUESTION>
  <QUESTION QUESTIONVARNAME="KernelDumpOnCDrive" DATATYPE="boolean" DEFAULTVALUE="True">Is the System set to create a MEMORY.DMP file on C: drive in the event of a server crash (blue screen). By default this is set to C: drive.</QUESTION>
  <ANALYSIS NAME="LogicalDisk Read Latency Analysis" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Read" ID="{dfb21d00-cf83-49e7-bf63-3d82db3d63c3}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Read" COLLECTIONVARNAME="LogicalDiskAvgDisksecReadALL" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Read" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 10ms logical disk READ response times" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="52" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.010
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 20ms logical disk READ response times" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.020
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Read" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Read" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -MinThreshold 0.010 -MaxThreshold 0.020 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -MinThreshold 0.020 -MaxThreshold 0.029999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Read is the average time, in seconds, of a read of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.010 (10 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.020 (20 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
Monitoring Mailbox Servers<BR>
<A HREF="http://technet.microsoft.com/en-us/library/bb201689(EXCHG.80).aspx">http://technet.microsoft.com/en-us/library/bb201689(EXCHG.80).aspx</A><BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Write Latency Analysis" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Write" ID="{28eaa0b2-0bc2-41f8-8c27-9045b597d001}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Write" COLLECTIONVARNAME="LogicalDiskAvgDisksecWriteALL" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Write" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 10ms logical disk WRITE response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.010
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 20ms logical disk WRITE response times" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.020
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Write" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Write" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -MinThreshold 0.010 -MaxThreshold 0.020 -UseMaxValue $False        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -MinThreshold 0.020 -MaxThreshold 0.029999 -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Greater than 900ms - Slower than a 3.5 inch floppy drive" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[#// Use PowerShell code to create alerts when the conditions for this threshold are met.
#// Optionally use the variables listed above in the Variables list box.
#// If the condition for this threshold is a static value, then use the StaticThreshold() function.
#// Otherwise, you will need to manually loop through the counter instance collection object.
#// The counter instance collection object has a unique name for each counter data source in this analysis.
#// See the variables in the Variables list box above for more information on the counter instance collection object.

#// Here is a ready to use example on how to use the StaticThreshold() function to define a threshold:
StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.9
#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.010 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.020 (25 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
Monitoring Mailbox Servers<BR>
<A HREF="http://technet.microsoft.com/en-us/library/bb201689(EXCHG.80).aspx">http://technet.microsoft.com/en-us/library/bb201689(EXCHG.80).aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Utilization Analysis" ENABLED="True" ANALYZECOUNTER="\Processor(*)\% Processor Time" CATEGORY="Processor">
    <!--
    COUNTER: All of the counters to be as a datasource for analysis. At least one counter (the AnalyzeCounter in the Analsysis) must be defined here.
      NAME: Name of the counter. An asterick (*) or a specific instance name can be used. 
        - An asterick (*) indicates all instances of the counter.
        - The (*) indicates the respective instance names will be compared.
      MINVARNAME: The name of the variable which will be assigned the minimum value of the time interval being analyzed.
      AVGVARNAME: The name of the variable which will be assigned the average value of the time interval being analyzed.
      MAXVARNAME: The name of the variable which will be assigned the maximum value of the time interval being analyzed.
      TRENDVARNAME: [NOT IMPLEMENTED] The name of the variable which will be assigned the trend value of the time interval being analyzed.
      All variable names (VARNAME's) must be unique to the Analysis node.
      DATATYPE: This is the datatype that the counter values will be converted to:
        - Supported valued: absolute, byte, double, integer, long, single
        - Default datatype is double.
    -->
    <!-- DESCRIPTION: The description of the analysis. -->
    <COUNTER NAME="\Processor(*)\% Processor Time" MINVARNAME="MinProcessor" AVGVARNAME="AvgProcessor" MAXVARNAME="MaxProcessor" TRENDVARNAME="TrendProcessor" DATATYPE="Integer" />
    <!--
    THRESHOLD: This is used to compare the value of the analyzed counter to a condition. If the condition is true, then the COLOR will be used to highlight the value.
      NAME: [NOT USED YET]
      CONDITION: This is the text that will show next to the values breaking the threshold.
      PRIORITY: This is used to determine which threshold is more important. The higher the number the more important.
        For example, a Warning is typically 50 and Critical is 100. Since the 100 is higher the Critical will be the threshold that shows because it's more important than the Warning level of 50.
      COLOR: This is the HTML color (BGCOLOR attribute) behind the value if this threshold is exceeded.
      CODE: Within the <CODE></CODE> tags. This is the VBScript code that will be evaluated against the analyzed counter values.
       - VBScript code is required when creating new threholds.
       - Here is where you use the Min, Avg, and Max variable names specified in the COUNTER node.
       - IsMinThresholdBroken, IsAvgThresholdBroken, IsMaxThresholdBroken, and/or IsTrendTresholdBroken must be evaluated to a True or False without quotes.
       - The CDATA tag must be in place to prevent a malformed XML document when using greater than and less than signs.
      DESCRIPTION: This is the description that shows in the report. 
       - This should describe what the code section is analyzing.
       - HTML tags such as bold "<B>" can be used to allow HTML formatting in the report as long as the CDATA tag is used.
    -->
    <THRESHOLD NAME="High average processor utilization - more than 75% CPU utilization" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[If the total processor time is greater than <b>75%</B> consumed on average, then the system is borderline on a processor bottleneck.        ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgProcessor > 75 Then
 			IsAvgThresholdBroken = True
			End If

			If MaxProcessor > 75 Then
 			IsMaxThresholdBroken = True
			End If
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Very high average processor utilization - more than 90% CPU utilization" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[If the total processor time is greater than <B>90%</B> consumed on average, then the system has a clear processor bottleneck.        ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgProcessor > 90 Then
 			IsAvgThresholdBroken = True
			End If

			If MaxProcessor > 90 Then
 			IsMaxThresholdBroken = True
			End If
        ]]></CODE>
    </THRESHOLD>
    <!--
    CHART: This is the value which will be used in the chart (graph) in the report.      
      - This is typically the same as the Analyze counter.
      - This value will always be averaged by time interval.
      - An asterick (*) or a specific instance name can be used.
      - An asterick (*) indicates all instances of the counter will be charted.
      CHARTTYPE: The set of available chart types depends on the version of the Microsoft Office Web Components installed on the local computer.
      CATEGORIES: Display category labels along the category axis.
      DATATYPE: This is the datatype that the counter values will be converted to:
        - Supported valued: absolute, byte, double, integer, long, single
        - Default datatype is double.
       CHARTTYPE         <chart type>       : Chart type; one of: Line,
                                              LineMarkers, LineStacked,
                                              LineStackedMarkers, LineStacked100,
                                              LineStacked100Markers, Line3D,
                                              LineOverlapped3D, LineStacked3D,
                                              LineStacked1003D, SmoothLine,
                                              SmoothLineMarkers, SmoothLineStacked
                                              , SmoothLineStackedMarkers,
                                              SmoothLineStacked100, SmoothLineStac
                                              ked100Markers, BarClustered,
                                              BarStacked, BarStacked100, Bar3D,
                                              BarClustered3D, BarStacked3D,
                                              BarStacked1003D, ColumnClustered,
                                              ColumnStacked, ColumnStacked100,
                                              Column3D, ColumnClustered3D,
                                              ColumnStacked3D, ColumnStacked1003D,
                                              Pie, PieExploded, PieStacked, Pie3D,
                                              PieExploded3D, ScatterMarkers,
                                              ScatterSmoothLine, ScatterSmoothLine
                                              Markers, ScatterLine, ScatterLineMar
                                              kers, ScatterLineFilled, Bubble,
                                              BubbleLine, Area, AreaStacked,
                                              AreaStacked100, Area3D, AreaOverlapp
                                              ed3D, AreaStacked3D, AreaStacked1003
                                              D, Doughnut, DoughnutExploded,
                                              RadarLine, RadarLineMarkers,
                                              RadarLineFilled, RadarSmoothLine,
                                              RadarSmoothLineMarkers, StockHLC,
                                              StockOHLC, PolarMarkers, PolarLine,
                                              PolarLineMarkers, PolarSmoothLine,
                                              PolarSmoothLineMarkers [default
                                              value=Line]
       CATEGORIES        ON|OFF|AUTO        : Display categories along the X-Axis;
                                              if AUTO, will display categories if
                                              the fields in the first column are
                                              STRING values [default value=AUTO]
       MAXCATEGORYLABELS <max categories>   : Maximum number of category labels
                                              displayed along the X-Axis (0=auto,
                                              -1=unlimited) [default value=0]
       LEGEND            ON|OFF|AUTO        : Print legend for each series; if
                                              AUTO, will print legend if there are
                                              2 or more series [default
                                              value=AUTO]
       VALUES            ON|OFF|AUTO        : Print value labels; if AUTO, will
                                              decide based on the chart type
                                              [default value=AUTO]
       GROUPSIZE         <width>x<height>   : Image size [default value=640x480]
       CHARTTITLE        <any string>       : Title of this chart; if 'Auto' and 1
                                              series only, will use the series'
                                              field name [default value=Auto]
       OTSFORMAT         <timestamp format> : Format in which TIMESTAMP fields are
                                              rendered [default value=yyyy-MM-dd      
       TEXT              <CHART>Text</CHART>: The variable name of the counter to 
                                              chart.
    -->
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Processor(*)\% Processor Time" DATASOURCE="\Processor(*)\% Processor Time" DATATYPE="Integer" ORDERBY="ASC" />
    <DESCRIPTION><![CDATA[% Processor Time is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the duration of the idle thread is active in the sample interval, and subtracting that time from interval duration.  (Each processor has an idle thread that consumes cycles when no other threads are ready to run). This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. It is calculated by monitoring the time that the service is inactive, and subtracting that value from 100%.

This analysis checks for utilization greater than 60% on each individual processor. If so, determine if it is high user mode CPU or high privileged mode. If high privileged mode CPU is suspected, then see the Privileged Mode CPU Analysis. If a user-mode processor bottleneck is suspected, then consider using a process profiler to analyze the functions causing the high CPU consumption. See “How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment” article in the references section for more information.<BR>
<BR>
If a user-mode processor bottleneck is suspected, then consider using a process profiler to analyze the functions causing the high CPU consumption. See “How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment” article in the references section for more information.<BR>
<BR>
<B>References:</B><BR>
Measuring .NET Application Performance<BR>
http://msdn2.microsoft.com/en-us/library/ms998579.aspx<BR>
<BR>
How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Utilization Analysis" ENABLED="True" ANALYZECOUNTER="\Network Interface(*)\Bytes Total/sec" CATEGORY="Network">
    <COUNTER NAME="\Network Interface(*)\Bytes Total/sec" MINVARNAME="MinNetworkInterfaceBytesTotalPerSec" AVGVARNAME="AvgNetworkInterfaceBytesTotalPerSec" MAXVARNAME="MaxNetworkInterfaceBytesTotalPerSec" TRENDVARNAME="TrendNetworkInterfaceBytesTotalPerSec" DATATYPE="Integer" />
    <COUNTER NAME="\Network Interface(*)\Current Bandwidth" MINVARNAME="MinNetworkInterfaceCurrentBandwidth" AVGVARNAME="AvgNetworkInterfaceCurrentBandwidth" MAXVARNAME="MaxNetworkInterfaceCurrentBandwidth" TRENDVARNAME="TrendNetworkInterfaceCurrentBandwidth" DATATYPE="Integer" />
    <THRESHOLD NAME="High average network utilization - more than 50%" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks to see if <B>50%</B> or more of the total network utilization is being used. If so, then the computer is using a lot of network bandwidth.
        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim BitsPerSec, PercentOfNetworkUtilized, PercentNetworkUtilizationThreshold
If AvgNetworkInterfaceBytesTotalPerSec > 0 AND AvgNetworkInterfaceCurrentBandwidth > 0 Then
 PercentNetworkUtilizationThreshold = 50
 BitsPerSec = Round(AvgNetworkInterfaceBytesTotalPerSec) * 8
 PercentOfNetworkUtilized = (BitsPerSec * 100) / AvgNetworkInterfaceCurrentBandwidth
 If AvgNetworkInterfaceBytesTotalPerSec > 0 Then
   If PercentOfNetworkUtilized > PercentNetworkUtilizationThreshold Then
     IsAvgThresholdBroken = True
   End If
 End If
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Very high average network utilization - more than 80%" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[Checks to see if <B>80%</B> or more of the total network utilization is being used. If so, then the computer is using a lot of network bandwidth.
        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim BitsPerSec, PercentOfNetworkUtilized, PercentNetworkUtilizationThreshold
If AvgNetworkInterfaceBytesTotalPerSec > 0 AND AvgNetworkInterfaceCurrentBandwidth > 0 Then
 PercentNetworkUtilizationThreshold = 80
 BitsPerSec = Round(AvgNetworkInterfaceBytesTotalPerSec) * 8
 PercentOfNetworkUtilized = (BitsPerSec * 100) / AvgNetworkInterfaceCurrentBandwidth
 If AvgNetworkInterfaceBytesTotalPerSec > 0 Then
   If PercentOfNetworkUtilized > PercentNetworkUtilizationThreshold Then
     IsAvgThresholdBroken = True
   End If
 End If
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Network Interface(*)\Bytes Total/sec" DATASOURCE="\Network Interface(*)\Bytes Total/sec" DATATYPE="Integer" />
    <DESCRIPTION><![CDATA[Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Received/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec. This counter indicates the rate at which bytes are sent and received over each network adapter. This counter helps you know whether the traffic at your network adapter is saturated and if you need to add another network adapter. How quickly you can identify a problem depends on the type of network you have as well as whether you share bandwidth with other applications.<BR>
<BR>
This analysis converts Bytes Total/sec to bits and compares it to the current bandwidth of the network adapter to calculate network utilization. Next, it checks for utilization above 50%.
<BR>
<B>Reference:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Queue Length" ENABLED="True" ANALYZECOUNTER="\System\Processor Queue Length" CATEGORY="Processor">
    <COUNTER NAME="\System\Processor Queue Length" MINVARNAME="MinQueue" AVGVARNAME="AvgQueue" MAXVARNAME="MaxQueue" TRENDVARNAME="TrendQueue" DATATYPE="Integer" />
    <THRESHOLD NAME="Each processor has 10 or more threads waiting" CONDITION="WARNING" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[
        Determines if the average processor queue length exceeds the <B>number of processors</B> by 10. If this threshold is broken, then the processor(s) may be at capacity.
        ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgQueue => (NumberOfProcessors * 10) Then
  IsAvgThresholdBroken = True
End If
If MaxQueue => (NumberOfProcessors * 10) Then
  IsMaxThresholdBroken = True
End If
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Each processor has 20 or more threads waiting" CONDITION="CRITICAL" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[
        Determines if the average processor queue length exceeds <B>twenty times the number of processors</B>. If this threshold is broken, then the processor(s) are beyond capacity.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        If AvgQueue => (NumberOfProcessors * 20) Then
  			IsAvgThresholdBroken = True
				End If
				If MaxQueue => (NumberOfProcessors * 20) Then
  			IsMaxThresholdBroken = True
				End If
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\System\Processor Queue Length" DATASOURCE="\System\Processor Queue Length" DATATYPE="Integer" />
    <DESCRIPTION><![CDATA[Processor Queue Length is the number of threads in the processor queue.  Unlike the disk counters, this counter counters, this counter shows ready threads only, not threads that are running.  There is a single queue for processor time even on computers with multiple processors. Therefore, if a computer has multiple processors, you need to divide this value by the number of processors servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, dependent of the workload.<BR>
<BR>
This analysis determines if the average processor queue length exceeds the number of processors. If so, then this could indicate a processor bottleneck. Use this analysis in correlation with Privileged Mode CPU Analysis and “Excessive Processor Use by Process” analysis.<BR>
<BR>
If there are more tasks ready to run than there are processors, threads queue up. The processor queue is the collection of threads that are ready but not able to be executed by the processor because another active thread is currently executing. A sustained or recurring queue of more threads than number of processors is a good indication of a processor bottleneck.<BR>
<BR>
You can use this counter in conjunction with the Processor\% Processor Time counter to determine if your application can benefit from more CPUs. There is a single queue for processor time, even on multiprocessor computers. Therefore, in a multiprocessor computer, divide the Processor Queue Length (PQL) value by the number of processors servicing the workload.<BR>
<BR>
If the CPU is very busy (90 percent and higher utilization) and the PQL average is consistently higher than the number of processors, then you may have a processor bottleneck that could benefit from additional CPUs. Or, you could reduce the number of threads and queue more at the application level. This will cause less context switching, and less context switching is good for reducing CPU load. The common reason for a high PQL with low CPU utilization is that requests for processor time arrive randomly and threads demand irregular amounts of time from the processor. This means that the processor is not a bottleneck but that it is your threading logic that needs to be improved.<BR>
<BR>
If a user-mode processor bottleneck is suspected, then consider using a process profiler to analyze the functions causing the high CPU consumption. See “How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment” article in the references section for more information.<BR>
<BR>
<B>Reference:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A><BR>
<BR>
How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Privileged Mode CPU Analysis" ENABLED="True" ANALYZECOUNTER="\Processor(*)\% Privileged Time" CATEGORY="Processor">
    <COUNTER NAME="\Processor(*)\% Processor Time" MINVARNAME="MinProcessor" AVGVARNAME="AvgProcessor" MAXVARNAME="MaxProcessor" TRENDVARNAME="TrendProcessor" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
    </COUNTER>
    <COUNTER NAME="\Processor(*)\% Privileged Time" MINVARNAME="MinPrivProcessor" AVGVARNAME="AvgPrivProcessor" MAXVARNAME="MaxPrivProcessor" TRENDVARNAME="TrendPrivProcessor" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
    </COUNTER>
    <THRESHOLD NAME="More than 30% CPU in Privileged Mode CPU - This may indicate a high I/O issue" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[If the privileged mode CPU is greater than <B>30%</B> of the total CPU and if total CPU exceeds 50%, then this threshold will break. This theshold indicates that the system is beginning to spend too much time in system I/O. This is sometimes an indicator that there is another system bottleneck elsewhere such as too many threads, too little memory, high latency disks or network, etc.]]></DESCRIPTION>
      <CODE><![CDATA[Dim PercentageOfPrivilegedModeCPUToTotalCPU
                
If AvgPrivProcessor > 0 Then
 PercentageOfPrivilegedModeCPUToTotalCPU = (AvgPrivProcessor * 100) / AvgProcessor        
 If PercentageOfPrivilegedModeCPUToTotalCPU > 30 AND AvgProcessor > 50 Then
  IsAvgThresholdBroken = True
 End If
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Spike of more than 30% CPU in Privileged Mode CPU - This may indicate a spike of high I/O" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="40">
      <DESCRIPTION><![CDATA[If the privileged mode CPU is greater than <B>30%</B> of the total CPU and if total CPU exceeds 50%, then this threshold will break. This theshold indicates that the system is spending too much time in system I/O. This is sometimes an indicator that there is another system bottleneck elsewhere such as too many threads, too little memory, high latency disks or network, etc.        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim PercentageOfPrivilegedModeCPUToTotalCPU
                
If MaxPrivProcessor > 0 Then
 PercentageOfPrivilegedModeCPUToTotalCPU = (MaxPrivProcessor * 100) / MaxProcessor
 If PercentageOfPrivilegedModeCPUToTotalCPU > 30 AND MaxProcessor > 50 Then
  IsMaxThresholdBroken = True
 End If
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Processor(*)\% Privileged Time" DATASOURCE="\Processor(*)\% Privileged Time" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
    </CHART>
    <DESCRIPTION><![CDATA[This counter indicates the percentage of time a thread runs in privileged mode. When your application calls operating system functions (for example to perform file or network I/O or to allocate memory), these operating system functions are executed in privileged mode.<BR>
<BR>
High privileged mode CPU indicates that computer is spending too much time in system I/O versus real (user mode) work. % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.<BR>
<BR>
This analysis checks to see if privileged mode CPU is consuming more than 30% of total CPU. If so, then the CPU consumption is likely caused by another bottleneck other than the processor such as network, memory, or disk I/O.<BR>
<BR>
<B>References:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Physical Disk Read Latency Analysis" ENABLED="True" ANALYZECOUNTER="\PhysicalDisk(*)\Avg. Disk sec/Read" CATEGORY="Disk">
    <COUNTER NAME="\PhysicalDisk(*)\Avg. Disk sec/Read" MINVARNAME="MinRead" AVGVARNAME="AvgRead" MAXVARNAME="MaxRead" TRENDVARNAME="TrendRead" DATATYPE="Round3" />
    <THRESHOLD NAME="Average disk responsiveness is slow - more than 20ms" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks to see if the response times are greater than <B>.020 (20 milliseconds)</B>. This disk subsystem is keeping up with demand, but does not have much overhead left.]]></DESCRIPTION>
      <CODE><![CDATA[Dim TimeInMilliseconds
TimeInMilliseconds = 0.020
If AvgRead > TimeInMilliseconds Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Average disk responsiveness is very slow - more than 50ms" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[Checks to see if the response times are greater than <B>.050 (50 milliseconds)</B>. Noticeable slow downs and performance issues affecting users may begin to occur.]]></DESCRIPTION>
      <CODE><![CDATA[Dim TimeInMilliseconds
TimeInMilliseconds = 0.050        
If AvgRead > TimeInMilliseconds Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\PhysicalDisk(*)\Avg. Disk sec/Read" DATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Read" DATATYPE="Round3" />
    <THRESHOLD NAME="Disk responsiveness is very slow (spike of more than 100ms)" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="40">
      <DESCRIPTION><![CDATA[Checks to see if the spikes' response times are greater than <B>.100 (100 milliseconds)</B>. Noticeable slow downs and performance issues affecting users may begin to occur.]]></DESCRIPTION>
      <CODE><![CDATA[Dim TimeInMilliseconds
TimeInMilliseconds = 0.100
If MaxRead > TimeInMilliseconds Then
  IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Read is the average time, in seconds, of a read of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.020 (20 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.050 (50 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
CAS Servers overall should not be disk intensive as most operations should be handled in memory. If excessive disk use is found, then we either have too much load on the server or more memory is needed to handle the overall load.<br>
<br>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Physical Disk Write Latency Analysis" ENABLED="True" ANALYZECOUNTER="\PhysicalDisk(*)\Avg. Disk sec/Write" CATEGORY="Disk">
    <COUNTER NAME="\PhysicalDisk(*)\Avg. Disk sec/Write" MINVARNAME="MinWrite" AVGVARNAME="AvgWrite" MAXVARNAME="MaxWrite" TRENDVARNAME="TrendWrite" DATATYPE="Round3" />
    <THRESHOLD NAME="Average disk responsiveness is slow - more than 20ms" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[
        Over <B>.020</B> (20 milliseconds) is beginning to show signs of slow performance. Slow downs and performance issues affecting users may begin to occur.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.020
        If AvgWrite > TimeInMilliseconds Then
          IsAvgThresholdBroken = True
        End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Average disk responsiveness is very slow - more than 50ms" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[
        Over <B>.050</B> (50 milliseconds) is Serious to Critical. Noticeable slow downs and performance issues affecting users begin to occur.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.050
        If AvgWrite > TimeInMilliseconds Then
          IsAvgThresholdBroken = True
        End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\PhysicalDisk(*)\Avg. Disk sec/Write" DATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Write" DATATYPE="Integer" />
    <THRESHOLD NAME="Disk responsiveness is very slow (spike of more than 100ms)" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="40">
      <DESCRIPTION><![CDATA[Checks to see if the response times are greater than <B>.100 (100 milliseconds)</B>. Noticeable slow downs and performance issues affecting users may begin to occur.]]></DESCRIPTION>
      <CODE><![CDATA[        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.100
        If MaxWrite > TimeInMilliseconds Then
          IsMaxThresholdBroken = True
        End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.020 (20 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.050 (50 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
CAS Servers overall should not be disk intensive as most operations should be handled in memory. If excessive disk use is found, then we either have too much load on the server or more memory is needed to handle the overall load.<br>
<br>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Logical Disk Read Latency Analysis" ENABLED="True" ANALYZECOUNTER="\LogicalDisk(*)\Avg. Disk sec/Read" CATEGORY="Disk">
    <COUNTER NAME="\LogicalDisk(*)\Avg. Disk sec/Read" MINVARNAME="MinRead" AVGVARNAME="AvgRead" MAXVARNAME="MaxRead" TRENDVARNAME="TrendRead" DATATYPE="Round3" />
    <THRESHOLD NAME="Average disk responsiveness is slow - more than 20ms" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[
        Checks to see if the response times are greater than <B>.020 (20 milliseconds)</B>. This disk subsystem is keeping up with demand, but does not have much overhead left.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.020
        If AvgRead >TimeInMilliseconds Then
          IsAvgThresholdBroken = True
        End If       
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Average disk responsiveness is very slow - more than 50ms" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[
        Checks to see if the response times are greater than <B>.050 (50 milliseconds)</B>. Noticeable slow downs and performance issues affecting users may begin to occur.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.050       
        If AvgRead > TimeInMilliseconds Then
          IsAvgThresholdBroken = True
        End If    
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Read" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Read" DATATYPE="Round3" />
    <THRESHOLD NAME="Disk responsiveness is very slow (spike of more than 100ms)" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="40">
      <DESCRIPTION><![CDATA[Checks to see if the response times are greater than <B>.100 (100 milliseconds)</B>. Noticeable slow downs and performance issues affecting users may begin to occur.]]></DESCRIPTION>
      <CODE><![CDATA[        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.100
        If MaxRead > TimeInMilliseconds Then
          IsMaxThresholdBroken = True
        End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Read is the average time, in seconds, of a read of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.020 (20 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.050 (50 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
CAS Servers overall should not be disk intensive as most operations should be handled in memory. If excessive disk use is found, then we either have too much load on the server or more memory is needed to handle the overall load.<br>
<br>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Logical Disk Write Latency Analysis" ENABLED="True" ANALYZECOUNTER="\LogicalDisk(*)\Avg. Disk sec/Write" CATEGORY="Disk">
    <COUNTER NAME="\LogicalDisk(*)\Avg. Disk sec/Write" MINVARNAME="MinWrite" AVGVARNAME="AvgWrite" MAXVARNAME="MaxWrite" TRENDVARNAME="TrendWrite" DATATYPE="Round3" />
    <THRESHOLD NAME="Average disk responsiveness is slow - more than 20ms" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[
        Over <B>.020</B> (20 milliseconds) is beginning to show signs of slow performance. Slow downs and performance issues affecting users may begin to occur.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.020
        If AvgWrite > TimeInMilliseconds Then
          IsAvgThresholdBroken = True
        End If      
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Average disk responsiveness is very slow - more than 50ms" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[
        Over <B>.050</B> (50 milliseconds) is Serious to Critical. Noticeable slow downs and performance issues affecting users begin to occur.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.050
        If AvgWrite > TimeInMilliseconds Then
          IsAvgThresholdBroken = True
        End If
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Write" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Write" DATATYPE="Integer" />
    <THRESHOLD NAME="Disk responsiveness is very slow (spike of more than 100ms)" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="40">
      <DESCRIPTION><![CDATA[Checks to see if the response times are greater than <B>.100 (25 milliseconds)</B>. Noticeable slow downs and performance issues affecting users may begin to occur.]]></DESCRIPTION>
      <CODE><![CDATA[        Dim TimeInMilliseconds
        TimeInMilliseconds = 0.100
        If MaxWrite > TimeInMilliseconds Then
          IsMaxThresholdBroken = True
        End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.020 (20 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.050 (50 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
CAS Servers overall should not be disk intensive as most operations should be handled in memory. If excessive disk use is found, then we either have too much load on the server or more memory is needed to handle the overall load.<br>
<br>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Free System Page Table Entries" ENABLED="True" ANALYZECOUNTER="\Memory\Free System Page Table Entries" CATEGORY="Memory">
    <COUNTER NAME="\Memory\Free System Page Table Entries" MINVARNAME="MinPTEs" AVGVARNAME="AvgPTEs" MAXVARNAME="MaxPTEs" TRENDVARNAME="TrendPTEs" DATATYPE="Integer" />
    <THRESHOLD NAME="Running low on PTE's - less than 10,000" CONDITION="WARNING" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[
        If MinPTEs < 10000 Then
          IsMinThresholdBroken = True
        End If      
        If AvgPTEs < 10000 Then
          IsAvgThresholdBroken = True
        End If
        ]]></CODE>
      <DESCRIPTION><![CDATA[
        Checks to see if free PTEs are under <B>10,000</B>. If so, the system is close to a system wide hang. Consider removing the use of the /3GB switch and/or consider migrating to a 64-bit computer.
        ]]></DESCRIPTION>
    </THRESHOLD>
    <THRESHOLD NAME="Critically low on PTE's - less than 5000" CONDITION="CRITICAL" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[
        If MinPTEs < 5000 Then
          IsMinThresholdBroken = True
        End If         
        If AvgPTEs < 5000 Then
          IsAvgThresholdBroken = True
        End If
        ]]></CODE>
      <DESCRIPTION><![CDATA[
        Checks to see if free PTEs are under <B>5,000</B>. If so, the system could be experiencing system wide hangs. Consider removing the use of the /3GB switch and/or consider migrating to a 64-bit computer.
        ]]></DESCRIPTION>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Memory\Free System Page Table Entries" DATASOURCE="\Memory\Free System Page Table Entries" DATATYPE="Integer" />
    <DESCRIPTION><![CDATA[Free System Page Table Entries is the number of page table entries not currently in used by the system. This analysis determines if the system is running out of free system page table entries (PTEs) by checking if there is less than 5,000 free PTE’s with a Warning if there is less than 10,000 free PTE’s. Lack of enough PTEs can result in system wide hangs. Also note that the /3GB switch will lower the amount of free PTEs significantly. <BR>
<BR>
The Performance Monitor “Memory\Free System Page Table Entries” counter is inaccurate on installations of Windows Server 2003 without Service Pack 1. For more information about this counter, see Microsoft Knowledge Base article 894067 “The Performance tool does not accurately show the available Free System Page Table entries in Windows Server 2003” <a href="http://go.microsoft.com/fwlink/?linkid=3052&kbid=894067">http://go.microsoft.com/fwlink/?linkid=3052&amp;kbid=894067</a><BR>
<BR>
<B>Fix for Win2003 SP1 systems with /3GB and low on PTE’s:</B> If the system is low on PTE’s, running Windows 2003, and using /3GB switch, then consider using the /USERVA switch to give back some of the memory to the kernel. Note, this only works for Free System PTE issues.<BR>
<BR>
For more information on the USERVA switch, go to:
How to use the /userva switch with the /3GB switch to tune the User-mode space to a value between 2 GB and 3 GB
<A HREF="http://support.microsoft.com/kb/316739">http://support.microsoft.com/kb/316739</A><BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A><BR>
<BR>
Microsoft Knowledge Base article 894067 “The Performance tool does not accurately show the available Free System Page Table entries in Windows Server 2003” http://go.microsoft.com/fwlink/?linkid=3052&amp;kbid=894067<BR>
<BR>
“How to use the /userva switch with the /3GB switch to tune the User-mode space to a value between 2 GB and 3 GB”  http://support.microsoft.com/kb/316739">http://support.microsoft.com/kb/316739<BR>
<BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Pool Non Paged Bytes" ENABLED="True" ANALYZECOUNTER="\Memory\Pool Nonpaged Bytes" CATEGORY="Memory">
    <COUNTER NAME="\Memory\Pool Nonpaged Bytes" MINVARNAME="MinPoolNonPagedBytes" AVGVARNAME="AvgPoolNonPagedBytes" MAXVARNAME="MaxPoolNonPagedBytes" TRENDVARNAME="TrendPoolNonPagedBytes" DATATYPE="Integer" />
    <THRESHOLD NAME="Low on Pool NonPaged memory - less than 40% available" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks to see if the system exceeds <B>60%</B> of the Pool Non-paged bytes memory pool. If so, consider removing the /3GB switch or consider migrating to a 64-bit system.
        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim iMemPoolMax, SixtyPercentOfMemoryPoolMaximum, MemoryPoolMaxInMegabytes, iTotalMemory
' Determine the maximum memory pool size.
iTotalMemory = Round(TotalMemory)
If SixtyFourBit = False Then
    If ThreeGBSwitch = True Then
      SELECT CASE iTotalMemory
        CASE 1
          iMemPoolMax = 131
        CASE 2
          iMemPoolMax = 131
        CASE 3
          iMemPoolMax = 131
        CASE 4
          iMemPoolMax = 154
        CASE 5
          iMemPoolMax = 154
        CASE 6
          iMemPoolMax = 131
        CASE 7
          iMemPoolMax = 131
        CASE 8
          iMemPoolMax = 131
        CASE Else
          iMemPoolMax = 131        
      END SELECT      
    Else
      SELECT CASE iTotalMemory
        CASE 1
          iMemPoolMax = 212
        CASE 2
          iMemPoolMax = 262
        CASE 3
          iMemPoolMax = 262
        CASE 4
          iMemPoolMax = 285
        CASE 5
          iMemPoolMax = 285
        CASE 6
          iMemPoolMax = 262
        CASE 7
          iMemPoolMax = 262
        CASE 8
          iMemPoolMax = 262
        CASE Else
          iMemPoolMax = 262       
      END SELECT
    End If
Else
  SELECT CASE iTotalMemory
    CASE 1
      iMemPoolMax = 872
    CASE 2
      iMemPoolMax = 872
    CASE 3
      iMemPoolMax = 872
    CASE 4
      iMemPoolMax = 1420
    CASE 5
      iMemPoolMax = 1420
    CASE 6
      iMemPoolMax = 1420
    CASE 7
      iMemPoolMax = 1420
    CASE 8
      iMemPoolMax = 3090
    CASE 9
      iMemPoolMax = 3090
    CASE 10
      iMemPoolMax = 3090
    CASE 11
      iMemPoolMax = 3090
    CASE 12
      iMemPoolMax = 4720
    CASE 13
      iMemPoolMax = 4720 
    CASE 14
      iMemPoolMax = 4720 
    CASE 15
      iMemPoolMax = 4720 
    CASE 16
      iMemPoolMax = 6360 
    CASE 17
      iMemPoolMax = 6360 
    CASE 18
      iMemPoolMax = 6360 
    CASE 19
      iMemPoolMax = 6360 
    CASE 20
      iMemPoolMax = 6360 
    CASE 21
      iMemPoolMax = 6360 
    CASE 22
      iMemPoolMax = 6360 
    CASE 23
      iMemPoolMax = 6360 
    CASE 24
      iMemPoolMax = 9640 
    CASE 25
      iMemPoolMax = 9640 
    CASE 26
      iMemPoolMax = 9640 
    CASE 27
      iMemPoolMax = 9640 
    CASE 28
      iMemPoolMax = 9640 
    CASE 29
      iMemPoolMax = 9640 
    CASE 30
      iMemPoolMax = 9640 
    CASE 31
      iMemPoolMax = 9640 
    CASE 32
      iMemPoolMax = 13220                                                                                                                                            
    CASE Else
      iMemPoolMax = 13220       
  END SELECT
End If
MemoryPoolMaxInMegabytes = iMemPoolMax * 1024 * 1000
SixtyPercentOfMemoryPoolMaximum = MemoryPoolMaxInMegabytes * 0.60
If AvgPoolNonPagedBytes > SixtyPercentOfMemoryPoolMaximum Then
  IsAvgThresholdBroken = True
End If
If MaxPoolNonPagedBytes > SixtyPercentOfMemoryPoolMaximum Then
  IsMaxThresholdBroken = True
End If    ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Critically low on Pool NonPaged memory - less than 20% available" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[Checks to see if the system exceeds <B>80%</B> of the Pool Non-paged bytes memory pool. If so, consider removing the /3GB switch or consider migrating to a 64-bit system.        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim iMemPoolMax, PercentOfMemoryPoolMaximum, MemoryPoolMaxInMegabytes, iTotalMemory
' Determine the maximum memory pool size.
iTotalMemory = Round(TotalMemory)
If SixtyFourBit = False Then
    If ThreeGBSwitch = True Then
      SELECT CASE iTotalMemory
        CASE 1
          iMemPoolMax = 131
        CASE 2
          iMemPoolMax = 131
        CASE 3
          iMemPoolMax = 131
        CASE 4
          iMemPoolMax = 154
        CASE 5
          iMemPoolMax = 154
        CASE 6
          iMemPoolMax = 131
        CASE 7
          iMemPoolMax = 131
        CASE 8
          iMemPoolMax = 131
        CASE Else
          iMemPoolMax = 131        
      END SELECT      
    Else
      SELECT CASE iTotalMemory
        CASE 1
          iMemPoolMax = 212
        CASE 2
          iMemPoolMax = 262
        CASE 3
          iMemPoolMax = 262
        CASE 4
          iMemPoolMax = 285
        CASE 5
          iMemPoolMax = 285
        CASE 6
          iMemPoolMax = 262
        CASE 7
          iMemPoolMax = 262
        CASE 8
          iMemPoolMax = 262
        CASE Else
          iMemPoolMax = 262       
      END SELECT
    End If
Else
  SELECT CASE iTotalMemory
    CASE 1
      iMemPoolMax = 872
    CASE 2
      iMemPoolMax = 872
    CASE 3
      iMemPoolMax = 872
    CASE 4
      iMemPoolMax = 1420
    CASE 5
      iMemPoolMax = 1420
    CASE 6
      iMemPoolMax = 1420
    CASE 7
      iMemPoolMax = 1420
    CASE 8
      iMemPoolMax = 3090
    CASE 9
      iMemPoolMax = 3090
    CASE 10
      iMemPoolMax = 3090
    CASE 11
      iMemPoolMax = 3090
    CASE 12
      iMemPoolMax = 4720
    CASE 13
      iMemPoolMax = 4720 
    CASE 14
      iMemPoolMax = 4720 
    CASE 15
      iMemPoolMax = 4720 
    CASE 16
      iMemPoolMax = 6360 
    CASE 17
      iMemPoolMax = 6360 
    CASE 18
      iMemPoolMax = 6360 
    CASE 19
      iMemPoolMax = 6360 
    CASE 20
      iMemPoolMax = 6360 
    CASE 21
      iMemPoolMax = 6360 
    CASE 22
      iMemPoolMax = 6360 
    CASE 23
      iMemPoolMax = 6360 
    CASE 24
      iMemPoolMax = 9640 
    CASE 25
      iMemPoolMax = 9640 
    CASE 26
      iMemPoolMax = 9640 
    CASE 27
      iMemPoolMax = 9640 
    CASE 28
      iMemPoolMax = 9640 
    CASE 29
      iMemPoolMax = 9640 
    CASE 30
      iMemPoolMax = 9640 
    CASE 31
      iMemPoolMax = 9640 
    CASE 32
      iMemPoolMax = 13220                                                                                                                                            
    CASE Else
      iMemPoolMax = 13220       
  END SELECT
End If
MemoryPoolMaxInMegabytes = iMemPoolMax * 1024 * 1000
PercentOfMemoryPoolMaximum = MemoryPoolMaxInMegabytes * 0.80
If AvgPoolNonPagedBytes > PercentOfMemoryPoolMaximum Then
  IsAvgThresholdBroken = True
End If
If MaxPoolNonPagedBytes > PercentOfMemoryPoolMaximum Then
  IsMaxThresholdBroken = True
End If    ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Memory\Pool Nonpaged Bytes" DATASOURCE="\Memory\Pool Nonpaged Bytes" DATATYPE="Integer" />
    <DESCRIPTION><![CDATA[Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.<BR>
<BR>
This analysis checks to see if the system is becoming close to the maximum Pool Nonpaged memory size. It does this by estimating the pool sizes taking into consideration /3GB, physical memory size, and 32-bit/64-bit, then determining if the value is higher than 60% of the estimated pool size. If the system becomes close to the maximum size, then the system could experience system wide hangs. Checks both 32-bit and 64-bit memory pools. Warning: The /3GB switch option in the boot.ini file significantly reduces the size of this memory pool.<BR>
<BR>
If the system is low on Paged Pool or non-Paged pool memory, then it is recommended to open a support case with Microsoft to address this. Alternatively, you can use a free and public tool called Poolmon.exe to see what DLL’s are using kernel memory (see the article below). Most kernel memory leaks can be tracked back to a usermode process. To identify which user mode process is responsible, reboot the system (so you start off with a clean system), start a performance monitor log intending to run for a week or more capturing the Memory and Process objects, then analyze the perfmon log looking for memory leaks and/or handle leaks in one or more of the processes. In any case, migrating to a 64-bit version of Windows should alleviate this issue.
<BR>
<B>References:</B><BR>
How to Use Memory Pool Monitor (Poolmon.exe) to Troubleshoot Kernel Mode Memory Leaks<BR>
<A HREF="http://support.microsoft.com/kb/177415">http://support.microsoft.com/kb/177415</A><BR>
<BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A><BR>
<BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Pool Paged Bytes" ENABLED="True" ANALYZECOUNTER="\Memory\Pool Paged Bytes" CATEGORY="Memory">
    <COUNTER NAME="\Memory\Pool Paged Bytes" MINVARNAME="MinPoolPagedBytes" AVGVARNAME="AvgPoolPagedBytes" MAXVARNAME="MaxPoolPagedBytes" TRENDVARNAME="TrendPoolPagedBytes" DATATYPE="Integer" />
    <THRESHOLD NAME="Low on Pool Paged memory - less than 40% available" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks to see if the system exceeds <B>60%</B> of the Pool paged bytes memory pool. If so, consider removing the /3GB switch or consider migrating to a 64-bit system.        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim iMemPoolMax, PercentOfMemoryPoolMaximum, MemoryPoolMaxInMegabytes, iTotalMemory
' Determine the maximum memory pool size.
iTotalMemory = Round(TotalMemory)
If SixtyFourBit = False Then
    If ThreeGBSwitch = True Then
      SELECT CASE iTotalMemory
        CASE 1
          iMemPoolMax = 163
        CASE 2
          iMemPoolMax = 262
        CASE 3
          iMemPoolMax = 262
        CASE 4
          iMemPoolMax = 258
        CASE 5
          iMemPoolMax = 258
        CASE 6
          iMemPoolMax = 239
        CASE 7
          iMemPoolMax = 239
        CASE 8
          iMemPoolMax = 225
        CASE 9
          iMemPoolMax = 225
        CASE 10
          iMemPoolMax = 225
        CASE 11
          iMemPoolMax = 225
        CASE 12
          iMemPoolMax = 196
        CASE 13
          iMemPoolMax = 196
        CASE 14
          iMemPoolMax = 196
        CASE 15
          iMemPoolMax = 196
        CASE 16
          iMemPoolMax = 169                                                                                
        CASE Else
          iMemPoolMax = 169        
      END SELECT      
    Else
      SELECT CASE iTotalMemory
        CASE 1
          iMemPoolMax = 282
        CASE 2
          iMemPoolMax = 360
        CASE 3
          iMemPoolMax = 360
        CASE 4
          iMemPoolMax = 360
        CASE 5
          iMemPoolMax = 360
        CASE 6
          iMemPoolMax = 366
        CASE 7
          iMemPoolMax = 366
        CASE 8
          iMemPoolMax = 366
        CASE Else
          iMemPoolMax = 366       
      END SELECT
    End If
Else
  SELECT CASE iTotalMemory
    CASE 1
      iMemPoolMax = 3480
    CASE 2
      iMemPoolMax = 3480
    CASE 3
      iMemPoolMax = 3480
    CASE 4
      iMemPoolMax = 5700
    CASE 5
      iMemPoolMax = 5700
    CASE 6
      iMemPoolMax = 5700
    CASE 7
      iMemPoolMax = 5700
    CASE 8
      iMemPoolMax = 12360
    CASE 9
      iMemPoolMax = 12360
    CASE 10
      iMemPoolMax = 12360
    CASE 11
      iMemPoolMax = 12360
    CASE 12
      iMemPoolMax = 18910
    CASE 13
      iMemPoolMax = 18910 
    CASE 14
      iMemPoolMax = 18910 
    CASE 15
      iMemPoolMax = 18910 
    CASE 16
      iMemPoolMax = 38570 
    CASE 17
      iMemPoolMax = 38570 
    CASE 18
      iMemPoolMax = 38570 
    CASE 19
      iMemPoolMax = 38570 
    CASE 20
      iMemPoolMax = 38570 
    CASE 21
      iMemPoolMax = 38570 
    CASE 22
      iMemPoolMax = 38570 
    CASE 23
      iMemPoolMax = 38570 
    CASE 24
      iMemPoolMax = 38570 
    CASE 25
      iMemPoolMax = 38570 
    CASE 26
      iMemPoolMax = 38570 
    CASE 27
      iMemPoolMax = 38570 
    CASE 28
      iMemPoolMax = 38570 
    CASE 29
      iMemPoolMax = 38570 
    CASE 30
      iMemPoolMax = 38570 
    CASE 31
      iMemPoolMax = 38570 
    CASE 32
      iMemPoolMax = 52910                                                                                                                                            
    CASE Else
      iMemPoolMax = 52910       
  END SELECT
End If
MemoryPoolMaxInMegabytes = iMemPoolMax * 1024 * 1000
PercentOfMemoryPoolMaximum = MemoryPoolMaxInMegabytes * 0.60
If AvgPoolPagedBytes > PercentOfMemoryPoolMaximum Then
  IsAvgThresholdBroken = True
End If
If MaxPoolPagedBytes > PercentOfMemoryPoolMaximum Then
  IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Critically low on Pool Paged memory - less than 20% available" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[Checks to see if the system exceeds <B>80%</B> of the Pool paged bytes memory pool. If so, consider removing the /3GB switch or consider migrating to a 64-bit system.        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim iMemPoolMax, PercentOfMemoryPoolMaximum, MemoryPoolMaxInMegabytes, iTotalMemory
' Determine the maximum memory pool size.
iTotalMemory = Round(TotalMemory)
If SixtyFourBit = False Then
    If ThreeGBSwitch = True Then
      SELECT CASE iTotalMemory
        CASE 1
          iMemPoolMax = 163
        CASE 2
          iMemPoolMax = 262
        CASE 3
          iMemPoolMax = 262
        CASE 4
          iMemPoolMax = 258
        CASE 5
          iMemPoolMax = 258
        CASE 6
          iMemPoolMax = 239
        CASE 7
          iMemPoolMax = 239
        CASE 8
          iMemPoolMax = 225
        CASE 9
          iMemPoolMax = 225
        CASE 10
          iMemPoolMax = 225
        CASE 11
          iMemPoolMax = 225
        CASE 12
          iMemPoolMax = 196
        CASE 13
          iMemPoolMax = 196
        CASE 14
          iMemPoolMax = 196
        CASE 15
          iMemPoolMax = 196
        CASE 16
          iMemPoolMax = 169                                                                                
        CASE Else
          iMemPoolMax = 169        
      END SELECT      
    Else
      SELECT CASE iTotalMemory
        CASE 1
          iMemPoolMax = 282
        CASE 2
          iMemPoolMax = 360
        CASE 3
          iMemPoolMax = 360
        CASE 4
          iMemPoolMax = 360
        CASE 5
          iMemPoolMax = 360
        CASE 6
          iMemPoolMax = 366
        CASE 7
          iMemPoolMax = 366
        CASE 8
          iMemPoolMax = 366
        CASE Else
          iMemPoolMax = 366       
      END SELECT
    End If
Else
  SELECT CASE iTotalMemory
    CASE 1
      iMemPoolMax = 3480
    CASE 2
      iMemPoolMax = 3480
    CASE 3
      iMemPoolMax = 3480
    CASE 4
      iMemPoolMax = 5700
    CASE 5
      iMemPoolMax = 5700
    CASE 6
      iMemPoolMax = 5700
    CASE 7
      iMemPoolMax = 5700
    CASE 8
      iMemPoolMax = 12360
    CASE 9
      iMemPoolMax = 12360
    CASE 10
      iMemPoolMax = 12360
    CASE 11
      iMemPoolMax = 12360
    CASE 12
      iMemPoolMax = 18910
    CASE 13
      iMemPoolMax = 18910 
    CASE 14
      iMemPoolMax = 18910 
    CASE 15
      iMemPoolMax = 18910 
    CASE 16
      iMemPoolMax = 38570 
    CASE 17
      iMemPoolMax = 38570 
    CASE 18
      iMemPoolMax = 38570 
    CASE 19
      iMemPoolMax = 38570 
    CASE 20
      iMemPoolMax = 38570 
    CASE 21
      iMemPoolMax = 38570 
    CASE 22
      iMemPoolMax = 38570 
    CASE 23
      iMemPoolMax = 38570 
    CASE 24
      iMemPoolMax = 38570 
    CASE 25
      iMemPoolMax = 38570 
    CASE 26
      iMemPoolMax = 38570 
    CASE 27
      iMemPoolMax = 38570 
    CASE 28
      iMemPoolMax = 38570 
    CASE 29
      iMemPoolMax = 38570 
    CASE 30
      iMemPoolMax = 38570 
    CASE 31
      iMemPoolMax = 38570 
    CASE 32
      iMemPoolMax = 52910                                                                                                                                            
    CASE Else
      iMemPoolMax = 52910       
  END SELECT
End If
MemoryPoolMaxInMegabytes = iMemPoolMax * 1024 * 1000
PercentOfMemoryPoolMaximum = MemoryPoolMaxInMegabytes * 0.80
If AvgPoolPagedBytes > PercentOfMemoryPoolMaximum Then
  IsAvgThresholdBroken = True
End If
If MaxPoolPagedBytes > PercentOfMemoryPoolMaximum Then
  IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Memory\Pool Paged Bytes" DATASOURCE="\Memory\Pool Paged Bytes" DATATYPE="Integer" />
    <DESCRIPTION><![CDATA[This analysis checks to see if the system is becoming close to the maximum Pool paged memory size. Pool Paged Bytes is the size, in bytes, of the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used.<BR>
<BR>
This analysis checks to see if the system is becoming close to the maximum Pool Paged memory size. It does this by estimating the pool sizes taking into consideration /3GB, physical memory size, and 32-bit/64-bit, then determining if the value is higher than 60% of the estimated pool size. If the system becomes close to the maximum size, then the system could experience system wide hangs. Checks both 32-bit and 64-bit memory pools. Warning: The /3GB switch option in the boot.ini file significantly reduces the size of this memory pool.<BR>
<BR>
If the system is low on Paged Pool or non-Paged pool memory, then it is recommended to open a support case with Microsoft to address this. Alternatively, you can use a free and public tool called Poolmon.exe to see what DLL’s are using kernel memory (see the article below). Most kernel memory leaks can be tracked back to a usermode process. To identify which user mode process is responsible, reboot the system (so you start off with a clean system), start a performance monitor log intending to run for a week or more capturing the Memory and Process objects, then analyze the perfmon log looking for memory leaks and/or handle leaks in one or more of the processes. In any case, migrating to a 64-bit version of Windows should alleviate this issue.<BR>
<BR>
<B>Reference:</B><BR>
How to Use Memory Pool Monitor (Poolmon.exe) to Troubleshoot Kernel Mode Memory Leaks<BR>
<A HREF="http://support.microsoft.com/kb/177415">http://support.microsoft.com/kb/177415</A><BR>
<BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A><BR>
<BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Available Memory" ENABLED="True" ANALYZECOUNTER="\Memory\Available MBytes" CATEGORY="Memory">
    <COUNTER NAME="\Memory\Available MBytes" MINVARNAME="MinAvailableMemory" AVGVARNAME="AvgAvailableMemory" MAXVARNAME="MaxAvailableMemory" TRENDVARNAME="TrendAvailableMemory" DATATYPE="Integer" />
    <THRESHOLD NAME="Low on available memory - less than 10% available" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the available memory is less than <B>10%</B> of the total amount of memory. If so, then continue to monitor this counter.]]></DESCRIPTION>
      <CODE><![CDATA[Dim TenPercentOfTotalMemory
TenPercentOfTotalMemory = TotalMemory * 1024 * 0.10
If MinAvailableMemory < TenPercentOfTotalMemory Then
  IsMinThresholdBroken = True
End If
If AvgAvailableMemory < TenPercentOfTotalMemory Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Very low on available memory - less than 5% available" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the available memory is less than <B>5%</B> of memory. If so, the system is low on memory and hangs or slow performance is likely occuring. Check to see which processes are taking up a large amount of physical memory (private bytes).]]></DESCRIPTION>
      <CODE><![CDATA[Dim FivePercentOfTotalMemory
FivePercentOfTotalMemory = TotalMemory * 1024 * 0.05
If MinAvailableMemory < FivePercentOfTotalMemory Then
  IsMinThresholdBroken = True
End If
If AvgAvailableMemory < FivePercentOfTotalMemory Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Memory\Available MBytes" DATASOURCE="\Memory\Available MBytes" DATATYPE="Integer" />
    <THRESHOLD NAME="Decreasing trend of 10MB's per hour" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks for a decreasing trend of 10MB's per hour. This could indicate a memory leak.]]></DESCRIPTION>
      <CODE><![CDATA[If TrendAvailableMemory <= -10 Then
 IsTrendThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Available MBytes is the amount of physical memory available to processes running on the computer, in Megabytes, rather than bytes as reported in Memory\Available Bytes. The Virtual Memory Manager continually adjusts the space used in physical memory and on disk to maintain a minimum number of available bytes for the operating system and processes. When available bytes are plentiful, the Virtual Memory Manager lets the working sets of processes grow, or keeps them stable by removing an old page for each new page added. When available bytes are few, the Virtual Memory Manager must trim the working sets of processes to maintain the minimum required.

This analysis checks to see if the total available memory is low – Warning at 10% available and Critical at 5% available. A Warning is also alerted when a decreasing trend of 10MB’s per hour is detecting indicating a potential upcoming memory condition. Low physical memory can cause increased privileged mode CPU and system delays. <BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A><BR>
<BR>
Detecting Memory Bottlenecks <br>
http://www.microsoft.com/resources/documentation/windowsnt/4/workstation/reskit/en-us/04memory.mspx?mfr=true ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages/sec" ENABLED="True" ANALYZECOUNTER="\Memory\Pages/sec" CATEGORY="Memory">
    <COUNTER NAME="\Memory\Pages/sec" MINVARNAME="MinPagesPerSec" AVGVARNAME="AvgPagesPerSec" MAXVARNAME="MaxPagesPerSec" TRENDVARNAME="TrendPagesPerSec" DATATYPE="Integer" />
    <THRESHOLD NAME="High pages/sec - greater than 1000" CONDITION="Warning" COLOR="#CCFF66" PRIORITY="20">
      <DESCRIPTION><![CDATA[
        Checks to see if Pages/sec is greater than <B>1000</B>. If so, the system is could be beginning to run out of memory or process working sets are getting trimmed. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        If AvgPagesPerSec > 1000 Then
          IsAvgThresholdBroken = True
        End If   
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Very high average pages/sec - greater than 2500" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[
        Checks to see if Pages/sec is greater than <B>2500</B>. If so, the system could be experiencing system-wide delays due to insufficient memory or excessive process working set trimming. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        If AvgPagesPerSec > 2500 Then
          IsAvgThresholdBroken = True
        End If  
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Critically high average pages/sec - greater than 5000" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[
        Checks to see if Pages/sec is greater than <B>5000</B>. If so, the system is most likely experiencing delays due to insufficient memory. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        If AvgPagesPerSec > 5000 Then
          IsAvgThresholdBroken = True
        End If     
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Memory\Pages/sec" DATASOURCE="\Memory\Pages/sec" DATATYPE="Integer" ORDERBY="ASC" />
    <THRESHOLD NAME="Spike in pages/sec - greater than 1000" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="15">
      <DESCRIPTION><![CDATA[Checks to see if Pages/sec is greater than <B>1000</B>. If so, the system is could be beginning to run out of memory. Consider reviewing the processes to see which processes are taking up the most memory or consider adding more memory.]]></DESCRIPTION>
      <CODE><![CDATA[        If MaxPagesPerSec > 5000 Then
          IsMaxThresholdBroken = True
        End If   
        ]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis checks to see if the Pages/sec is high. If it is high, then the system is likely running out of memory by trying to page the memory to the disk. Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. This counter is a primary indicator of the kinds of faults that cause system-wide delays.  It is the sum of Memory\Pages Input/sec and Memory\Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files.<BR>
<BR>
This counter should always be below 1000, therefore this analysis checks for values above 1000. Use this analysis in correlation with Available Memory Analysis and Memory Leak Analysis. All are throwing alerts at the same time, then this may indicate the system is running out of memory and the suspected processes involved and follow analysis steps mentioned in the Memory Leak analysis.<BR>
<BR>
<b>Role Specific</b>
<B>Reference:</B><BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A><BR>
<BR>
      ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Output Queue Length Analysis" ENABLED="True" ANALYZECOUNTER="\Network Interface(*)\Output Queue Length" CATEGORY="Network">
    <COUNTER NAME="\Network Interface(*)\Output Queue Length" MINVARNAME="MinOutputQueueLength" AVGVARNAME="AvgOutputQueueLength" MAXVARNAME="MaxOutputQueueLength" TRENDVARNAME="TrendOutputQueueLength" DATATYPE="Integer" />
    <THRESHOLD NAME="High Network I/O - more than 1 thread waiting on network I/O" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks to see if the output queue length is greater than <B>1</B>. If so, this system's network is nearing capacity. Consider analyzing network traffic to determine why network I/O is nearing capacity such as *chatty* network services and/or large data transfers.
        ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgOutputQueueLength > 1 Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Very high network I/O - more than 2 threads waiting on network I/O" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[Checks to see if the output queue length is greater than <B>2</B>. If so, this system's network is over capacity. Consider analyzing network traffic to determine why network I/O is nearing capacity such as *chatty* network services and/or large data transfers.
        ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgOutputQueueLength > 2 Then
  IsAvgThresholdBroken = True
End If
  
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Network Interface(*)\Output Queue Length" DATASOURCE="\Network Interface(*)\Output Queue Length" DATATYPE="Integer" />
    <DESCRIPTION><![CDATA[This analysis checks to see how many threads are waiting on the network adapter. If there are a lot of threads waiting on the network adapter, then the system is most likely saturating the network I/O most likely due to network latency or network bandwidth.<BR>
<BR>
Output Queue Length is the length of the output packet queue (in packets). If this is longer than two, there are delays and the bottleneck should be found and eliminated, if possible. Since the requests are queued by the Network Driver Interface Specification (NDIS) in this implementation, this will always be 0.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="High Context Switching" ENABLED="True" ANALYZECOUNTER="\System\Context Switches/sec" CATEGORY="Processor">
    <COUNTER NAME="\Processor(_Total)\% Processor Time" MINVARNAME="MinProcessor" AVGVARNAME="AvgProcessor" MAXVARNAME="MaxProcessor" TRENDVARNAME="TrendProcessor" DATATYPE="Integer" />
    <COUNTER NAME="\Processor(_Total)\% Privileged Time" MINVARNAME="MinPrivProcessor" AVGVARNAME="AvgPrivProcessor" MAXVARNAME="MaxPrivProcessor" TRENDVARNAME="TrendPrivProcessor" DATATYPE="Integer" />
    <COUNTER NAME="\System\Context Switches/sec" MINVARNAME="MinContextSwitchesPerSec" AVGVARNAME="AvgContextSwitchesPerSec" MAXVARNAME="MaxContextSwitchesPerSec" TRENDVARNAME="TrendContextSwitchesPerSec" DATATYPE="Integer" />
    <THRESHOLD NAME="High context switches/sec - more than 5000 context switches/sec per processor and more than 20% privilged mode CPU" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[If the privileged mode CPU is greater than <B>20%</B> of the total CPU and if total CPU exceeds <B>50%</B> and if the average context switches per sec is greater than <B>5000</B> per processor, then this threshold will break. This theshold indicates that the system is beginning to spend too much time in context switching. Consider reducing the number of processes and the number of threads.]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim PercentageOfPrivilegedModeCPUToTotalCPU
        ' Check to see if any of the values are zero to avoid divide by zero errors.
        If AvgPrivProcessor > 0 AND AvgProcessor > 0 AND AvgContextSwitchesPerSec > 0 AND NumberOfProcessors > 0 Then
          PercentageOfPrivilegedModeCPUToTotalCPU = (AvgPrivProcessor * 100) / AvgProcessor
          If PercentageOfPrivilegedModeCPU > 20 AND AvgProcessor > 50 AND (AvgContextSwitchesPerSec / NumberOfProcessors) > 5000 Then
            IsAvgThresholdBroken = True
          End If
        End If
      ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Very high context switches/sec - more than 15,000 context switches per second per processor and more than 20% of total CPU is in privileged mode" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[If the privileged mode CPU is greater than <B>20%</B> of the total CPU and if total CPU exceeds <B>50%</B> and if the average context switches per sec is greater than <B>15,000</B> per processor, then this threshold will break. This theshold indicates that the system is beginning to spend too much time in context switching. Consider reducing the number of processes and the number of threads.]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim PercentageOfPrivilegedModeCPUToTotalCPU
        If AvgPrivProcessor > 0 AND AvgProcessor > 0 AND AvgContextSwitchesPerSec > 0 AND NumberOfProcessors > 0 Then
          PercentageOfPrivilegedModeCPUToTotalCPU = (AvgPrivProcessor * 100) / AvgProcessor
          If PercentageOfPrivilegedModeCPUToTotalCPU > 20 AND AvgProcessor > 50 AND (AvgContextSwitchesPerSec / NumberOfProcessors) > 15000 Then
            IsAvgThresholdBroken = True
          End If
        End If
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\System\Context Switches/sec" DATASOURCE="\System\Context Switches/sec" DATATYPE="Integer" />
    <DESCRIPTION><![CDATA[High context switching is only a problem if privileged mode CPU and overall CPU is high as well. This analysis checks for high CPU, high privileged mode CPU, and high system context switches per sec.<BR>
<BR>
Threshold: As a general rule, context switching rates of less than 5,000 per second per processor are not worth worrying about. If context switching rates exceed 15,000 per second per processor, then there is a constraint.<BR>
<BR>
Significance: Context switching happens when a higher priority thread preempts a lower priority thread that is currently running or when a high priority thread blocks. High levels of context switching can occur when many threads share the same priority level. This often indicates that there are too many threads competing for the processors on the system. If you do not see much processor utilization and you see very low levels of context switching, it could indicate that threads are blocked.<BR>
<BR>
<B>Reference:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Leak Detection" ENABLED="True" ANALYZECOUNTER="\Process(*)\Private Bytes" CATEGORY="Memory">
    <COUNTER NAME="\Process(*)\Private Bytes" MINVARNAME="MinPrivateBytes" AVGVARNAME="AvgPrivateBytes" MAXVARNAME="MaxPrivateBytes" TRENDVARNAME="TrendPrivateBytes" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </COUNTER>
    <THRESHOLD NAME="Memory: an increasing trend of 5MB's per hour detected" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[If the private bytes size is greater than <B>256MB</B> and the process is increasing at a rate greater than <B>5MB's</B> per hour, then a memory leak is suspected.        ]]></DESCRIPTION>
      <CODE><![CDATA[' If the private bytes is over 256MBs and if the trend show a 5MB increase at each hour.        
If IsNull(AvgPrivateBytes) = False AND IsNull(TrendPrivateBytes) = False Then          
  If AvgPrivateBytes > 256000000 AND TrendPrivateBytes > 5000000 Then
    IsTrendThresholdBroken = True
  End If          
End If
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Memory: an increasing trend of 10MB's per hour detected" CONDITION="Warning" COLOR="Yellow" PRIORITY="51">
      <DESCRIPTION><![CDATA[If the private bytes size is greater than <B>256MB</B> and the process is increasing at a rate greater than <B>10MB's</B> per hour, then an aggressive memory leak is suspected.
        ]]></DESCRIPTION>
      <CODE><![CDATA[' If the private bytes is over 256MBs and if the trend show a 10MB increase at each hour.
If IsNull(AvgPrivateBytes) = False AND IsNull(TrendPrivateBytes) = False Then                  
  If AvgPrivateBytes > 256000000 AND TrendPrivateBytes > 10000000 Then
    IsTrendThresholdBroken = True
  End If  
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Process(*)\Private Bytes" DATASOURCE="\Process(*)\Private Bytes" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </CHART>
    <DESCRIPTION><![CDATA[This analysis determines if any of the processes are consuming a large size of the system's memory and if the process is increasing in memory consumption over time. A process consuming large portions of memory is okay as long as the process returns the memory back to the system. Look for increasing trends in the chart. An increasing trend over a long period of time could indicate a memory leak. Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes. This analysis checks for a 10MB’s per hour and 5MB’s per hour increasing trends. Use this analysis in correlation with the Available Memory analysis.<BR>
<BR>
Also, keep in mind that newly started processes will initially appear as a memory leak when it is simply normal start up behavior. A memory leak is when a process continues to consume memory and not releasing memory over a long period of time.<BR>
<BR>
Use this analysis in correlation with the Available Memory analysis. If you suspect a memory leak condition, then install and use the Debug Diag tool. For more information on the Debug Diag Tool, see the references section.<BR>
<BR>
<B>References:</B><BR>
<BR>
<BR>
Debug Diagnostic Tool v1.1 <a 
href="http://www.microsoft.com/downloads/details.aspx?FamilyID=28bd5941-c458-46f1-b24d-f60151d875a3&displaylang=
en">http://www.microsoft.com/downloads/details.aspx?FamilyID=28bd5941-c458-46f1-b24d-f60151d875a3&displaylang=en
</a><br>
<BR>
<B>Known Issues:</B><BR>
<BR>
- If Process(MonitoringHost.exe)\Private Bytes is generating a sawtooth looking pattern, then this is a known 
issue for SCOM 2007 as listed in <a href="http://support.microsoft.com/kb/950853">950853</a>. You will also see 
a corresponding 6026 event in the application log stating that this process has exceeded some threshold and is 
being restarted. <BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Handle Leak Detection" ENABLED="True" ANALYZECOUNTER="\Process(*)\Handle Count" CATEGORY="Memory">
    <COUNTER NAME="\Process(*)\Handle Count" MINVARNAME="MinHandleCount" AVGVARNAME="AvgHandleCount" MAXVARNAME="MaxHandleCount" TRENDVARNAME="TrendHandleCount" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </COUNTER>
    <THRESHOLD NAME="Handle Leak Suspected - more than 5000 handles and a trend of more than 50 handles per hour" CONDITION="Warning" COLOR="#CCFF66" PRIORITY="40">
      <DESCRIPTION><![CDATA[Checks for any process with a handle count greater than <B>5000</B> and if the trend is greater than <B>50</B> handles per hour. If so, check the chart to determine if the counter is on an increasing trend potentially indicating a handle leak.]]></DESCRIPTION>
      <CODE><![CDATA[If IsNull(AvgHandleCount) = False AND IsNull(TrendHandleCount) = False Then                  
  If AvgHandleCount > 5000 AND TrendHandleCount > 50 Then
    IsTrendThresholdBroken = True
  End If          
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Aggressive Handle Leak Suspected - more than 10,000 handles and a trend of more than 100 handles per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks for any process with a handle count greater than <B>10,000</B> and if the trend is greater than <B>100</B> handles per hour. If so, check the chart to determine if the counter is on an increasing trend potentially indicating a handle leak.]]></DESCRIPTION>
      <CODE><![CDATA[If IsNull(AvgHandleCount) = False AND IsNull(TrendHandleCount) = False Then                  
  If AvgHandleCount > 10000 AND TrendHandleCount > 100 Then
    IsTrendThresholdBroken = True
  End If          
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Process(*)\Handle Count" DATASOURCE="\Process(*)\Handle Count" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </CHART>
    <DESCRIPTION><![CDATA[This analysis checks all of the processes to determine how many handles each has open and determines if a handle leaks is suspected. A process with a large number of handles and/or an aggresive upward trend could indicate a handle leak which typically results in a memory leak. The total number of handles currently open by this process. This number is equal to the sum of the handles currently open by each thread in this process.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Thread Count" ENABLED="True" ANALYZECOUNTER="\Process(*)\Thread Count" CATEGORY="Memory">
    <COUNTER NAME="\Process(*)\Thread Count" MINVARNAME="MinThreadCount" AVGVARNAME="AvgThreadCount" MAXVARNAME="MaxThreadCount" TRENDVARNAME="TrendThreadCount" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </COUNTER>
    <THRESHOLD NAME="Thread Leak Suspected - thread count greater than 500 and an increasing trend of more than 50 threads per hour" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks for any process with a thread count greater than <B>500</B> and a trend greater than a <B>50</B> thread increase per hour. If so, check the chart to determine if the counter is on an increasing trend potentially indicating a thread leak.]]></DESCRIPTION>
      <CODE><![CDATA[If IsNull(AvgThreadCount) = False AND IsNull(TrendThreadCount) = False Then        
  If AvgThreadCount > 500 AND TrendThreadCount > 50 Then
    IsTrendThresholdBroken = True
  End If          
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Aggressive Thread Leak Suspected - thread count of more than 500 and an increasing trend of more than 100 threads per hour" CONDITION="Warning" COLOR="#FF8000" PRIORITY="75">
      <DESCRIPTION><![CDATA[Checks for any process with a thread count greater than <B>500</B> and a trend greater than a <B>100</B> thread increase per hour. If so, check the chart to determine if the counter is on an increasing trend potentially indicating a thread leak.]]></DESCRIPTION>
      <CODE><![CDATA[If IsNull(AvgThreadCount) = False AND IsNull(TrendThreadCount) = False Then        
  If AvgThreadCount > 500 AND TrendThreadCount > 100 Then
    IsTrendThresholdBroken = True
  End If          
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Process(*)\Thread Count" DATASOURCE="\Process(*)\Thread Count" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </CHART>
    <DESCRIPTION><![CDATA[The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.<BR>
<BR>
This analysis checks all of the processes to determine if a process has more than 500 threads and if it is on an increasing trend of 50 threads per hour. A process with a large number of threads and/or an aggressive upward trend could indicate a thread leak which typically results in either a memory leak or high context switching. High context switching will result in high privileged mode CPU. ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Excessive Processor Use by Processes" ENABLED="True" ANALYZECOUNTER="\Process(*)\% Processor Time" CATEGORY="Processor">
    <COUNTER NAME="\Process(*)\% Processor Time" MINVARNAME="MinPercentProcessorTime" AVGVARNAME="AvgPercentProcessorTime" MAXVARNAME="MaxPercentProcessorTime" TRENDVARNAME="TrendPercentProcessorTime" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </COUNTER>
    <THRESHOLD NAME="Significant Processor Use Suspected - more than 60% CPU utilization" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[Checks for any process using CPU greater than <B>60%</B>. If so, the process should be studied further to determine why it is consuming so much CPU.        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim AvgProcessorTimeDividedByNumberOfProcessors, MaxProcessorTimeDividedByNumberOfProcessors
If AvgPercentProcessorTime > 0 AND MaxPercentProcessorTime > 0 AND NumberOfProcessors > 0 Then
 AvgProcessorTimeDividedByNumberOfProcessors = AvgPercentProcessorTime / NumberOfProcessors
 MaxProcessorTimeDividedByNumberOfProcessors = MaxPercentProcessorTime / NumberOfProcessors
 If AvgProcessorTimeDividedByNumberOfProcessors > 60 Then
  IsAvgThresholdBroken = True
 End If
 If MaxProcessorTimeDividedByNumberOfProcessors > 60 Then
  IsMaxThresholdBroken = True
 End If
End If
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Excessive Processor Use Suspected - more than 80% CPU utilization" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[Checks for any process using CPU greater than <B>80%</B>. If so, the process should be studied further to determine why it is consuming so much CPU.
        ]]></DESCRIPTION>
      <CODE><![CDATA[Dim AvgProcessorTimeDividedByNumberOfProcessors, MaxProcessorTimeDividedByNumberOfProcessors
If AvgPercentProcessorTime > 0 AND MaxPercentProcessorTime > 0 AND NumberOfProcessors > 0 Then
 AvgProcessorTimeDividedByNumberOfProcessors = AvgPercentProcessorTime / NumberOfProcessors
 MaxProcessorTimeDividedByNumberOfProcessors = MaxPercentProcessorTime / NumberOfProcessors
 If AvgProcessorTimeDividedByNumberOfProcessors > 80 Then
  IsAvgThresholdBroken = True
 End If
 If MaxProcessorTimeDividedByNumberOfProcessors > 80 Then
  IsMaxThresholdBroken = True
 End If
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Process(*)\% Processor Time" DATASOURCE="\Process(*)\% Processor Time" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </CHART>
    <DESCRIPTION><![CDATA[This analysis checks all of the processes to determine if any of the processes are consuming a large amount of CPU.<BR>
<BR>
If a user-mode processor bottleneck is suspected, then consider using a process profiler to analyze the functions causing the high CPU consumption. See “How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment” article in the references section for more information.<BR>
<BR>
<b>Role Specific</b><br>
<br>
- Process(MSExchangeMailboxAssistants*)\%Processor Time should be less than 5% of overll CPU<br>
<br>
- Process(msftefd*)\%Processor Time should be less than 10% of what the store process is consuming. <b>Note:</b> If indexing is running and overall CPU is greater than 80%, then msfte should backoff it's CPU usage if that threshold is hit.<br>
<br>
<B>References:</B><BR>
Measuring .NET Application Performance<BR>
http://msdn2.microsoft.com/en-us/library/ms998579.aspx<BR>
<BR>
How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="High Virtual Memory Usage" ENABLED="True" ANALYZECOUNTER="\Process(*)\Virtual Bytes" CATEGORY="Memory">
    <COUNTER NAME="\Process(*)\Virtual Bytes" MINVARNAME="MinVirtualBytes" AVGVARNAME="AvgVirtualBytes" MAXVARNAME="MaxVirtualBytes" TRENDVARNAME="TrendVirtualBytes" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </COUNTER>
    <THRESHOLD NAME="High User-mode Memory Usage - consuming more than 80% of available virtual memory" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[This threshold checks to see if any processes are consuming a large amount of virtual memory. If the /3GB switch is used, then the user-mode process size limit changes from 2GB to 3GB and the threshold calculates if the process is within <B>80%</B> of that threshold. If 64-bit is used, then the threshold calculates the virtual memory at 8TB's.]]></DESCRIPTION>
      <CODE><![CDATA[Dim MaxUserModeMemory, PercentageOfMaxUserModeMemory
If SixtyFourBit = False Then
    If ThreeGBSwitch = True Then
      MaxUserModeMemory = 3000000000
    Else
      MaxUserModeMemory = 2000000000
    End If
Else
    ' 64-bit virtual memory
    MaxUserModeMemory = 8000000000000 ' 8TBs
End If

PercentageOfMaxUserModeMemory = MaxUserModeMemory * 0.80
If IsNull(AvgVirtualBytes) = False AND IsNull(AvgVirtualBytes) = False Then
  If AvgVirtualBytes > PercentageOfMaxUserModeMemory Then
    IsAvgThresholdBroken = True
  End If
End If        
If IsNull(MaxVirtualBytes) = False AND IsNull(MaxVirtualBytes) = False Then          
  If MaxVirtualBytes > PercentageOfMaxUserModeMemory Then
    IsMaxThresholdBroken = True
  End If
End If]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\Process(*)\Virtual Bytes" DATASOURCE="\Process(*)\Virtual Bytes" DATATYPE="Integer">
      <EXCLUDE INSTANCE="_Total" />
      <EXCLUDE INSTANCE="System" />
      <EXCLUDE INSTANCE="Idle" />
    </CHART>
    <DESCRIPTION><![CDATA[This analysis determines if any of the processes are consuming a large of virtual memory. 32-bit processes by default are only allowed to access up to 2GB's of user mode memory. If the process becomes close to this maximum, then it could starve for memory. If a process is becoming close to it's maximum, then consider moving the process to a 64-bit system. The /3GB switch could be used to give the user mode process a total of 3GB's of addressable memory, but this takes away 1GB of memory from the kernel which could have worse affects on the entire system such as with Pool Paged Memory and Pool Non-Paged Memory.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Disk Free Space for a Kernel Dump" ENABLED="True" ANALYZECOUNTER="\LogicalDisk(C:)\Free Megabytes" CATEGORY="Disk">
    <COUNTER NAME="\LogicalDisk(C:)\Free Megabytes" MINVARNAME="MinLogicalDiskFreeMBs" AVGVARNAME="AvgLogicalDiskFreeMBs" MAXVARNAME="MaxLogicalDiskFreeMBs" TRENDVARNAME="TrendLogicalDiskFreeMBs" DATATYPE="Integer">
    </COUNTER>
    <THRESHOLD NAME="Low on disk space on C: drive for a kernel dump (blue screen)" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[Based on the <B>amount of physical memory on the system plus 1 gigabyte</B>, there is not enough free disk space on the computer to purge all of the physical memory to disk in the event of an operating system failure (blue screen). It is very important to either free enough disk space on C: drive or to move the memory dump location. If you have moved the memory dump location to another location, then ignore this warning.        ]]></DESCRIPTION>
      <CODE><![CDATA[If KernelDumpOnCDrive = True Then
        Dim LogicalDiskFreeGBs
        LogicalDiskFreeGBs = MinLogicalDiskFreeMBs / 1024 + 1 ' Converting to gigabytes plus 1 gigabyte for padding.
        If LogicalDiskFreeGBs < TotalMemory Then
          IsMinThresholdBroken = True
        End If
End If        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Not enough disk space on C: drive for a kernel dump (blue screen)" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="60">
      <DESCRIPTION><![CDATA[Based on the <B>amount of physical memory</B> on the system, there is not enough free disk space on the computer to purge all of the physical memory to disk in the event of an operating system failure (blue screen). It is very important to either free enough disk space on C: drive or to move the memory dump location. If you have moved the memory dump location to another location, then ignore this warning.
        ]]></DESCRIPTION>
      <CODE><![CDATA[If KernelDumpOnCDrive = True Then
        Dim LogicalDiskFreeGBs
        LogicalDiskFreeGBs = MinLogicalDiskFreeMBs / 1024 ' Converting to gigabytes.
        If LogicalDiskFreeGBs < TotalMemory Then
          IsMinThresholdBroken = True
        End If
End If
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\LogicalDisk(C:)\Free Megabytes" DATASOURCE="\LogicalDisk(C:)\Free Megabytes" DATATYPE="Integer">
    </CHART>
    <DESCRIPTION><![CDATA[The default setting of kernel dumps (blue screens) is to purge all of the physical memory to the C: drive under the windows directory as a memory.dmp file. This analysis checks to make sure there is enough free disk space for the operating system to dump all memory to disk.      ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Interrupt Time" ENABLED="True" ANALYZECOUNTER="\Processor(*)\% Interrupt Time" CATEGORY="Processor">
    <COUNTER NAME="\Processor(*)\% Interrupt Time" MINVARNAME="MinProcessor_PercentInterruptTime" AVGVARNAME="AvgProcessor_PercentInterruptTime" MAXVARNAME="MaxProcessor_PercentInterruptTime" TRENDVARNAME="TrendProcessor_PercentInterruptTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor(*)\% Interrupt Time" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Processor(*)\% Interrupt Time" />
    <THRESHOLD NAME="High CPU Interrupt Time - more than 30% interrupt time" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[A high amount of % Interrupt Time in the processor could indicate a hardware or driver problem.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgProcessor_PercentInterruptTime > 30 Then
 IsAvgThreshold = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Very high CPU Interrupt Time - more than 50% interrupt time" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[A very high amount of % Interrupt Time in the processor could indicate a hardware or driver problem.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgProcessor_PercentInterruptTime > 50 Then
 IsAvgThreshold = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. A dramatic increase in this counter indicates potential hardware problems.<BR>
<BR>
This analysis checks for % Interrupt Time greater than 30%. If this occurs, then consider updating devices drivers for hardware that correlates to this alert.<BR>
<BR>
<B>References:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Working Set" ENABLED="True" ANALYZECOUNTER="\Process(*)\Working Set" CATEGORY="Memory">
    <COUNTER NAME="\Process(*)\Working Set" MINVARNAME="MinProcess_WorkingSet" AVGVARNAME="AvgProcess_WorkingSet" MAXVARNAME="MaxProcess_WorkingSet" TRENDVARNAME="TrendProcess_WorkingSet" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(*)\Working Set" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Process(*)\Working Set" ORDERBY="ASC" />
    <DESCRIPTION><![CDATA[Working Set is the current size, in bytes, of the Working Set of this process. The Working Set is the set of memory pages touched recently by the threads in the process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.<BR>
This analysis checks for an decreasing trend of 100MB’s or more in each of the processes. Use in correlation with Available Memory Analysis.<BR>
<BR>
<b>Known Issues</b><br>
<br>
- Outdated HP ILO driver causing kernel memory allocation problems. See <A HREF="http://technet.microsoft.com/en-us/library/aa998677.aspx">http://technet.microsoft.com/en-us/library/aa998677.aspx</a><br>
<br>
- Outdated Broadcom network card drivers with the Scalable Networking Pack chimney features enabled causing process working sets to get trimmed. Updating to the latest network card driver to VBD version 3.7x or later will help with this situation. See <A HREF="http://www.broadcom.com/support/ethernet_nic/netxtremeii.php">http://www.broadcom.com/support/ethernet_nic/netxtremeii.php</a> for more information on the update drivers. Certain OEM's have updated their drivers, so check with your server manufacturer before applying any update directly from the Broadcom site.<br>
<br>
<b>Hotfix:</b><br>
<br>
Applying <A HREF="http://support.microsoft.com/kb/938486">http://support.microsoft.com/kb/938486</a> will help reduce the amount that the working sets are trimmed preventing server performance issues due to excessive paging. <b>Note:</b> Any driver that calls the function MMAllocateContiguousMemory in large blocks may cause working sets to get trimmed. Exchange 2007 caches most data in memory and any trimming of any working sets will be detremental to overall performance.<br>
<br>
<B>References:</B><BR>
<BR>
Detecting Memory Bottlenecks <A HREF="http://www.microsoft.com/resources/documentation/windowsnt/4/workstation/reskit/en-us/04memory.mspx?mfr=true">http://www.microsoft.com/resources/documentation/windowsnt/4/workstation/reskit/en-us/04memory.mspx?mfr=true</a> ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory System Cache Resident Bytes" ENABLED="True" ANALYZECOUNTER="\Memory\System Cache Resident Bytes" CATEGORY="Memory">
    <COUNTER NAME="\Memory\System Cache Resident Bytes" MINVARNAME="MinMemory_SystemCacheResidentBytes" AVGVARNAME="AvgMemory_SystemCacheResidentBytes" MAXVARNAME="MaxMemory_SystemCacheResidentBytes" TRENDVARNAME="TrendMemory_SystemCacheResidentBytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\System Cache Resident Bytes" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\System Cache Resident Bytes" ORDERBY="ASC" />
    <THRESHOLD NAME="Increasing trend of more than 10MB's per hour detected" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If TrendMemory_SystemCacheResidentBytes > 10000000 Then
 IsTrendThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[System Cache Resident Bytes is the size, in bytes, of the pageable operating system code in the file system cache. This value includes only current physical pages and does not include any virtual memory pages not currently resident. It does equal the System Cache value shown in Task Manager. As a result, this value may be smaller than the actual amount of virtual memory in use by the file system cache. This value is a component of Memory\\System Code Resident Bytes which represents all pageable operating system code that is currently in physical memory. This counter displays the last observed value only; it is not an average.<BR>
<BR>
This analysis checks for an increasing trend of 10MB’s per hour. Under load, a server might use the System Cache in order to cache I/O activity such as disk. Use in correlation with Process IO Data Operations/sec and Process IO Other Operations/sec Analyses.<BR>
<BR>
<B>References:</B><BR>
File Cache Performance and Tuning http://technet.microsoft.com/en-us/library/bb742613.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process IO Data Operations/sec" ENABLED="True" ANALYZECOUNTER="\Process(*)\IO Data Operations/sec" CATEGORY="Disk">
    <COUNTER NAME="\Process(*)\IO Data Operations/sec" MINVARNAME="MinProcess_IODataOperationssec" AVGVARNAME="AvgProcess_IODataOperationssec" MAXVARNAME="MaxProcess_IODataOperationssec" TRENDVARNAME="TrendProcess_IODataOperationssec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </COUNTER>
    <CHART CHARTTITLE="\Process(*)\IO Data Operations/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Process(*)\IO Data Operations/sec" ORDERBY="ASC" />
    <THRESHOLD NAME="This process is using more than 1000 data I/O's per second" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgProcess_IODataOperationssec > 1000 Then
 IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[The rate at which the process is issuing read and write I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process IO Other Operations/sec" ENABLED="True" ANALYZECOUNTER="\Process(*)\IO Other Operations/sec" CATEGORY="Disk">
    <COUNTER NAME="\Process(*)\IO Other Operations/sec" MINVARNAME="MinProcess_IOOtherOperationssec" AVGVARNAME="AvgProcess_IOOtherOperationssec" MAXVARNAME="MaxProcess_IOOtherOperationssec" TRENDVARNAME="TrendProcess_IOOtherOperationssec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </COUNTER>
    <CHART CHARTTITLE="\Process(*)\IO Other Operations/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Process(*)\IO Other Operations/sec" ORDERBY="ASC" />
    <THRESHOLD NAME="This process is using more than 1000 other I/O's per second" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgProcess_IOOtherOperationssec > 1000 Then
 IsAvgThresholdBroken = True
End if]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[The rate at which the process is issuing I/O operations that are neither read nor write operations (for example, a control function). This counter counts all I/O activity generated by the process to include file, network and device I/Os.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Disk Transfers/sec" ENABLED="True" ANALYZECOUNTER="\LogicalDisk(*)\Disk Transfers/sec" CATEGORY="Disk">
    <COUNTER NAME="\LogicalDisk(*)\Disk Transfers/sec" MINVARNAME="MinLogicalDisk_DiskTransferssec" AVGVARNAME="AvgLogicalDisk_DiskTransferssec" MAXVARNAME="MaxLogicalDisk_DiskTransferssec" TRENDVARNAME="TrendLogicalDisk_DiskTransferssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Transfers/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\LogicalDisk(*)\Disk Transfers/sec" />
    <COUNTER NAME="\LogicalDisk(*)\Avg. Disk sec/Read" MINVARNAME="MinLogicalDiskAvgDisksecReadAll" AVGVARNAME="AvgLogicalDiskAvgDisksecReadAll" MAXVARNAME="MaxLogicalDiskAvgDisksecReadAll" TRENDVARNAME="TrendLogicalDiskAvgDisksecReadAll" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </COUNTER>
    <COUNTER NAME="\LogicalDisk(*)\Avg. Disk sec/Write" MINVARNAME="MinLogicalDiskAvgDisksecWriteAll" AVGVARNAME="AvgLogicalDiskAvgDisksecWriteAll" MAXVARNAME="MaxLogicalDiskAvgDisksecWriteAll" TRENDVARNAME="TrendLogicalDiskAvgDisksecWriteAll" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </COUNTER>
    <THRESHOLD NAME="Less than 80 I/O's per second on average when disk latency is longer than 25ms. This may indicate too many virtual LUNs using the same physical disks on a SAN. " CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgLogicalDiskAvgDisksecReadAll > 0.025 OR AvgLogicalDiskAvgDisksecWriteAll > 0.025 Then
 If AvgLogicalDisk_DiskTransferssec < 80 Then
  IsAvgThresholdBroken = True  
 End If
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 80 I/O's per second on average when disk latency is longer than 25ms. This may indicate too many virtual LUNs using the same physical disks on a SAN. This was a spike - not an average." CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If MaxLogicalDiskAvgDisksecReadAll > 0.025 OR MaxLogicalDiskAvgDisksecWriteAll > 0.025 Then
 If MaxLogicalDisk_DiskTransferssec < 80 Then
  IsMaxThresholdBroken = True  
 End If
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Disk Transfers/sec is the rate of read and write operations on the disk.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages Input/sec" ENABLED="True" ANALYZECOUNTER="\Memory\Pages Input/sec" CATEGORY="Memory">
    <COUNTER NAME="\Memory\Pages Input/sec" MINVARNAME="MinMemory_PagesInputsec" AVGVARNAME="AvgMemory_PagesInputsec" MAXVARNAME="MaxMemory_PagesInputsec" TRENDVARNAME="TrendMemory_PagesInputsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Pages Input/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\Pages Input/sec" ORDERBY="ASC" />
    <THRESHOLD NAME="More then 10 page file reads per second" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[More then 10 page file reads per second on average]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMemory_PagesInputsec > 10 Then
 IsAvgThresholdBroken = True
End If

If MaxMemory_PagesInputsec > 10 Then
 IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk. When a page is faulted, the system tries to read multiple contiguous pages into memory to maximize the benefit of the read operation. Compare the value of Memory\\Pages Input/sec to the value of  Memory\\Page Reads/sec to determine the average number of pages read into memory during each read operation.
<BR><BR>
<B>Reference:</B><BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Paging File % Usage" ENABLED="True" ANALYZECOUNTER="\Paging File(*)\% Usage" CATEGORY="Paging File">
    <COUNTER NAME="\Paging File(*)\% Usage" MINVARNAME="MinPagingFile_PercentUsage" AVGVARNAME="AvgPagingFile_PercentUsage" MAXVARNAME="MaxPagingFile_PercentUsage" TRENDVARNAME="TrendPagingFile_PercentUsage" DATATYPE="integer" />
    <CHART CHARTTITLE="\Paging File(*)\% Usage" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Paging File(*)\% Usage" ORDERBY="ASC" />
    <THRESHOLD NAME="More than 70% PageFile usage" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[More than 70% PageFile usage]]></DESCRIPTION>
      <CODE><![CDATA[If AvgPagingFile_PercentUsage > 70 Then
 IsAvgThresholdBroken = True
End If

If MaxPagingFile_PercentUsage > 70 Then
 IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[The amount of the Page File instance in use in percent.  See also Process\\Page File Bytes.<BR>
<BR>
This analysis checks if the percentage of usage is greater than 70%.<BR>
<BR>
<B>Reference:</B><BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Paging File % Usage Peak" ENABLED="True" ANALYZECOUNTER="\Paging File(*)\% Usage Peak" CATEGORY="Paging File">
    <COUNTER NAME="\Paging File(*)\% Usage Peak" MINVARNAME="MinPagingFile_PercentUsagePeak" AVGVARNAME="AvgPagingFile_PercentUsagePeak" MAXVARNAME="MaxPagingFile_PercentUsagePeak" TRENDVARNAME="TrendPagingFile_PercentUsagePeak" DATATYPE="integer" />
    <CHART CHARTTITLE="\Paging File(*)\% Usage Peak" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Paging File(*)\% Usage Peak" ORDERBY="ASC" />
    <THRESHOLD NAME="More than 70% PageFile Peak usage" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[More than 70% PageFile Peak usage]]></DESCRIPTION>
      <CODE><![CDATA[If AvgPagingFile_PercentUsagePeak > 70 Then
 IsAvgThresholdBroken = True
End If

If MaxPagingFile_PercentUsagePeak > 70 Then
 IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[The peak usage of the Page File instance in percent.  See also Process\\Page File Bytes Peak.<BR>
<BR>
<B>Reference:</B><BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <!--ASP.NET-->
  <ANALYSIS NAME=".NET CLR Exceptions / Second" ENABLED="True" ANALYZECOUNTER="\.NET CLR Exceptions(*)\# of Exceps Thrown / sec" CATEGORY=".NET Related">
    <DESCRIPTION><![CDATA[
      The total number of managed exceptions thrown per second. As this number increases, performance degrades. Exceptions should not be thrown as part of normal processing. Note, however, that Response.Redirect, Server.Transfer, and Response.End all cause a ThreadAbortException to be thrown multiple times, and a site that relies heavily upon these methods will incur a performance penalty. If you must use Response.Redirect, call Response.Redirect(url, false), which does not call Response.End, and hence does not throw. The downside is that the user code that follows the call to Response.Redirect(url, false) will execute. It is also possible to use a static HTML page to redirect. Microsoft Knowledge Base Article 312629 provides further detail. In addition to monitoring this very useful performance counter, the Application_Error event should be used in order to alert administrators to problems.
      <BR>
      Reference:<BR>
      <A HREF="http://msdn2.microsoft.com/en-us/library/ms972959.aspx">ASP.NET Performance</A>      
      ]]></DESCRIPTION>
    <COUNTER NAME="\.NET CLR Exceptions(*)\# of Exceps Thrown / sec" MINVARNAME="MinExcepsValue" AVGVARNAME="AvgExcepsValue" MAXVARNAME="MaxExcepsValue" TRENDVARNAME="TrendExcepsValue" DATATYPE="Integer">
    </COUNTER>
    <COUNTER NAME="\Web Service(_Total)\Connection Attempts/sec" MINVARNAME="MinRPSValue" AVGVARNAME="AvgRPSValue" MAXVARNAME="MaxRPSValue" TRENDVARNAME="TrendRPSValue" DATATYPE="Integer">
    </COUNTER>
    <THRESHOLD NAME=".NET Exceptions are occurring - more than 1 exception is occurring per second" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[      
        Checks for the occurance of any .NET exceptions.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        If AvgExcepsValue > 1 Then
          IsAvgThresholdBroken = True
        End If
        If MaxExcepsValue > 1 Then
          IsMaxThresholdBroken = True
        End If
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 5 percent of requests per second are .NET exceptions" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[      
        Checks to see if the number of .NET exception is greater than 5% of total requests per second.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        Dim PercentageOfRPS
        PercentageOfRPS = AvgRPSValue * 0.05
        If AvgExcepsValue > PercentageOfRPS Then
          IsAvgThresholdBroken = True
        End If
        If MaxExcepsValue > PercentageOfRPS Then
          IsMaxThresholdBroken = True
        End If
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\.NET CLR Exceptions(*)\# of Exceps Thrown / sec" DATASOURCE="\.NET CLR Exceptions(*)\# of Exceps Thrown / sec" DATATYPE="Integer" ORDERBY="ASC">
    </CHART>
    <DESCRIPTION><![CDATA[
      The total number of managed exceptions thrown per second. As this number increases, performance degrades. Exceptions should not be thrown as part of normal processing. Note, however, that Response.Redirect, Server.Transfer, and Response.End all cause a ThreadAbortException to be thrown multiple times, and a site that relies heavily upon these methods will incur a performance penalty. If you must use Response.Redirect, call Response.Redirect(url, false), which does not call Response.End, and hence does not throw. The downside is that the user code that follows the call to Response.Redirect(url, false) will execute. It is also possible to use a static HTML page to redirect. Microsoft Knowledge Base Article 312629 provides further detail. In addition to monitoring this very useful performance counter, the Application_Error event should be used in order to alert administrators to problems.
      <BR>
      Reference:<BR>
      <A HREF="http://msdn2.microsoft.com/en-us/library/ms972959.aspx">ASP.NET Performance</A>      
      ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Leak Detection in .NET " ENABLED="True" ANALYZECOUNTER="\.NET CLR Memory(*)\# Bytes in all Heaps" CATEGORY=".NET Related">
    <COUNTER NAME="\.NET CLR Memory(*)\# Bytes in all Heaps" MINVARNAME="MinDotNetHeapsValue" AVGVARNAME="AvgDotNetHeapsValue" MAXVARNAME="MaxDotNetHeapsValue" TRENDVARNAME="TrendDotNetHeapsValue" DATATYPE="Integer">
    </COUNTER>
    <THRESHOLD NAME="Increasing trend of 5MBs per hour in .NET memory consumption" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[      
        Checks for an increasing trend of 5MB's or more per hour.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        If TrendDotNetHeapsValue > 5000000 Then
          IsTrendThresholdBroken = True
        End If
        ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Increasing trend of 10MBs per hour in .NET memory consumption" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[      
        Checks for an increasing trend of 10MB's or more per hour.
        ]]></DESCRIPTION>
      <CODE><![CDATA[
        If TrendDotNetHeapsValue > 10000000 Then
          IsTrendThresholdBroken = True
        End If
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTYPE="Line" CATEGORIES="AUTO" MAXCATEGORYLABELS="0" LEGEND="ON" VALUES="AUTO" GROUPSIZE="640x480" OTSFORMAT="MM/dd hh:mm" CHARTTITLE="\.NET CLR Memory(*)\# Bytes in all Heaps" DATASOURCE="\.NET CLR Memory(*)\# Bytes in all Heaps" DATATYPE="Integer" ORDERBY="ASC">
    </CHART>
    <DESCRIPTION><![CDATA[
      The number of bytes committed by managed objects. This is the sum of the large object heap and the generation 0, 1, and 2 heaps. These regions of memory are of type MEM_COMMIT (see Platform SDK documentation for VirtualAlloc). The value of this counter will always be less than the value of Process\Private Bytes, which counts all MEM_COMMIT regions for the process. Private Bytes minus # Bytes in all Heaps is the number of bytes committed by unmanaged objects. The first step in the investigation of excessive memory usage is to determine whether it is being used by managed or unmanaged objects. To investigate excessive managed memory usage, I recommend WINDBG.EXE and SOS.DLL, which you can read about in Production Debugging for .NET Framework Applications. SOS.DLL has a "!dumpheap –stat" command that lists the count, size, and type of objects in the managed heap. You can use "!dumpheap –mt" to obtain the address of an object, and "!gcroot" to see its roots. The command "!eeheap" presents memory usage statistics for the managed heaps. 
      <P>
      Another useful tool for diagnosing memory usage is the CLR Profiler, discussed in more detail below. 
      <P>
      Excessive managed memory usage is commonly caused by: 
      <OL type="a">
        <LI>Reading large data sets into memory.</LI>
        <LI>Creating excessive cache entries.</LI>
        <LI>Uploading or downloading large files.</LI>
        <LI>Excessive use of regular expressions or strings while parsing files. </LI>
        <LI>Excessive ViewState.</LI>
        <LI>Too much data in session state or too many sessions.</LI>
      </OL>
      <BR><BR>
      Reference:<BR>
      <A HREF="http://msdn2.microsoft.com/en-us/library/ms972959.aspx">ASP.NET Performance</A>
      ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Page Reads/sec" ENABLED="True" ANALYZECOUNTER="\Memory\Page Reads/sec" CATEGORY="Memory">
    <COUNTER NAME="\Memory\Page Reads/sec" MINVARNAME="MinPageReadssec" AVGVARNAME="AvgPageReadssec" MAXVARNAME="MaxPageReadssec" TRENDVARNAME="TrendPageReadssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Page Reads/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\Page Reads/sec" />
    <THRESHOLD NAME="High Page Reads/Sec - greater than 100" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgPageReadssec >100 Then 
  IsAvgThresholdBroken = True
End If

If MaxPageReadssec >100 Then
  IsMaxThresholdBroken = True
End If

]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Very High Page Reads/Sec - greater than 1000" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgPageReadssec >1000 Then 
  IsAvgThresholdBroken = True
End If

If MaxPageReadssec >1000 Then
 IsMaxThresholdBroken = True
End If

]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Extremely High Page Reads/Sec - System wide working set trimming possible" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgPageReadssec >10000 Then 
  IsAvgThresholdBroken = True
End If

If MaxPageReadssec >10000 Then
 IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Page Reads/sec is the rate at which the disk was read to resolve hard page faults. It shows the number of reads operations, without regard to the number of pages retrieved in each operation. Hard page faults occur when a process references a page in virtual memory that is not in working set or elsewhere in physical memory, and must be retrieved from disk. This counter is a primary indicator of the kinds of faults that cause system-wide delays. It includes read operations to satisfy faults in the file system cache (usually requested by applications) and in non-cached mapped memory files. Compare the value of Memory\\Pages Reads/sec to the value of Memory\\Pages Input/sec to determine the average number of pages read during each operation.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME=".NET CLR Memory % Time in GC" ENABLED="True" ANALYZECOUNTER="\.NET CLR Memory(_Global_)\% Time in GC" CATEGORY=".NET Related">
    <COUNTER NAME="\.NET CLR Memory(_Global_)\% Time in GC" MINVARNAME="MinNETCLRMemory_PercentTimeinGC" AVGVARNAME="AvgNETCLRMemory_PercentTimeinGC" MAXVARNAME="MaxNETCLRMemory_PercentTimeinGC" TRENDVARNAME="TrendNETCLRMemory_PercentTimeinGC" DATATYPE="integer" />
    <CHART CHARTTITLE="\.NET CLR Memory(_Global_)\% Time in GC" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\.NET CLR Memory(_Global_)\% Time in GC" />
    <THRESHOLD NAME=".NET garbage collection high - greater than 5%" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This counter is updated when a garbage collection has occurred. Putting more memory in the server will help this situation.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgNETCLRMemory_PercentTimeinGC >5 Then
IsAvgThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME=".NET garbage collection very high - greater than 10%" CONDITION="Critical" COLOR="#FF0000" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgNETCLRMemory_PercentTimeinGC > 10 Then
IsAvgThresholdBroken = True
End If

]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME=".NET garbage collection critical - greater than 20%" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgNETCLRMemory_PercentTimeinGC > 20 Then
IsAvgThresholdBroken = True
End If

]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% Time in GC is the percentage of elapsed time that was spent in performing a garbage collection (GC) since the last GC cycle. This counter is usually an indicator of the work done by the Garbage Collector on behalf of the application to collect and compact memory. This counter is updated only at the end of every GC and the counter value reflects the last observed value; its not an average.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange ADAccess Domain Controllers LDAP Search Time" ENABLED="True" ANALYZECOUNTER="\MSExchange ADAccess Domain Controllers(*)\LDAP Search Time" CATEGORY="MSExchange ADAccess Domain Controllers">
    <COUNTER NAME="\MSExchange ADAccess Domain Controllers(*)\LDAP Search Time" MINVARNAME="MinMSExchangeADAccessDomainControllers_LDAPSearchTime" AVGVARNAME="AvgMSExchangeADAccessDomainControllers_LDAPSearchTime" MAXVARNAME="MaxMSExchangeADAccessDomainControllers_LDAPSearchTime" TRENDVARNAME="TrendMSExchangeADAccessDomainControllers_LDAPSearchTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange ADAccess Domain Controllers(*)\LDAP Search Time" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange ADAccess Domain Controllers(*)\LDAP Search Time" />
    <THRESHOLD NAME="Average LDAP Search times - greater than 50ms" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeADAccessDomainControllers_LDAPSearchTime >50 Then
IsAvgThresholdBroken = True
End If

]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Average LDAP Search times - greater than 100ms" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeADAccessDomainControllers_LDAPSearchTime >100 Then
IsAvgThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Average LDAP Search Times - greater than 500ms" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If MaxMSExchangeADAccessDomainControllers_LDAPSearchTime > 500 Then
IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[LDAP Search Time is the time (in ms) taken to send an LDAP search request and receive a response]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange ADAccess Caches LDAP Searches/Sec" ENABLED="True" ANALYZECOUNTER="\MSExchange ADAccess Caches(*)\LDAP Searches/Sec" CATEGORY="MSExchange ADAccess Caches">
    <DESCRIPTION><![CDATA[LDAP Searches/Sec is the number of LDAP search requests issued per second.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchange ADAccess Caches(*)\LDAP Searches/Sec" MINVARNAME="MinMSExchangeADAccessCaches_LDAPSearchesSec" AVGVARNAME="AvgMSExchangeADAccessCaches_LDAPSearchesSec" MAXVARNAME="MaxMSExchangeADAccessCaches_LDAPSearchesSec" TRENDVARNAME="TrendMSExchangeADAccessCaches_LDAPSearchesSec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange ADAccess Caches(*)\LDAP Searches/Sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange ADAccess Caches(*)\LDAP Searches/Sec" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange ADAccess Domain Controllers LDAP Read Time" ENABLED="True" ANALYZECOUNTER="\MSExchange ADAccess Domain Controllers(*)\LDAP Read Time" CATEGORY="MSExchange ADAccess Domain Controllers">
    <DESCRIPTION><![CDATA[LDAP Read Time for a given DC is the time (in ms) taken to send an LDAP read request to the specified DC and receive a response]]></DESCRIPTION>
    <COUNTER NAME="\MSExchange ADAccess Domain Controllers(*)\LDAP Read Time" MINVARNAME="MinMSExchangeADAccessDomainControllers_LDAPReadTime" AVGVARNAME="AvgMSExchangeADAccessDomainControllers_LDAPReadTime" MAXVARNAME="MaxMSExchangeADAccessDomainControllers_LDAPReadTime" TRENDVARNAME="TrendMSExchangeADAccessDomainControllers_LDAPReadTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange ADAccess Domain Controllers(*)\LDAP Read Time" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange ADAccess Domain Controllers(*)\LDAP Read Time" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange ADAccess Processes LDAP Read Time" ENABLED="True" ANALYZECOUNTER="\MSExchange ADAccess Processes(*)\LDAP Read Time" CATEGORY="MSExchange ADAccess Processes">
    <COUNTER NAME="\MSExchange ADAccess Processes(*)\LDAP Read Time" MINVARNAME="MinMSExchangeADAccessProcesses_LDAPReadTime" AVGVARNAME="AvgMSExchangeADAccessProcesses_LDAPReadTime" MAXVARNAME="MaxMSExchangeADAccessProcesses_LDAPReadTime" TRENDVARNAME="TrendMSExchangeADAccessProcesses_LDAPReadTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange ADAccess Processes(*)\LDAP Read Time" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange ADAccess Processes(*)\LDAP Read Time" />
    <DESCRIPTION><![CDATA[LDAP Read Time is the time (in ms) taken to send an LDAP read request and receive a response]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange ADAccess Processes LDAP Search Time" ENABLED="True" ANALYZECOUNTER="\MSExchange ADAccess Processes(*)\LDAP Search Time" CATEGORY="MSExchange ADAccess Processes">
    <COUNTER NAME="\MSExchange ADAccess Processes(*)\LDAP Search Time" MINVARNAME="MinMSExchangeADAccessProcesses_LDAPSearchTime" AVGVARNAME="AvgMSExchangeADAccessProcesses_LDAPSearchTime" MAXVARNAME="MaxMSExchangeADAccessProcesses_LDAPSearchTime" TRENDVARNAME="TrendMSExchangeADAccessProcesses_LDAPSearchTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange ADAccess Processes(*)\LDAP Search Time" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange ADAccess Processes(*)\LDAP Search Time" />
    <THRESHOLD NAME="Average LDAP Search times - greater than 50ms" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeADAccessProcesses_LDAPSearchTime >50 Then
IsAvgThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Average LDAP Search times - greater than 100ms" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeADAccessProcesses_LDAPSearchTime >100 Then
IsAvgThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Average LDAP Search times - greater than 500ms" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If MaxMSExchangeADAccessProcesses_LDAPSearchTime > 500 Then
IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[LDAP Search Time is the time (in ms) taken to send an LDAP search request and receive a response]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange ADAccess Domain Controllers LDAP Searches timed out per minute" ENABLED="True" ANALYZECOUNTER="\MSExchange ADAccess Domain Controllers(*)\LDAP Searches timed out per minute" CATEGORY="MSExchange ADAccess Domain Controllers">
    <COUNTER NAME="\MSExchange ADAccess Domain Controllers(*)\LDAP Searches timed out per minute" MINVARNAME="MinMSExchangeADAccessDomainControllers_LDAPSearchestimedoutperminute" AVGVARNAME="AvgMSExchangeADAccessDomainControllers_LDAPSearchestimedoutperminute" MAXVARNAME="MaxMSExchangeADAccessDomainControllers_LDAPSearchestimedoutperminute" TRENDVARNAME="TrendMSExchangeADAccessDomainControllers_LDAPSearchestimedoutperminute" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange ADAccess Domain Controllers(*)\LDAP Searches timed out per minute" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange ADAccess Domain Controllers(*)\LDAP Searches timed out per minute" />
    <THRESHOLD NAME="LDAP Searches timed out per minute - greater than 10" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeADAccessDomainControllers_LDAPSearchestimedoutperminute > 10 Then
IsAvgThresholdBroken = True
End If

If MaxMSExchangeADAccessDomainControllers_LDAPSearchestimedoutperminute >10 Then
IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="LDAP Searches timed out per minute - greater than 20" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeADAccessDomainControllers_LDAPSearchestimedoutperminute > 20 Then
IsAvgThresholdBroken = True
End If

If MaxMSExchangeADAccessDomainControllers_LDAPSearchestimedoutperminute >20 Then
IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[LDAP Searches timed out per minute is the number of LDAP searches returned LDAP_TIMEOUT during the last minute<br>
<br>
This counter is indicitive of an overloaded domain controller or there are network connectivity problems to the DC.<br>
<br>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange ADAccess Domain Controllers Long running LDAP operations/Min" ENABLED="True" ANALYZECOUNTER="\MSExchange ADAccess Domain Controllers(*)\Long running LDAP operations/Min" CATEGORY="MSExchange ADAccess Domain Controllers">
    <COUNTER NAME="\MSExchange ADAccess Domain Controllers(*)\Long running LDAP operations/Min" MINVARNAME="MinMSExchangeADAccessDomainControllers_LongrunningLDAPoperationsMin" AVGVARNAME="AvgMSExchangeADAccessDomainControllers_LongrunningLDAPoperationsMin" MAXVARNAME="MaxMSExchangeADAccessDomainControllers_LongrunningLDAPoperationsMin" TRENDVARNAME="TrendMSExchangeADAccessDomainControllers_LongrunningLDAPoperationsMin" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange ADAccess Domain Controllers(*)\Long running LDAP operations/Min" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange ADAccess Domain Controllers(*)\Long running LDAP operations/Min" />
    <THRESHOLD NAME="Long Running LDAP operations/min - greater than 50" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeADAccessDomainControllers_LongrunningLDAPoperationsMin > 50 Then
IsAvgThresholdBroken = True
End If

If AvgMSExchangeADAccessDomainControllers_LongrunningLDAPoperationsMin >50 Then
IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Long Running LDAP operations/min - greater than 100" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeADAccessDomainControllers_LongrunningLDAPoperationsMin > 100 Then
IsAvgThresholdBroken = True
End If

If AvgMSExchangeADAccessDomainControllers_LongrunningLDAPoperationsMin >100 Then
IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Long running LDAP operations/Min is the number of LDAP operations on this DC that took longer than the specified threshold per minute (default threshold is 15 seconds)<br>
<br>
This counter is useful for determining domain controller latencies that may affect overall Exchange performance.<br>
<br>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange ADAccess Domain Controllers LDAP Search calls/Sec" ENABLED="True" ANALYZECOUNTER="\MSExchange ADAccess Domain Controllers(*)\LDAP Search calls/Sec" CATEGORY="MSExchange ADAccess Domain Controllers">
    <COUNTER NAME="\MSExchange ADAccess Domain Controllers(*)\LDAP Search calls/Sec" MINVARNAME="MinMSExchangeADAccessDomainControllers_LDAPSearchcallsSec" AVGVARNAME="AvgMSExchangeADAccessDomainControllers_LDAPSearchcallsSec" MAXVARNAME="MaxMSExchangeADAccessDomainControllers_LDAPSearchcallsSec" TRENDVARNAME="TrendMSExchangeADAccessDomainControllers_LDAPSearchcallsSec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange ADAccess Domain Controllers(*)\LDAP Search calls/Sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange ADAccess Domain Controllers(*)\LDAP Search calls/Sec" />
    <DESCRIPTION><![CDATA[LDAP Search calls/Sec is the number of Depth 1 or 2 LDAP Search calls made by this process per second<br>
<br>
This counter is useful to determine if there is an increase in LDAP calls to the domain controllers possibly affecting overall latency on the server.<br>
<br>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Transition Faults/sec" ENABLED="True" ANALYZECOUNTER="\Memory\Transition Faults/sec" CATEGORY="Memory">
    <DESCRIPTION><![CDATA[Transition Faults/sec is the rate at which page faults are resolved by recovering pages that were being used by another process sharing the page, or were on the modified page list or the standby list, or were being written to disk at the time of the page fault. The pages were recovered without additional disk activity. Transition faults are counted in numbers of faults; because only one page is faulted in each operation, it is also equal to the number of pages faulted.]]></DESCRIPTION>
    <COUNTER NAME="\Memory\Transition Faults/sec" MINVARNAME="MinMemory_TransitionFaultssec" AVGVARNAME="AvgMemory_TransitionFaultssec" MAXVARNAME="MaxMemory_TransitionFaultssec" TRENDVARNAME="TrendMemory_TransitionFaultssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Transition Faults/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\Transition Faults/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="Memory Cache Bytes" ENABLED="True" ANALYZECOUNTER="\Memory\Cache Bytes" CATEGORY="Memory">
    <DESCRIPTION><![CDATA[Cache Bytes is the sum of the Memory\\System Cache Resident Bytes, Memory\\System Driver Resident Bytes, Memory\\System Code Resident Bytes, and Memory\\Pool Paged Resident Bytes counters.  This counter displays the last observed value only; it is not an average. ]]></DESCRIPTION>
    <COUNTER NAME="\Memory\Cache Bytes" MINVARNAME="MinMemory_CacheBytes" AVGVARNAME="AvgMemory_CacheBytes" MAXVARNAME="MaxMemory_CacheBytes" TRENDVARNAME="TrendMemory_CacheBytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Cache Bytes" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\Cache Bytes" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeMailSubmission Hub Servers In Retry" ENABLED="True" ANALYZECOUNTER="\MSExchangeMailSubmission(*)\Hub Servers In Retry" CATEGORY="MSExchangeMailSubmission">
    <DESCRIPTION><![CDATA[Hub Servers In Retry is the number of hub servers in retry.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeMailSubmission(*)\Hub Servers In Retry" MINVARNAME="MinMSExchangeMailSubmission_HubServersInRetry" AVGVARNAME="AvgMSExchangeMailSubmission_HubServersInRetry" MAXVARNAME="MaxMSExchangeMailSubmission_HubServersInRetry" TRENDVARNAME="TrendMSExchangeMailSubmission_HubServersInRetry" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeMailSubmission(*)\Hub Servers In Retry" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeMailSubmission(*)\Hub Servers In Retry" />
  </ANALYSIS>
  <ANALYSIS NAME="Process % Processor Time" ENABLED="True" ANALYZECOUNTER="\Process(*)\% Processor Time" CATEGORY="Process">
    <DESCRIPTION><![CDATA[% Processor Time is the percentage of elapsed time that all of process threads used the processor to execution instructions. An instruction is the basic unit of execution in a computer, a thread is the object that executes instructions, and a process is the object created when a program is run. Code executed to handle some hardware interrupts and trap conditions are included in this count.]]></DESCRIPTION>
    <COUNTER NAME="\Process(*)\% Processor Time" MINVARNAME="MinProcess_PercentProcessorTime" AVGVARNAME="AvgProcess_PercentProcessorTime" MAXVARNAME="MaxProcess_PercentProcessorTime" TRENDVARNAME="TrendProcess_PercentProcessorTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(*)\% Processor Time" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Process(*)\% Processor Time" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database Database Page Fault Stalls/sec" ENABLED="True" ANALYZECOUNTER="\MSExchange Database(*)\Database Page Fault Stalls/sec" CATEGORY="MSExchange Database">
    <COUNTER NAME="\MSExchange Database(*)\Database Page Fault Stalls/sec" MINVARNAME="MinMSExchangeDatabase_DatabasePageFaultStallssec" AVGVARNAME="AvgMSExchangeDatabase_DatabasePageFaultStallssec" MAXVARNAME="MaxMSExchangeDatabase_DatabasePageFaultStallssec" TRENDVARNAME="TrendMSExchangeDatabase_DatabasePageFaultStallssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database(*)\Database Page Fault Stalls/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database(*)\Database Page Fault Stalls/sec" />
    <THRESHOLD NAME="Disk Bottleneck Detected" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase_DatabasePageFaultStallssec > 1 Then
IsAvgThresholdBroken = True
End If

If MaxMSExchangeDatabase_DatabasePageFaultStallssec > 1 Then
IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Database Page Fault Stalls/sec is the rate of page faults that cannot be serviced because there are no pages available for allocation from the database cache.  If this counter is non-zero most of the time, the clean threshold may be too low.<br>

<p>If this value is non-zero, this indicates that the database is not able to flush dirty pages to the database file fast enough to make pages free for new page allocations.</p>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances I/O Database Reads Average Latency" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(*)\I/O Database Reads Average Latency" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(*)\I/O Database Reads Average Latency" MINVARNAME="MinMSExchangeDatabase_Instances_IODatabaseReadsAverageLatency" AVGVARNAME="AvgMSExchangeDatabase_Instances_IODatabaseReadsAverageLatency" MAXVARNAME="MaxMSExchangeDatabase_Instances_IODatabaseReadsAverageLatency" TRENDVARNAME="TrendMSExchangeDatabase_Instances_IODatabaseReadsAverageLatency" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(*)\I/O Database Reads Average Latency" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(*)\I/O Database Reads Average Latency" />
    <DESCRIPTION><![CDATA[I/O Database Reads Average Latency is the average length of time,  in milliseconds, per database read operation.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances I/O Database Writes Average Latency" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(*)\I/O Database Writes Average Latency" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(*)\I/O Database Writes Average Latency" MINVARNAME="MinMSExchangeDatabase_Instances_IODatabaseWritesAverageLatency" AVGVARNAME="AvgMSExchangeDatabase_Instances_IODatabaseWritesAverageLatency" MAXVARNAME="MaxMSExchangeDatabase_Instances_IODatabaseWritesAverageLatency" TRENDVARNAME="TrendMSExchangeDatabase_Instances_IODatabaseWritesAverageLatency" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(*)\I/O Database Writes Average Latency" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(*)\I/O Database Writes Average Latency" />
    <DESCRIPTION><![CDATA[I/O Database Writes Average Latency is the average length of time,  in milliseconds, per database write operation.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Server Pool Nonpaged Failures" ENABLED="True" ANALYZECOUNTER="\Server\Pool Nonpaged Failures" CATEGORY="Server">
    <DESCRIPTION><![CDATA[The number of times allocations from nonpaged pool have failed.  Indicates that the computer's physical memory is too small.]]></DESCRIPTION>
    <COUNTER NAME="\Server\Pool Nonpaged Failures" MINVARNAME="MinServer_PoolNonpagedFailures" AVGVARNAME="AvgServer_PoolNonpagedFailures" MAXVARNAME="MaxServer_PoolNonpagedFailures" TRENDVARNAME="TrendServer_PoolNonpagedFailures" DATATYPE="integer" />
    <CHART CHARTTITLE="\Server\Pool Nonpaged Failures" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Server\Pool Nonpaged Failures" />
  </ANALYSIS>
  <ANALYSIS NAME="Server Pool Paged Failures" ENABLED="True" ANALYZECOUNTER="\Server\Pool Paged Failures" CATEGORY="Server">
    <COUNTER NAME="\Server\Pool Paged Failures" MINVARNAME="MinServer_PoolPagedFailures" AVGVARNAME="AvgServer_PoolPagedFailures" MAXVARNAME="MaxServer_PoolPagedFailures" TRENDVARNAME="TrendServer_PoolPagedFailures" DATATYPE="integer" />
    <CHART CHARTTITLE="\Server\Pool Paged Failures" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Server\Pool Paged Failures" />
    <DESCRIPTION><![CDATA[The number of times allocations from paged pool have failed.  Indicates that the computer's physical memory or paging file are too small.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeMailSubmission Successful Submissions Per Second" ENABLED="True" ANALYZECOUNTER="\MSExchangeMailSubmission(*)\Successful Submissions Per Second" CATEGORY="MSExchangeMailSubmission">
    <DESCRIPTION><![CDATA[Successful Submissions Per Second]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeMailSubmission(*)\Successful Submissions Per Second" MINVARNAME="MinMSExchangeMailSubmission_SuccessfulSubmissionsPerSecond" AVGVARNAME="AvgMSExchangeMailSubmission_SuccessfulSubmissionsPerSecond" MAXVARNAME="MaxMSExchangeMailSubmission_SuccessfulSubmissionsPerSecond" TRENDVARNAME="TrendMSExchangeMailSubmission_SuccessfulSubmissionsPerSecond" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeMailSubmission(*)\Successful Submissions Per Second" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeMailSubmission(*)\Successful Submissions Per Second" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeMailSubmission Failed Submissions Per Second" ENABLED="True" ANALYZECOUNTER="\MSExchangeMailSubmission(*)\Failed Submissions Per Second" CATEGORY="MSExchangeMailSubmission">
    <COUNTER NAME="\MSExchangeMailSubmission(*)\Failed Submissions Per Second" MINVARNAME="MinMSExchangeMailSubmission_FailedSubmissionsPerSecond" AVGVARNAME="AvgMSExchangeMailSubmission_FailedSubmissionsPerSecond" MAXVARNAME="MaxMSExchangeMailSubmission_FailedSubmissionsPerSecond" TRENDVARNAME="TrendMSExchangeMailSubmission_FailedSubmissionsPerSecond" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeMailSubmission(*)\Failed Submissions Per Second" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeMailSubmission(*)\Failed Submissions Per Second" />
    <DESCRIPTION><![CDATA[Failed Submissions Per Second]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeMailSubmission Temporary Submission Failures/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeMailSubmission(*)\Temporary Submission Failures/sec" CATEGORY="MSExchangeMailSubmission">
    <COUNTER NAME="\MSExchangeMailSubmission(*)\Temporary Submission Failures/sec" MINVARNAME="MinMSExchangeMailSubmission_TemporarySubmissionFailuressec" AVGVARNAME="AvgMSExchangeMailSubmission_TemporarySubmissionFailuressec" MAXVARNAME="MaxMSExchangeMailSubmission_TemporarySubmissionFailuressec" TRENDVARNAME="TrendMSExchangeMailSubmission_TemporarySubmissionFailuressec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeMailSubmission(*)\Temporary Submission Failures/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeMailSubmission(*)\Temporary Submission Failures/sec" />
    <DESCRIPTION><![CDATA[Temporary Submission Failures per second is the number of temporary submission failures per second.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages Output/sec" ENABLED="True" ANALYZECOUNTER="\Memory\Pages Output/sec" CATEGORY="Memory">
    <DESCRIPTION><![CDATA[Pages Output/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code. A high rate of pages output might indicate a memory shortage. Windows writes more pages back to disk to free up space when physical memory is in short supply.  This counter shows the number of pages, and can be compared to other counts of pages, without conversion.]]></DESCRIPTION>
    <COUNTER NAME="\Memory\Pages Output/sec" MINVARNAME="MinMemory_PagesOutputsec" AVGVARNAME="AvgMemory_PagesOutputsec" MAXVARNAME="MaxMemory_PagesOutputsec" TRENDVARNAME="TrendMemory_PagesOutputsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Pages Output/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\Pages Output/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="Process IO Write Bytes/sec" ENABLED="True" ANALYZECOUNTER="\Process(EdgeTransport)\IO Write Bytes/sec" CATEGORY="Process">
    <DESCRIPTION><![CDATA[The rate at which the process is writing bytes to I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.]]></DESCRIPTION>
    <COUNTER NAME="\Process(EdgeTransport)\IO Write Bytes/sec" MINVARNAME="MinProcess_IOWriteBytessec" AVGVARNAME="AvgProcess_IOWriteBytessec" MAXVARNAME="MaxProcess_IOWriteBytessec" TRENDVARNAME="TrendProcess_IOWriteBytessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(EdgeTransport)\IO Write Bytes/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Process(EdgeTransport)\IO Write Bytes/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="Process IO Data Bytes/sec" ENABLED="True" ANALYZECOUNTER="\Process(EdgeTransport)\IO Data Bytes/sec" CATEGORY="Process">
    <DESCRIPTION><![CDATA[The rate at which the process is reading and writing bytes in I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.]]></DESCRIPTION>
    <COUNTER NAME="\Process(EdgeTransport)\IO Data Bytes/sec" MINVARNAME="MinProcess_IODataBytessec" AVGVARNAME="AvgProcess_IODataBytessec" MAXVARNAME="MaxProcess_IODataBytessec" TRENDVARNAME="TrendProcess_IODataBytessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(EdgeTransport)\IO Data Bytes/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Process(EdgeTransport)\IO Data Bytes/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="Process IO Read Bytes/sec" ENABLED="True" ANALYZECOUNTER="\Process(EdgeTransport)\IO Read Bytes/sec" CATEGORY="Process">
    <DESCRIPTION><![CDATA[The rate at which the process is reading bytes from I/O operations. This counter counts all I/O activity generated by the process to include file, network and device I/Os.]]></DESCRIPTION>
    <COUNTER NAME="\Process(EdgeTransport)\IO Read Bytes/sec" MINVARNAME="MinProcess_IOReadBytessec" AVGVARNAME="AvgProcess_IOReadBytessec" MAXVARNAME="MaxProcess_IOReadBytessec" TRENDVARNAME="TrendProcess_IOReadBytessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(EdgeTransport)\IO Read Bytes/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Process(EdgeTransport)\IO Read Bytes/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Messages Submitted Per Second" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Messages Submitted Per Second" CATEGORY="MSExchangeTransport Queues">
    <DESCRIPTION><![CDATA[Messages Submitted Per Second is the number of messages enqueued in the submission queue per second.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Messages Submitted Per Second" MINVARNAME="MinMSExchangeTransportQueues_MessagesSubmittedPerSecond" AVGVARNAME="AvgMSExchangeTransportQueues_MessagesSubmittedPerSecond" MAXVARNAME="MaxMSExchangeTransportQueues_MessagesSubmittedPerSecond" TRENDVARNAME="TrendMSExchangeTransportQueues_MessagesSubmittedPerSecond" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Messages Submitted Per Second" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Messages Submitted Per Second" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Messages Completed Delivery Per Second" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Messages Completed Delivery Per Second" CATEGORY="MSExchangeTransport Queues">
    <DESCRIPTION><![CDATA[Messages Completed Delivery Per Second is the number of messages delivery per second.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Messages Completed Delivery Per Second" MINVARNAME="MinMSExchangeTransportQueues_MessagesCompletedDeliveryPerSecond" AVGVARNAME="AvgMSExchangeTransportQueues_MessagesCompletedDeliveryPerSecond" MAXVARNAME="MaxMSExchangeTransportQueues_MessagesCompletedDeliveryPerSecond" TRENDVARNAME="TrendMSExchangeTransportQueues_MessagesCompletedDeliveryPerSecond" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Messages Completed Delivery Per Second" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Messages Completed Delivery Per Second" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Active Mailbox Delivery Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Active Mailbox Delivery Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Active Mailbox Delivery Queue Length" MINVARNAME="MinMSExchangeTransportQueues_ActiveMailboxDeliveryQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_ActiveMailboxDeliveryQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_ActiveMailboxDeliveryQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_ActiveMailboxDeliveryQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Active Mailbox Delivery Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Active Mailbox Delivery Queue Length" />
    <THRESHOLD NAME="Active Mailbox Delivery Queue Length greater than 250" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Active Mailbox Delivery Queue Length is greater than <B>250</B>. Messages in this queue are destined for a Mailbox server.

To resolve this problem, do one or more of the following:

Use the Exchange Mail Flow Troubleshooter to troubleshoot this issue. When running the tool, under <B>What Symptom are you seeing?</B>, click <B>Messages are backing up in one or more queues on a server</B>. The Mail flow Troubleshooter is located under the <B>Toolbox</B> node of Microsoft Exchange Management Console.

Review the System and Application event logs for related events.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_ActiveMailboxDeliveryQueueLength > 249 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_ActiveMailboxDeliveryQueueLength > 249 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Active Mailbox Delivery Queue Length greater than 200" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Active Mailbox Delivery Queue Length is greater than <B>200</B>. Messages in this queue are destined for a Mailbox server.
]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_ActiveMailboxDeliveryQueueLength > 199 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_ActiveMailboxDeliveryQueueLength > 199 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Active Mailbox Delivery Queue Length is the number of items in the active mailbox queues.<br>
<br>
Messages in this queue are destined for a Mailbox server.<br>
<br>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Active Non-Smtp Delivery Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Active Non-Smtp Delivery Queue Length" CATEGORY="MSExchangeTransport Queues">
    <DESCRIPTION><![CDATA[Active Non-Smtp Delivery Queue Length is the number of items in the active Non-Smtp queues.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Active Non-Smtp Delivery Queue Length" MINVARNAME="MinMSExchangeTransportQueues_ActiveNon-SmtpDeliveryQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_ActiveNon-SmtpDeliveryQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_ActiveNon-SmtpDeliveryQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_ActiveNon-SmtpDeliveryQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Active Non-Smtp Delivery Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Active Non-Smtp Delivery Queue Length" />
    <THRESHOLD NAME="Active Non-Smtp Delivery Queue Length greater than 250" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Active Non-Smtp Delivery Queue Length is greater than <B>250</B>. The Non-Smtp Delivery Queue is associated with the queue for <B>Foreign Connectors</B>. A Foreign Connector is added by using the new-ForeignConnector cmdlet or by a 3rd-party Exchange 2007 application.

To resolve this problem, do one or more of the following:

Use the Exchange Mail Flow Troubleshooter to troubleshoot this issue. When running the tool, under <B>What Symptom are you seeing?</B>, click <B>Messages are backing up in one or more queues on a server</B>. The Mail flow Troubleshooter is located under the <B>Toolbox</B> node of Microsoft Exchange Management Console.

Review the System and Application event logs for related events.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_ActiveNon-SmtpDeliveryQueueLength > 249 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_ActiveNon-SmtpDeliveryQueueLength > 249 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Active Non-Smtp Delivery Queue Length greater than 200." CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Active Non-Smtp Delivery Queue Length is greater than <B>200</B>. The Non-Smtp Delivery Queue is associated with the queue for <B>Foreign Connectors</B>. A Foreign Connector is added by using the new-ForeignConnector cmdlet or by a 3rd-party Exchange 2007 application.

To resolve this problem, do one or more of the following:

Use the Exchange Mail Flow Troubleshooter to troubleshoot this issue. When running the tool, under <B>What Symptom are you seeing?</B>, click <B>Messages are backing up in one or more queues on a server</B>. The Mail flow Troubleshooter is located under the <B>Toolbox</B> node of Microsoft Exchange Management Console.

Review the System and Application event logs for related events.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_ActiveNon-SmtpDeliveryQueueLength > 199 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_ActiveNon-SmtpDeliveryQueueLength > 199 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Active Remote Delivery Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Active Remote Delivery Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Active Remote Delivery Queue Length" MINVARNAME="MinMSExchangeTransportQueues_ActiveRemoteDeliveryQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_ActiveRemoteDeliveryQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_ActiveRemoteDeliveryQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_ActiveRemoteDeliveryQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Active Remote Delivery Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Active Remote Delivery Queue Length" />
    <THRESHOLD NAME="Active Remote Delivery Queue Length greater than 200" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Active Remote Delivery Queue Length is greater than 200.

]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_ActiveRemoteDeliveryQueueLength > 199 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_ActiveRemoteDeliveryQueueLength > 199 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Active Remote Delivery Queue Length greater than 350" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Active Remote Delivery Queue Length is greater than 350]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_ActiveRemoteDeliveryQueueLength > 349 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_ActiveRemoteDeliveryQueueLength > 349 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Active Remote Delivery Queue Length is the number of items in the active remote delivery queues.<br>
<br>
<p>To resolve this problem, do one or more of the following:</p>
<ul>
    <li>Use the Exchange Mail Flow Troubleshooter to troubleshoot this issue. When running the tool, under <strong>What Symptom are you seeing?</strong>, click <strong>Messages are backing up in one or more queues on a server</strong>. The Mail flow Troubleshooter is located under the <strong>Toolbox</strong> node of Microsoft Exchange Management Console.</li>
    <li>Review the System and Application event logs for related events.</li>
</ul>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Retry Mailbox Delivery Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Retry Mailbox Delivery Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Retry Mailbox Delivery Queue Length" MINVARNAME="MinMSExchangeTransportQueues_RetryMailboxDeliveryQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_RetryMailboxDeliveryQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_RetryMailboxDeliveryQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_RetryMailboxDeliveryQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Retry Mailbox Delivery Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Retry Mailbox Delivery Queue Length" />
    <THRESHOLD NAME="Retry Mailbox Delivery Queue Length greater than 100" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Retry Mailbox Delivery Queue Length is greater than 100. ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_RetryMailboxDeliveryQueueLength > 99 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_RetryMailboxDeliveryQueueLength > 99 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Retry Mailbox Delivery Queue Length greater than 250" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Retry Mailbox Delivery Queue Length is greater than 250. ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_RetryMailboxDeliveryQueueLength > 249 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_RetryMailboxDeliveryQueueLength > 249 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Retry Mailbox Delivery Queue Length is the number of items in retry in the retry mailbox queues.
<p>The Retry Mailbox Delivery Queue Length performance counter measures the number of messages currently in the retry mailbox delivery queue. Messages in this queue are in a retry state because an issue prevented their delivery. If the issue is transient, a subsequent attempt to send the message may be successful.</p>
<p>Messages that cannot be successfully delivered are subject to various retry, resubmit, and expiration deadlines based on the message's source and destination. Retry is a renewed connection attempt with the destination domain, smart host, or Mailbox server. Resubmit is the act of sending messages back to the Submission queue for the categorizer to reprocess. The message is said to &quot;time-out&quot;, or expire, after all delivery efforts have failed during a specified period of time. After a message expires, the sender is notified of the delivery failure. Then the message is deleted from the queue.</p>
<p>In all three cases of retry, resubmit, or expire, you can manually intervene before the automatic actions are performed on the messages.</p>
<p>This problem may be caused by any of the following:</p>
<ul>
    <li>A domain that you send a large amount of e-mail to is down or experiencing problems.</li>
    <li>A computer on your network may be infected with a virus which is sending messages through your Exchange servers.</li>
    <li>Your DNS server may have some issue resolving fully qualified domain names (FQDNs) to IP addresses.</li>
    <li>There may be a network connectivity issue that is preventing your server from properly connecting to destination servers or the Internet. Some possible issues that could effect your connection are:</li>
    <li>Router or routing issues between your server and the destination.</li>
    <li>Proxy or gateway server issues.</li>
    <li>Internet Service providers (ISP) issues such as a cut line, downed system, routing issues, global disturbance, or some other issue.</li>
</ul>
<p>Determine the root cause of the issue by doing one or more of the following:</p>
<ul>
    <li>Check the destination where the retry messages are being sent to. If the messages are all addressed to a single domain, or small number of domains, verify that the specified domains are valid and functional using the steps detailed in <a href="http://technet.microsoft.com/en-za/library/bb123686(en-us).aspx">http://technet.microsoft.com/en-za/library/bb123686(en-us).aspx</a>.</li>
    <li>Verify that there are no computers on your network that are infected with a virus which is sending messages through your Exchange server(s). Check where the retry messages are being sent to, if there a large number of messages addressed to companies that you do not know or do not regularly work with, or with unusual subject lines that look to be spam in nature. Take steps to remove the virus from the infected computer, or remove the computer from your network.</li>
    <li>Confirm that your DNS server can resolve the FQDNs of the affected domain's mail exchanger (MX) resource records to IP by using the NSLOOKUP command as described in <a href="http://technet.microsoft.com/en-us/library/cc740171.aspx">http://technet.microsoft.com/en-us/library/cc740171.aspx</a>.</li>
    <li>Confirm that there are no network connectivity issues preventing your server from properly connecting to destination servers or the Internet. After you have isolated and corrected the issue, manually submit again any messages that are located in the mailbox delivery queues. To do this, use either the Queue Viewer or the Retry-Queue cmdlet and specify the Resubmit parameter. For information about how to retry sending a message, see <a href="http://technet.microsoft.com/en-za/library/bb124568(en-us).aspx">http://technet.microsoft.com/en-za/library/bb124568(en-us).aspx</a>.</li>
</ul>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Retry Non-Smtp Delivery Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Retry Non-Smtp Delivery Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Retry Non-Smtp Delivery Queue Length" MINVARNAME="MinMSExchangeTransportQueues_RetryNon-SmtpDeliveryQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_RetryNon-SmtpDeliveryQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_RetryNon-SmtpDeliveryQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_RetryNon-SmtpDeliveryQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Retry Non-Smtp Delivery Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Retry Non-Smtp Delivery Queue Length" />
    <THRESHOLD NAME="Retry Non-Smtp Delivery Queue Length greater than 100" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Retry Non-Smtp Delivery Queue Length is greater than 100]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_RetryNon-SmtpDeliveryQueueLength > 99 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_RetryNon-SmtpDeliveryQueueLength > 99 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Retry Non-Smtp Delivery Queue Length greater than 250" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Retry Non-Smtp Delivery Queue Length is greater than 250.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_RetryNon-SmtpDeliveryQueueLength > 99 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_RetryNon-SmtpDeliveryQueueLength > 99 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Retry Non-Smtp Delivery Queue Length is the number of items in rety in the Non-Smtp queues.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Retry Remote Delivery Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Retry Remote Delivery Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Retry Remote Delivery Queue Length" MINVARNAME="MinMSExchangeTransportQueues_RetryRemoteDeliveryQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_RetryRemoteDeliveryQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_RetryRemoteDeliveryQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_RetryRemoteDeliveryQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Retry Remote Delivery Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Retry Remote Delivery Queue Length" />
    <THRESHOLD NAME="Retry Remote Delivery Queue Length greater than 250" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Retry Remote Delivery Queue Length is greater than 250]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_RetryRemoteDeliveryQueueLength > 249 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_RetryRemoteDeliveryQueueLength > 249 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Retry Remote Delivery Queue Length greater than 100" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Retry Remote Delivery Queue Length is greater than 100]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_RetryRemoteDeliveryQueueLength > 99 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_RetryRemoteDeliveryQueueLength > 99 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Retry Remote Delivery Queue Length is the number of items in retry in the remote delivery queues.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Submission Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Submission Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Submission Queue Length" MINVARNAME="MinMSExchangeTransportQueues_SubmissionQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_SubmissionQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_SubmissionQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_SubmissionQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Submission Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Submission Queue Length" />
    <THRESHOLD NAME="Submission Queue Length greater than 250" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Submission Queue Length is greater than 250]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_SubmissionQueueLength > 249 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_SubmissionQueueLength > 249 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Submission Queue Length greater than 100" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Submission Queue Length is greater than 100.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_SubmissionQueueLength > 99 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_SubmissionQueueLength > 99 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Submission Queue Length is the number of items in the submission queue.
<p>The Submission Queue Length performance counter measures the number of messages currently in the submission queue. Messages in this queue are in a retry state because an issue prevented their submission to the categorizer. The categorizer is responsible for doing things such as querying the Active Directory domain controllers in order to determine where the recipient of the message resides or determining the members of a distribution group. It is also responsible for running transport agents and rules and determining the optimal path a message should take. If the issue is transient, a subsequent attempt to submit the message may be successful.</p>
<p>A sustained high Submission Queue Length value may indicate that an excessive amount of inbound messages have over-loaded the categorizer. It may also indicate that there is an issue with message categorization. Message resubmission sends undelivered messages back to the submission queue to be processed again by the categorizer.</p>
<p>A sustained high Submission Queue Length may be caused by one or more of the following:</p>
<ul>
    <li>The server is being over-utilized and does not have enough resources to satisfy all of the current requests. This situation may occur if there are more messages being submitted for transport then the server can handle. Similarly, it may also occur if many messages are being resubmitted for categorization.</li>
    <li>There is a problem with a custom transport agent or rule, or a third-party transport agent or rule.</li>
    <li>Or there is an issue querying an Active Directory domain controller either due to permission or network related issues or the domain controller may be experiencing performance issues of its own.</li>
</ul>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Unreachable Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Unreachable Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Unreachable Queue Length" MINVARNAME="MinMSExchangeTransportQueues_UnreachableQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_UnreachableQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_UnreachableQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_UnreachableQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Unreachable Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Unreachable Queue Length" />
    <THRESHOLD NAME="Unreachable Queue Length greater than 100" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Unreachable Queue Length is greater than 100]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_UnreachableQueueLength > 99 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_UnreachableQueueLength > 99 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Unreachable Queue Length greater than 250" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Unreachable Queue Length is greater than 250. ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_UnreachableQueueLength > 249 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_UnreachableQueueLength > 249 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Unreachable Queue Length is the number of items in the unreachable queues.
<p>The categorizer sends messages to the unreachable queue when there is no known route to their destinations. Typically, an unreachable destination is caused by a configuration error that affects the delivery path. For example, the messages will be sent to the unreachable queue if the following conditions are true:</p>
<ul>
    <li>There are messages in the &quot;Contoso.com&quot; remote delivery queue.</li>
    <li>You delete the Send connector that is used to reach the Contoso.com domain.</li>
</ul>
<p>By default, the messages in the unreachable queue have the status of Ready. Messages remain in the unreachable queue until they are manually resubmitted by an administrator, removed by an administrator, an Active Directory Exchange topology configuration change is detected or the value specified in the MessageExpirationTimeOut parameter passes.</p>
<p>To resolve this problem, determine what messages are in the queue and then determine their destination. Using this information correct any configuration issues and ensure that a delivery path exists for these messages. Finally, resubmit the messages in the unreachable message queue. You can do this by using Exchange Queue Viewer or by running the Resume-Message cmdlet in the Exchange Management Shell.</p>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Dumpster Dumpster Size" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Dumpster\Dumpster Size" CATEGORY="MSExchangeTransport Dumpster">
    <DESCRIPTION><![CDATA[Item Size is the total size  (in bytes) of mail items that are currently in the Transport Dumpster on this server.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Dumpster\Dumpster Size" MINVARNAME="MinMSExchangeTransportDumpster_DumpsterSize" AVGVARNAME="AvgMSExchangeTransportDumpster_DumpsterSize" MAXVARNAME="MaxMSExchangeTransportDumpster_DumpsterSize" TRENDVARNAME="TrendMSExchangeTransportDumpster_DumpsterSize" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Dumpster\Dumpster Size" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Dumpster\Dumpster Size" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Dumpster Dumpster Inserts/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Dumpster\Dumpster Inserts/sec" CATEGORY="MSExchangeTransport Dumpster">
    <DESCRIPTION><![CDATA[Insert Rate is the rate at which items are inserted into the Transport Dumpster on this server.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Dumpster\Dumpster Inserts/sec" MINVARNAME="MinMSExchangeTransportDumpster_DumpsterInsertssec" AVGVARNAME="AvgMSExchangeTransportDumpster_DumpsterInsertssec" MAXVARNAME="MaxMSExchangeTransportDumpster_DumpsterInsertssec" TRENDVARNAME="TrendMSExchangeTransportDumpster_DumpsterInsertssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Dumpster\Dumpster Inserts/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Dumpster\Dumpster Inserts/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Dumpster Dumpster Item Count" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Dumpster\Dumpster Item Count" CATEGORY="MSExchangeTransport Dumpster">
    <DESCRIPTION><![CDATA[Item Count is the total number of mail  items that are currently in the Transport Dumpster on this server.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Dumpster\Dumpster Item Count" MINVARNAME="MinMSExchangeTransportDumpster_DumpsterItemCount" AVGVARNAME="AvgMSExchangeTransportDumpster_DumpsterItemCount" MAXVARNAME="MaxMSExchangeTransportDumpster_DumpsterItemCount" TRENDVARNAME="TrendMSExchangeTransportDumpster_DumpsterItemCount" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Dumpster\Dumpster Item Count" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Dumpster\Dumpster Item Count" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Dumpster Dumpster Deletes/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Dumpster\Dumpster Deletes/sec" CATEGORY="MSExchangeTransport Dumpster">
    <DESCRIPTION><![CDATA[Delete Rate is the rate at which items are deleted from the Transport Dumpster on this server.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Dumpster\Dumpster Deletes/sec" MINVARNAME="MinMSExchangeTransportDumpster_DumpsterDeletessec" AVGVARNAME="AvgMSExchangeTransportDumpster_DumpsterDeletessec" MAXVARNAME="MaxMSExchangeTransportDumpster_DumpsterDeletessec" TRENDVARNAME="TrendMSExchangeTransportDumpster_DumpsterDeletessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Dumpster\Dumpster Deletes/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Dumpster\Dumpster Deletes/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Database Stream writes/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Database(*)\Stream writes/sec" CATEGORY="MSExchangeTransport Database">
    <DESCRIPTION><![CDATA[This counter should only be used if Microsoft Product Support services advises that they need this information to troubleshoot a complex ESE-related performance issue.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Database(*)\Stream writes/sec" MINVARNAME="MinMSExchangeTransportDatabase_Streamwritessec" AVGVARNAME="AvgMSExchangeTransportDatabase_Streamwritessec" MAXVARNAME="MaxMSExchangeTransportDatabase_Streamwritessec" TRENDVARNAME="TrendMSExchangeTransportDatabase_Streamwritessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Database(*)\Stream writes/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Database(*)\Stream writes/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Database Stream read/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Database(*)\Stream read/sec" CATEGORY="MSExchangeTransport Database">
    <DESCRIPTION><![CDATA[This counter should only be used if Microsoft Product Support services advises that they need this information to troubleshoot a complex ESE-related performance issue.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Database(*)\Stream read/sec" MINVARNAME="MinMSExchangeTransportDatabase_Streamreadsec" AVGVARNAME="AvgMSExchangeTransportDatabase_Streamreadsec" MAXVARNAME="MaxMSExchangeTransportDatabase_Streamreadsec" TRENDVARNAME="TrendMSExchangeTransportDatabase_Streamreadsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Database(*)\Stream read/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Database(*)\Stream read/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Database MailItem begin commit/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Database(*)\MailItem begin commit/sec" CATEGORY="MSExchangeTransport Database">
    <DESCRIPTION><![CDATA[This counter should only be used if Microsoft Product Support services advises that they need this information to troubleshoot a complex ESE-related performance issue.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport Database(*)\MailItem begin commit/sec" MINVARNAME="MinMSExchangeTransportDatabase_MailItembegincommitsec" AVGVARNAME="AvgMSExchangeTransportDatabase_MailItembegincommitsec" MAXVARNAME="MaxMSExchangeTransportDatabase_MailItembegincommitsec" TRENDVARNAME="TrendMSExchangeTransportDatabase_MailItembegincommitsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Database(*)\MailItem begin commit/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Database(*)\MailItem begin commit/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Batch Point Transactions committed/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Batch Point(*)\Transactions committed/sec" CATEGORY="MSExchangeTransport Batch Point">
    <COUNTER NAME="\MSExchangeTransport Batch Point(*)\Transactions committed/sec" MINVARNAME="MinMSExchangeTransportBatchPoint_Transactionscommittedsec" AVGVARNAME="AvgMSExchangeTransportBatchPoint_Transactionscommittedsec" MAXVARNAME="MaxMSExchangeTransportBatchPoint_Transactionscommittedsec" TRENDVARNAME="TrendMSExchangeTransportBatchPoint_Transactionscommittedsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Batch Point(*)\Transactions committed/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Batch Point(*)\Transactions committed/sec" />
    <DESCRIPTION><![CDATA[This counter should only be used if Microsoft Product Support services advises that they need this information to troubleshoot a complex ESE-related performance issue.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Extensibility Agents Average Agent Processing Time (sec)" ENABLED="True" ANALYZECOUNTER="\MSExchange Extensibility Agents(*)\Average Agent Processing Time (sec)" CATEGORY="MSExchange Extensibility Agents">
    <COUNTER NAME="\MSExchange Extensibility Agents(*)\Average Agent Processing Time (sec)" MINVARNAME="MinMSExchangeExtensibilityAgents_AverageAgentProcessingTimesec" AVGVARNAME="AvgMSExchangeExtensibilityAgents_AverageAgentProcessingTimesec" MAXVARNAME="MaxMSExchangeExtensibilityAgents_AverageAgentProcessingTimesec" TRENDVARNAME="TrendMSExchangeExtensibilityAgents_AverageAgentProcessingTimesec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Extensibility Agents(*)\Average Agent Processing Time (sec)" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Extensibility Agents(*)\Average Agent Processing Time (sec)" />
    <THRESHOLD NAME="Extensibility agent taking longer than expected to process messages - greater than 20" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[Shows the average agent processing time in seconds per event.

]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeExtensibilityAgents_AverageAgentProcessingTimesec > 20 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeExtensibilityAgents_AverageAgentProcessingTimesec > 20 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Average agent processing time in seconds per event.<BR>
<BR>
Sustained higher latencies may indicate a hung agent.<BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Extensibility Agents Total Agent Invocations" ENABLED="True" ANALYZECOUNTER="\MSExchange Extensibility Agents(*)\Total Agent Invocations" CATEGORY="MSExchange Extensibility Agents">
    <COUNTER NAME="\MSExchange Extensibility Agents(*)\Total Agent Invocations" MINVARNAME="MinMSExchangeExtensibilityAgents_TotalAgentInvocations" AVGVARNAME="AvgMSExchangeExtensibilityAgents_TotalAgentInvocations" MAXVARNAME="MaxMSExchangeExtensibilityAgents_TotalAgentInvocations" TRENDVARNAME="TrendMSExchangeExtensibilityAgents_TotalAgentInvocations" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Extensibility Agents(*)\Total Agent Invocations" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Extensibility Agents(*)\Total Agent Invocations" />
    <DESCRIPTION><![CDATA[Total number of agent invocations since the last restart.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Store Driver Inbound: MessageDeliveryAttempts" ENABLED="True" ANALYZECOUNTER="\MSExchange Store Driver(_total)\Inbound: MessageDeliveryAttempts" CATEGORY="MSExchange Store Driver">
    <DESCRIPTION><![CDATA[Inbound: Message Delivery Attempts is the number of attempt for delivering transport mailitem.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchange Store Driver(_total)\Inbound: MessageDeliveryAttempts" MINVARNAME="MinMSExchangeStoreDriver_InboundMessageDeliveryAttempts" AVGVARNAME="AvgMSExchangeStoreDriver_InboundMessageDeliveryAttempts" MAXVARNAME="MaxMSExchangeStoreDriver_InboundMessageDeliveryAttempts" TRENDVARNAME="TrendMSExchangeStoreDriver_InboundMessageDeliveryAttempts" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Store Driver(_total)\Inbound: MessageDeliveryAttempts" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Store Driver(_total)\Inbound: MessageDeliveryAttempts" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Store Driver Inbound: MessageDeliveryAttemptsPerSecond" ENABLED="True" ANALYZECOUNTER="\MSExchange Store Driver(_total)\Inbound: MessageDeliveryAttemptsPerSecond" CATEGORY="MSExchange Store Driver">
    <DESCRIPTION><![CDATA[Inbound: Message Delivery Attempts Per Second is the number of attempts for delivering transport mailitem per second.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchange Store Driver(_total)\Inbound: MessageDeliveryAttemptsPerSecond" MINVARNAME="MinMSExchangeStoreDriver_InboundMessageDeliveryAttemptsPerSecond" AVGVARNAME="AvgMSExchangeStoreDriver_InboundMessageDeliveryAttemptsPerSecond" MAXVARNAME="MaxMSExchangeStoreDriver_InboundMessageDeliveryAttemptsPerSecond" TRENDVARNAME="TrendMSExchangeStoreDriver_InboundMessageDeliveryAttemptsPerSecond" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Store Driver(_total)\Inbound: MessageDeliveryAttemptsPerSecond" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Store Driver(_total)\Inbound: MessageDeliveryAttemptsPerSecond" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Aggregate Delivery Queue Length (All Queues)" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Aggregate Delivery Queue Length (All Queues)" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Aggregate Delivery Queue Length (All Queues)" MINVARNAME="MinMSExchangeTransportQueues_AggregateDeliveryQueueLengthAllQueues" AVGVARNAME="AvgMSExchangeTransportQueues_AggregateDeliveryQueueLengthAllQueues" MAXVARNAME="MaxMSExchangeTransportQueues_AggregateDeliveryQueueLengthAllQueues" TRENDVARNAME="TrendMSExchangeTransportQueues_AggregateDeliveryQueueLengthAllQueues" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Aggregate Delivery Queue Length (All Queues)" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Aggregate Delivery Queue Length (All Queues)" />
    <THRESHOLD NAME="Aggregate Delivery Queue Length for all queues greater than 3000" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Aggregate Delivery Queue Length for all queues is greater than 3000. ]]></DESCRIPTION>
      <CODE><![CDATA[If MaxMSExchangeTransportQueues_AggregateDeliveryQueueLengthAllQueues > 2999 Then
  IsMaxThresholdBroken = True
End If

If AvgMSExchangeTransportQueues_AggregateDeliveryQueueLengthAllQueues > 2999 Then
  IsAvgThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Aggregate Delivery Queue Length for all queues greater than 5000" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Aggregate Delivery Queue Length for all queues is greater than 5000. This alert indicates that the total number of messages in all queues is more than 5000.]]></DESCRIPTION>
      <CODE><![CDATA[If MaxMSExchangeTransportQueues_AggregateDeliveryQueueLengthAllQueues > 4999 Then
  IsMaxThresholdBroken = True
End If

If AvgMSExchangeTransportQueues_AggregateDeliveryQueueLengthAllQueues > 4999 Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Aggregate Delivery Queue Length (All Queues) is the number of items queued for delivery in all queues.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Largest Delivery Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Largest Delivery Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Largest Delivery Queue Length" MINVARNAME="MinMSExchangeTransportQueues_LargestDeliveryQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_LargestDeliveryQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_LargestDeliveryQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_LargestDeliveryQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Largest Delivery Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Largest Delivery Queue Length" />
    <THRESHOLD NAME="Largest Delivery Queue Length greater than 200" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Largest Delivery Queue Length is greater than 200. ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_LargestDeliveryQueueLength > 200 Then
  IsMaxThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_LargestDeliveryQueueLength > 200 Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Largest Delivery Queue Length is the number of messages in the largest delivery queue.
<p>The Largest Delivery Queue Length performance counter represents the number of e-mail messages that are queued to a given Exchange Hub Transport server or Edge Transport server.</p>
<p>When this value is high, the server cannot establish a SMTP session to the other Hub Transport or Edge Transport server. Other symptoms you may experience when this threshold is reached are reduced intra-site, inter-site, and external mail flow. This alert may be caused by one or more of the following conditions:</p>
<ul>
    <li>Problem with a specific Hub Transport server or Edge Transport server. For example, one or more required services may not be running.</li>
    <li>Issues with network connectivity, routers, or firewalls.</li>
</ul>
<p>To resolve this problem, do one or more of the following:</p>
<ul>
    <li>Run the Microsoft Exchange Mail Flow Troubleshooter. To access the Mail Flow Troubleshooter, click Toolbox in the Exchange Management Console.</li>
    <li>Use the Nslookup command-line tool to verify that external or remote domains have valid mail exchanger (MX) records.</li>
    <li>Use Telnet to verify that external or remote domain mail exchangers respond to telnet to port 25. For more information, see <a href="http://technet.microsoft.com/en-za/library/bb123686(en-us).aspx">http://technet.microsoft.com/en-za/library/bb123686(en-us).aspx</a>.</li>
</ul>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport Queues Poison Queue Length" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport Queues(_total)\Poison Queue Length" CATEGORY="MSExchangeTransport Queues">
    <COUNTER NAME="\MSExchangeTransport Queues(_total)\Poison Queue Length" MINVARNAME="MinMSExchangeTransportQueues_PoisonQueueLength" AVGVARNAME="AvgMSExchangeTransportQueues_PoisonQueueLength" MAXVARNAME="MaxMSExchangeTransportQueues_PoisonQueueLength" TRENDVARNAME="TrendMSExchangeTransportQueues_PoisonQueueLength" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport Queues(_total)\Poison Queue Length" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport Queues(_total)\Poison Queue Length" />
    <THRESHOLD NAME="Poison Queue Length greater than 0" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[This checks to see if the Poison Queue Length is greater than 0. ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_PoisonQueueLength > 0 Then
  IsMaxThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_PoisonQueueLength > 0 Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Poison Queue Length greater than 5" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[This checks to see if the Poison Queue Length is greater than 5. ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeTransportQueues_PoisonQueueLength > 5 Then
  IsMaxThresholdBroken = True
End If

If MaxMSExchangeTransportQueues_PoisonQueueLength > 5 Then
  IsAvgThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Poison Message Queue Length is the number of messages in the poison message queue.
<p>Messages in the poison message queue are in a permanently suspended state.</p>
<p>The poison message queue contains messages that are determined to be potentially harmful to the Microsoft Exchange Server 2007 server after causing a server failure. The messages may be genuinely harmful in their content and format. Alternatively, they may be the results of a poorly-written agent that has caused the Exchange server to fail when it processed the supposedly bad messages.</p>
<p>Messages remain in the poison message queue until they are manually resumed or removed by an administrator. The messages in the poison message queue are never automatically resumed or expired.</p>
<p>To resolve this problem, resubmit or remove the messages from the poison message queue.. You can resubmit the messages by using the Exchange Queue Viewer or by running the Resume-Message cmdlet. You can remove messages by using Queue Viewer or by running the Remove-Message cmdlet.</p>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Store Driver Inbound: LocalDeliveryCallsPerSecond" ENABLED="True" ANALYZECOUNTER="\MSExchange Store Driver(_total)\Inbound: LocalDeliveryCallsPerSecond" CATEGORY="MSExchange Store Driver">
    <DESCRIPTION><![CDATA[Inbound: Local Delivery Calls Per Second is the number of local delivery attempts per second.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchange Store Driver(_total)\Inbound: LocalDeliveryCallsPerSecond" MINVARNAME="MinMSExchangeStoreDriver_InboundLocalDeliveryCallsPerSecond" AVGVARNAME="AvgMSExchangeStoreDriver_InboundLocalDeliveryCallsPerSecond" MAXVARNAME="MaxMSExchangeStoreDriver_InboundLocalDeliveryCallsPerSecond" TRENDVARNAME="TrendMSExchangeStoreDriver_InboundLocalDeliveryCallsPerSecond" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Store Driver(_total)\Inbound: LocalDeliveryCallsPerSecond" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Store Driver(_total)\Inbound: LocalDeliveryCallsPerSecond" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Store Driver Outbound: Submitted Mail Items Per Second" ENABLED="True" ANALYZECOUNTER="\MSExchange Store Driver(_total)\Outbound: Submitted Mail Items Per Second" CATEGORY="MSExchange Store Driver">
    <COUNTER NAME="\MSExchange Store Driver(_total)\Outbound: Submitted Mail Items Per Second" MINVARNAME="MinMSExchangeStoreDriver_OutboundSubmittedMailItemsPerSecond" AVGVARNAME="AvgMSExchangeStoreDriver_OutboundSubmittedMailItemsPerSecond" MAXVARNAME="MaxMSExchangeStoreDriver_OutboundSubmittedMailItemsPerSecond" TRENDVARNAME="TrendMSExchangeStoreDriver_OutboundSubmittedMailItemsPerSecond" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Store Driver(_total)\Outbound: Submitted Mail Items Per Second" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Store Driver(_total)\Outbound: Submitted Mail Items Per Second" />
    <DESCRIPTION><![CDATA[Outbound: Submitted Mail Items Per Second is the number of mail items per second being submitted.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport SmtpReceive Average bytes/message" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport SmtpReceive(_total)\Average bytes/message" CATEGORY="MSExchangeTransport SmtpReceive">
    <DESCRIPTION><![CDATA[Average Bytes/Message is the average number of message bytes per inbound message received.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport SmtpReceive(_total)\Average bytes/message" MINVARNAME="MinMSExchangeTransportSmtpReceive_Averagebytesmessage" AVGVARNAME="AvgMSExchangeTransportSmtpReceive_Averagebytesmessage" MAXVARNAME="MaxMSExchangeTransportSmtpReceive_Averagebytesmessage" TRENDVARNAME="TrendMSExchangeTransportSmtpReceive_Averagebytesmessage" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport SmtpReceive(_total)\Average bytes/message" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport SmtpReceive(_total)\Average bytes/message" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport SmtpReceive Messages Received/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport SmtpReceive(_total)\Messages Received/sec" CATEGORY="MSExchangeTransport SmtpReceive">
    <COUNTER NAME="\MSExchangeTransport SmtpReceive(_total)\Messages Received/sec" MINVARNAME="MinMSExchangeTransportSmtpReceive_MessagesReceivedsec" AVGVARNAME="AvgMSExchangeTransportSmtpReceive_MessagesReceivedsec" MAXVARNAME="MaxMSExchangeTransportSmtpReceive_MessagesReceivedsec" TRENDVARNAME="TrendMSExchangeTransportSmtpReceive_MessagesReceivedsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport SmtpReceive(_total)\Messages Received/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport SmtpReceive(_total)\Messages Received/sec" />
    <DESCRIPTION><![CDATA[Messages Received/sec is the number of messages received by the SMTP server each second.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchangeTransport SmtpSend Messages Sent/sec" ENABLED="True" ANALYZECOUNTER="\MSExchangeTransport SmtpSend(_total)\Messages Sent/sec" CATEGORY="MSExchangeTransport SmtpSend">
    <DESCRIPTION><![CDATA[Messages Sent/sec is the number of messages sent by the SMTP Send connector each second.]]></DESCRIPTION>
    <COUNTER NAME="\MSExchangeTransport SmtpSend(_total)\Messages Sent/sec" MINVARNAME="MinMSExchangeTransportSmtpSend_MessagesSentsec" AVGVARNAME="AvgMSExchangeTransportSmtpSend_MessagesSentsec" MAXVARNAME="MaxMSExchangeTransportSmtpSend_MessagesSentsec" TRENDVARNAME="TrendMSExchangeTransportSmtpSend_MessagesSentsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchangeTransport SmtpSend(_total)\Messages Sent/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchangeTransport SmtpSend(_total)\Messages Sent/sec" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Store Driver Inbound: Recipients Delivered Per Second" ENABLED="True" ANALYZECOUNTER="\MSExchange Store Driver(_total)\Inbound: Recipients Delivered Per Second" CATEGORY="MSExchange Store Driver">
    <DESCRIPTION><![CDATA[Recipients delivered per second]]></DESCRIPTION>
    <COUNTER NAME="\MSExchange Store Driver(_total)\Inbound: Recipients Delivered Per Second" MINVARNAME="MinMSExchangeStoreDriver_InboundRecipientsDeliveredPerSecond" AVGVARNAME="AvgMSExchangeStoreDriver_InboundRecipientsDeliveredPerSecond" MAXVARNAME="MaxMSExchangeStoreDriver_InboundRecipientsDeliveredPerSecond" TRENDVARNAME="TrendMSExchangeStoreDriver_InboundRecipientsDeliveredPerSecond" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Store Driver(_total)\Inbound: Recipients Delivered Per Second" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Store Driver(_total)\Inbound: Recipients Delivered Per Second" />
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances I/O Log Writes/sec" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Log Writes/sec" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Log Writes/sec" MINVARNAME="MinMSExchangeDatabase_Instances_IOLogWritessec" AVGVARNAME="AvgMSExchangeDatabase_Instances_IOLogWritessec" MAXVARNAME="MaxMSExchangeDatabase_Instances_IOLogWritessec" TRENDVARNAME="TrendMSExchangeDatabase_Instances_IOLogWritessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Log Writes/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Log Writes/sec" />
    <DESCRIPTION><![CDATA[I/O Log Writes/sec is the rate of logfile write operations completed.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances I/O Log Reads/sec" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Log Reads/sec" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Log Reads/sec" MINVARNAME="MinMSExchangeDatabase_Instances_IOLogReadssec" AVGVARNAME="AvgMSExchangeDatabase_Instances_IOLogReadssec" MAXVARNAME="MaxMSExchangeDatabase_Instances_IOLogReadssec" TRENDVARNAME="TrendMSExchangeDatabase_Instances_IOLogReadssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Log Reads/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Log Reads/sec" />
    <DESCRIPTION><![CDATA[I/O Log Reads/sec is the rate of logfile read operations completed.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances Version buckets allocated" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Version buckets allocated" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Version buckets allocated" MINVARNAME="MinMSExchangeDatabase_Instances_Versionbucketsallocated" AVGVARNAME="AvgMSExchangeDatabase_Instances_Versionbucketsallocated" MAXVARNAME="MaxMSExchangeDatabase_Instances_Versionbucketsallocated" TRENDVARNAME="TrendMSExchangeDatabase_Instances_Versionbucketsallocated" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Version buckets allocated" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Version buckets allocated" />
    <THRESHOLD NAME="Transport database Version Buckets Allocated greater than 120" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[The Version buckets allocated performance counter indicates the number of buckets of version store memory that are currently being used. ]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase_Instances_Versionbucketsallocated > 119 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeDatabase_Instances_Versionbucketsallocated > 119 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Transport database Version Buckets Allocated greater than 200" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[The Version buckets allocated performance counter indicates the number of buckets of version store memory that are currently being used.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase_Instances_Versionbucketsallocated > 199 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeDatabase_Instances_Versionbucketsallocated > 199 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Total number of version buckets allocated
<p>The Version buckets allocated performance counter indicates the number of buckets of version store memory that are currently being used. A version bucket is a 16 kilobyte (KB) chunk of the version store. The version store is an allocation of memory where database transactions are held until they can be written to disk. A list of changes that are made to the message queue database is kept in memory until those changes can be committed to a transaction log. Then the list is committed to the message queue database itself. These outstanding message queue database transactions that are kept in memory are known as version buckets.</p>
<p>This alert indicates that you have more than <strong>120 </strong>version buckets allocated. This alert usually indicates that you have a database transaction that is taking a long time to be saved to disk.</p>
<p>The number of version buckets may increase to unacceptably high levels because of virus issues, problems with the message queue database integrity, or hard disk drive performance.</p>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances I/O Database Reads/sec" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Database Reads/sec" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Database Reads/sec" MINVARNAME="MinMSExchangeDatabase_Instances_IODatabaseReadssec" AVGVARNAME="AvgMSExchangeDatabase_Instances_IODatabaseReadssec" MAXVARNAME="MaxMSExchangeDatabase_Instances_IODatabaseReadssec" TRENDVARNAME="TrendMSExchangeDatabase_Instances_IODatabaseReadssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Database Reads/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Database Reads/sec" />
    <DESCRIPTION><![CDATA[I/O Database Reads/sec is the rate of database read operations completed.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances I/O Database Writes/sec" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Database Writes/sec" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Database Writes/sec" MINVARNAME="MinMSExchangeDatabase_Instances_IODatabaseWritessec" AVGVARNAME="AvgMSExchangeDatabase_Instances_IODatabaseWritessec" MAXVARNAME="MaxMSExchangeDatabase_Instances_IODatabaseWritessec" TRENDVARNAME="TrendMSExchangeDatabase_Instances_IODatabaseWritessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Database Writes/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\I/O Database Writes/sec" />
    <DESCRIPTION><![CDATA[I/O Database Writes/sec is the rate of database write operations completed.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances Log Record Stalls/sec - Transport" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Record Stalls/sec" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Record Stalls/sec" MINVARNAME="MinMSExchangeDatabase_Instances_LogRecordStallssec" AVGVARNAME="AvgMSExchangeDatabase_Instances_LogRecordStallssec" MAXVARNAME="MaxMSExchangeDatabase_Instances_LogRecordStallssec" TRENDVARNAME="TrendMSExchangeDatabase_Instances_LogRecordStallssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Record Stalls/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Record Stalls/sec" />
    <THRESHOLD NAME="Transport database log records not being processed in a timely fashion - greater than 10" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[Shows the number of log records for the Edge/Hub Transport database that cannot be added to the log buffers per second because they are full. If this counter is non-zero most of the time, the log buffer size may be a bottleneck.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase_Instances_LogRecordStallssec > 10 Then
   IsAvgThresholdBroken = True
End If        

If MaxMSExchangeDatabase_Instances_LogRecordStallssec > 10 Then
   IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Transport database high log record stalls due to server performance issues - greater than 100" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[Shows the number of log records for the Edge/Hub Transport database that cannot be added to the log buffers per second because they are full. If this counter is non-zero most of the time, the log buffer size may be a bottleneck.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase_Instances_LogRecordStallssec > 100 Then
   IsAvgThresholdBroken = True
End If        

If MaxMSExchangeDatabase_Instances_LogRecordStallssec >100 Then
   IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Shows the number of log records for the Edge/Hub Transport database that cannot be added to the log buffers per second because they are full. If this counter is non-zero most of the time, the log buffer size may be a bottleneck.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances Log Threads Waiting" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Threads Waiting" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Threads Waiting" MINVARNAME="MinMSExchangeDatabase_Instances_LogThreadsWaiting" AVGVARNAME="AvgMSExchangeDatabase_Instances_LogThreadsWaiting" MAXVARNAME="MaxMSExchangeDatabase_Instances_LogThreadsWaiting" TRENDVARNAME="TrendMSExchangeDatabase_Instances_LogThreadsWaiting" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Threads Waiting" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Threads Waiting" />
    <THRESHOLD NAME="Transport database log threads not being processed in a timely manner - greater than 10" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[Shows the number of threads waiting for their data to be written to the log to complete an update of the database. If this number is too high, the log may be a bottleneck.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase_Instances_LogThreadsWaiting > 10 Then
    IsAvgThresholdBroken = True
End If        

If AvgMSExchangeDatabase_Instances_LogThreadsWaiting > 10 Then
  IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Log Threads Waiting is the number of threads waiting for their data to be written to the log in order to complete an update of the database.  If this number is too high, the log may be a bottleneck.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances Log Generation Checkpoint Depth - Transport" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Generation Checkpoint Depth" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Generation Checkpoint Depth" MINVARNAME="MinMSExchangeDatabase_Instances_LogGenerationCheckpointDepth" AVGVARNAME="AvgMSExchangeDatabase_Instances_LogGenerationCheckpointDepth" MAXVARNAME="MaxMSExchangeDatabase_Instances_LogGenerationCheckpointDepth" TRENDVARNAME="TrendMSExchangeDatabase_Instances_LogGenerationCheckpointDepth" DATATYPE="integer" />
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Generation Checkpoint Depth" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(edgetransport/Transport Mail Database)\Log Generation Checkpoint Depth" />
    <THRESHOLD NAME="Transport Database Log Generation Checkpoint Depth greater than 500" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[The Log Generation Checkpoint Depth performance counter represents the work, in a count of log files, that will need to be redone or undone to the database files if the process crashes.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase_Instances_LogGenerationCheckpointDepth > 500 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeDatabase_Instances_LogGenerationCheckpointDepth > 500 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Transport Database Log Generation Checkpoint Depth greater than 1000" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[The Log Generation Checkpoint Depth performance counter represents the work, in a count of log files, that will need to be redone or undone to the database files if the process crashes.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase_Instances_LogGenerationCheckpointDepth > 1000 Then
   IsAvgThresholdBroken = True
End If

If MaxMSExchangeDatabase_Instances_LogGenerationCheckpointDepth > 1000 Then
   IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Log Generation Checkpoint Depth represents the amount of work, in count of log files, that will need to be redone or undone to the database file(s) if the process crashes.
<p>When this alert is triggered, messages are being received faster than they can be written to the transport queue database. Other symptoms that may occur when this threshold is reached are reduced intra-site, inter-site, and external mail flow. This problem may be caused by one or more of the following conditions:</p>
<ul>
    <li>Message volume is exceeding server capacity.</li>
    <li>Applications other than Microsoft Exchange Server are accessing or placing file locks on the transaction log files.</li>
    <li>Hard disks are not performing at a level to meet the disk I/O requirements of your Exchange environment.</li>
</ul>
<p>To resolve this problem, do one or more of the following:</p>
<ul>
    <li>Run the Microsoft Exchange Mail Flow Troubleshooter. To access the Mail Flow Troubleshooter, click <strong>Toolbox</strong> in the Exchange Management Console.</li>
    <li>If you believe that an application is accessing or placing locks on the transaction log files, stop running the suspected application to determine if that is the cause of the problem. In addition, consider configuring the application so that it does not access the Microsoft Exchange folder and all subfolders.</li>
    <li>Evaluate disk I/O performance. For information about how to monitor disk performance with Performance Monitor, see Microsoft Knowledge Base article <a href="http://support.microsoft.com/kb/102020">http://support.microsoft.com/kb/102020</a>.</li>
</ul>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Transition Pages RePurposed/sec" ENABLED="True" ANALYZECOUNTER="\Memory\Transition Pages RePurposed/sec" CATEGORY="Memory">
    <COUNTER NAME="\Memory\Transition Pages RePurposed/sec" MINVARNAME="MinMemory_TransitionPagesRePurposedsec" AVGVARNAME="AvgMemory_TransitionPagesRePurposedsec" MAXVARNAME="MaxMemory_TransitionPagesRePurposedsec" TRENDVARNAME="TrendMemory_TransitionPagesRePurposedsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Transition Pages RePurposed/sec" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\Transition Pages RePurposed/sec" />
    <THRESHOLD NAME="Memory Pages being read from the paging file" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMemory_TransitionPagesRePurposedsec > 100 Then
    IsAvgThresholdBroken = True
End If

If MaxMemory_TransitionPagesRePurposedsec > 100 Then
   IsMaxThresholdBroken = True
End If

]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="High use of memory pages being read from the paging file - memory pressure" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMemory_TransitionPagesRePurposedsec > 1000 Then
    IsAvgThresholdBroken = True
End If

If MaxMemory_TransitionPagesRePurposedsec > 1000 Then
   IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Transition Pages RePurposed is the rate at which the number of transition cache pages were reused for a different purpose.  These pages would have otherwise remained in the page cache to provide a (fast) soft fault (instead of retrieving it from backing store) in the event the page was accessed in the future.  Note these pages can contain private or sharable memory.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets Outbound Errors" ENABLED="True" ANALYZECOUNTER="\Network Interface(*)\Packets Outbound Errors" CATEGORY="Network">
    <COUNTER NAME="\Network Interface(*)\Packets Outbound Errors" MINVARNAME="MinNetworkInterface_PacketsOutboundErrors" AVGVARNAME="AvgNetworkInterface_PacketsOutboundErrors" MAXVARNAME="MaxNetworkInterface_PacketsOutboundErrors" TRENDVARNAME="TrendNetworkInterface_PacketsOutboundErrors" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Packets Outbound Errors" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Network Interface(*)\Packets Outbound Errors" />
    <THRESHOLD NAME="Network Interface Packet Errors occurring" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If AvgNetworkInterface_PacketsOutboundErrors >1 Then
  IsAvgThresholdBroken = True
End If
If MaxNetworkInterface_PacketsOutboundErrors >1 Then
  IsMaxThresholdBroken = True
End If

]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.<BR>
<BR>
If errors are occuring during this analysis, network connectivity could be affected with a potential for random Outlook RPC dialog boxes. See <A HREF="http://technet.microsoft.com/en-us/library/aa997363.aspx">http://technet.microsoft.com/en-us/library/aa997363.aspx</A> and <A HREF="http://technet.microsoft.com/en-us/library/aa995850.asp">http://technet.microsoft.com/en-us/library/aa995850.asp</A> for more information<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="MSExchange Database ==&gt; Instances Log Generation Checkpoint Depth - MBX" ENABLED="True" ANALYZECOUNTER="\MSExchange Database ==&gt; Instances(*)\Log Generation Checkpoint Depth" CATEGORY="MSExchange Database ==&gt; Instances">
    <COUNTER NAME="\MSExchange Database ==&gt; Instances(*)\Log Generation Checkpoint Depth" MINVARNAME="MinMSExchangeDatabase==&gt;Instances_LogGenerationCheckpointDepth" AVGVARNAME="AvgMSExchangeDatabase==&gt;Instances_LogGenerationCheckpointDepth" MAXVARNAME="MaxMSExchangeDatabase==&gt;Instances_LogGenerationCheckpointDepth" TRENDVARNAME="TrendMSExchangeDatabase==&gt;Instances_LogGenerationCheckpointDepth" DATATYPE="integer">
      <EXCLUDE INSTANCE="edgetransport/Transport Mail Database" />
      <EXCLUDE INSTANCE="edgetransport/IP Filtering Database" />
      <EXCLUDE INSTANCE="edgetransport/Sender Reputation Database" />
    </COUNTER>
    <CHART CHARTTITLE="\MSExchange Database ==&gt; Instances(*)\Log Generation Checkpoint Depth" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\MSExchange Database ==&gt; Instances(*)\Log Generation Checkpoint Depth" />
    <THRESHOLD NAME="Mailbox Storage Group Log Generation Checkpoint Depth greater than 250" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[Log Generation Checkpoint Depth represents the amount of work, in count of log files, that will need to be redone or undone to the database file(s) if the process crashes.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase==>Instances_LogGenerationCheckpointDepth > 250 Then
IsAvgThresholdBroken = True
End If

If MaxMSExchangeDatabase==>Instances_LogGenerationCheckpointDepth > 250 Then
IsMaxThresholdBroken = True
End If

]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Mailbox Storage Group Log Generation Checkpoint Depth greater than 500 - Mailbox" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[Log Generation Checkpoint Depth represents the amount of work, in count of log files, that will need to be redone or undone to the database file(s) if the process crashes.]]></DESCRIPTION>
      <CODE><![CDATA[If AvgMSExchangeDatabase==>Instances_LogGenerationCheckpointDepth > 500 Then
IsAvgThresholdBroken = True
End If

If MaxMSExchangeDatabase==>Instances_LogGenerationCheckpointDepth > 500 Then
IsMaxThresholdBroken = True
End If
]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Log Generation Checkpoint Depth represents the amount of work, in count of log files, that will need to be redone or undone to the database file(s) if the process crashes.<br>

<p>The Log Generation Checkpoint Depth performance counter reports the number of transaction log files that have not yet been saved to the database. This number represents the number of transaction log files that must be replayed to the database if the Microsoft Exchange Information Store service process (Store.exe) stops and needs to be restarted. As the log file generation depth increases, the Exchange Information Store startup time increases. If the transaction log file depth of a storage group reaches 5,000, the Extensible Storage Engine (ESE) dismounts all the databases that are in the affected storage group.</p>
<p>This alert indicates that the checkpoint depth is greater than 2500. The transaction log file depth may grow during periods when the server is busy. However, large values typically occur when there is a failure or when a backup fails.</p>
<p><strong>User Action:</strong><br />
To resolve this error, do one or more of the following:</p>
<ul>
    <li>Check if there is a failure, or if there is any application causing the Exchange Information Store to fail. Resolve the cause of the failure&nbsp;so that the checkpoint depth will start to decrease.</li>
    <li>Check if there is a backup process that has failed.</li>
</ul>

]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Committed Bytes" ENABLED="True" ANALYZECOUNTER="\Memory\Committed Bytes" CATEGORY="Network">
    <COUNTER NAME="\Memory\Committed Bytes" MINVARNAME="MinMemory_CommittedBytes" AVGVARNAME="AvgMemory_CommittedBytes" MAXVARNAME="MaxMemory_CommittedBytes" TRENDVARNAME="TrendMemory_CommittedBytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Committed Bytes" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\Committed Bytes" ORDERBY="ASC" />
    <COUNTER NAME="\Memory\Commit Limit" MINVARNAME="MinMemoryCommitLimit" AVGVARNAME="AvgMemoryCommitLimit" MAXVARNAME="MaxMemoryCommitLimit" TRENDVARNAME="TrendMemoryCommitLimit" DATATYPE="integer" />
    <DESCRIPTION><![CDATA[Committed Bytes is the amount of committed virtual memory, in bytes. Committed memory is the physical memory which has space reserved on the disk paging file(s). There can be one or more paging files on each physical drive. This counter displays the last observed value only; it is not an average.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Percent Committed Bytes In Use" ENABLED="True" ANALYZECOUNTER="\Memory\% Committed Bytes In Use" CATEGORY="Memory">
    <COUNTER NAME="\Memory\% Committed Bytes In Use" MINVARNAME="MinMemory_PercentCommittedBytesInUse" AVGVARNAME="AvgMemory_PercentCommittedBytesInUse" MAXVARNAME="MaxMemory_PercentCommittedBytesInUse" TRENDVARNAME="TrendMemory_PercentCommittedBytesInUse" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\% Committed Bytes In Use" OTSFORMAT="MM/dd hh:mm" GROUPSIZE="640x480" CATEGORIES="AUTO" DATATYPE="integer" LEGEND="ON" MAXCATEGORYLABELS="0" CHARTTYPE="Line" VALUES="AUTO" DATASOURCE="\Memory\% Committed Bytes In Use" ORDERBY="ASC" />
    <THRESHOLD NAME="80% or more of the Committed memory limit (physical memory plus page file) is in use - Consider installing more physical memory or increase the size of the page file(s)" CONDITION="Warning" COLOR="#FFFF00" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If MaxMemory_PercentCommittedBytesInUse => 80 Then
	IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="95% or more of the Committed memory limit (physical memory plus page file) is in use - Consider installing more physical memory or increase the size of the page file(s)" CONDITION="Critical" COLOR="#FF0000" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[If MaxMemory_PercentCommittedBytesInUse => 95 Then
	IsMaxThresholdBroken = True
End If]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% Committed Bytes In Use is the ratio of Memory\\Committed Bytes to the Memory\\Commit Limit. Committed memory is the physical memory in use for which space has been reserved in the paging file should it need to be written to disk. The commit limit is determined by the size of the paging file.  If the paging file is enlarged, the commit limit increases, and the ratio is reduced). This counter displays the current percentage value only; it is not an average.<BR>
<BR>
This analysis checks if the amount of Commited memory is becoming close to the Commit Limit (RAM plus total page file sizes), If so, then identify if you have a memory leak. If no memory leak is identified, then consider adding more physical RAM or increase the size of your page files.]]></DESCRIPTION>
  </ANALYSIS>
</PAL>