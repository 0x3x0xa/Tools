<?xml version="1.0"?>
<PAL PALVERSION="2.0" NAME="Quick System Overview" DESCRIPTION="Quick base operating system performance analysis. Use this for a high level analysis. This threshold file does not contain the Process object to help reduce overhead." CONTENTOWNERS="Clint Huffman" FEEDBACKEMAILADDRESS="clinth@microsoft.com" VERSION="1.5.2" LANGUAGE="English" LANGUAGECODE="en">
  <!--This is to allow inheritance from other threshold files. The order of the inheritance tags matters a great deal. The first one will be overwritten by the next. Once there are no more inheritance tags, the current threshold file overwrites.-->
  <QUESTION DATATYPE="integer" DEFAULTVALUE="4" QUESTIONVARNAME="NumberOfProcessors">How many processors (physical and virtual) does the server have?</QUESTION>
  <QUESTION DATATYPE="boolean" DEFAULTVALUE="False" QUESTIONVARNAME="ThreeGBSwitch">Was the /3GB switch being used on the server?</QUESTION>
  <QUESTION DATATYPE="boolean" DEFAULTVALUE="False" QUESTIONVARNAME="SixtyFourBit">Was the computer 64-bit?</QUESTION>
  <QUESTION DATATYPE="integer" DEFAULTVALUE="4" QUESTIONVARNAME="TotalMemory">How much memory did the server have in gigabytes?</QUESTION>
  <QUESTION QUESTIONVARNAME="RAID5Drives" DATATYPE="string" DEFAULTVALUE="NULL">List the physical disks that are using RAID5 separated by commas (,). Example: D,E,F. If you don't know, then use the default of NULL.</QUESTION>
  <QUESTION QUESTIONVARNAME="RAID1Drives" DATATYPE="string" DEFAULTVALUE="NULL">List the physical disks that are using RAID1, RAID0+1, or RAID10 separated by commas (,). Example: D,E,F. If you don't know, then use the default of NULL.</QUESTION>
  <ANALYSIS NAME="Memory Available MBytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Available MBytes" ID="{798f674d-5173-4115-a051-4589dde82bea}">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Available MBytes" EXPRESSIONPATH="\Memory\Available MBytes" COLLECTIONVARNAME="CollectionOfAvailableMBytes" DATATYPE="Integer" />
    <CHART CHARTTITLE="\Memory\Available MBytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Available MBytes" CHARTLABELS="instance" BACKGRADIENTSTYLE="BottomTop">
      <SERIES NAME="Warning">
        <CODE><![CDATA[$TenPercentOfPhysicalMemory = $([Int] $TotalMemory * 1024) * 0.10
$FivePercentOfPhysicalMemory = $([Int] $TotalMemory * 1024) * 0.05
If ($FivePercentOfPhysicalMemory -lt 64)
{$FivePercentOfPhysicalMemory = 64
}
StaticChartThreshold -CollectionOfCounterInstances $CollectionOfAvailableMBytes -MinThreshold $FivePercentOfPhysicalMemory -MaxThreshold $TenPercentOfPhysicalMemory -IsOperatorGreaterThan $False -UseMaxValue $False
]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[$FivePercentOfPhysicalMemory = $([Int] $TotalMemory * 1024) * 0.05
If ($FivePercentOfPhysicalMemory -lt 64)
{$FivePercentOfPhysicalMemory = 64
}
StaticChartThreshold -CollectionOfCounterInstances $CollectionOfAvailableMBytes -MinThreshold 0.001 -MaxThreshold $FivePercentOfPhysicalMemory -IsOperatorGreaterThan $False -UseMaxValue $True
]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Less than 10 percent of RAM is available" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
$TenPercentOfPhysicalMemory = $([Int] $TotalMemory * 1024) * 0.10

StaticThreshold -CollectionOfCounterInstances $CollectionOfAvailableMBytes -Operator 'lt' -Threshold $TenPercentOfPhysicalMemory
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 5 percent of RAM is available or less than 64MBs of RAM is available" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[$FivePercentOfPhysicalMemory = $([Int] $TotalMemory * 1024) * 0.05
If ($FivePercentOfPhysicalMemory -lt 64)

{$FivePercentOfPhysicalMemory = 64}
StaticThreshold -CollectionOfCounterInstances $CollectionOfAvailableMBytes -Operator 'lt' -Threshold $FivePercentOfPhysicalMemory
        ]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[
Available MBytes is the amount of physical RAM, in Megabytes, immediately available for allocation to a process or for system use. It is equal to the sum of memory assigned to the standby (cached), free and zero page lists. If this counter is low, then the computer is running low on physical RAM.<BR>
This analysis will alert a Warning if this counter's value is less than 10% of the RAM installed and will alert a critical if this counter's value is less than 100MB's. When Windows Server 2003 and newer has less then 100MBs of available RAM, it will go into a low memory condition and alert processes of this condition. If in a low memory condition the operating system will be more aggressive at working set trimming which pages out the physical RAM used by processes to the pagefile on the disk.
<br>
<br>
<B>References:</B>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
<LI><A HREF="http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos">How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment</A></LI>
</UL>
<BR>

]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % Processor Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% Processor Time" ID="{cb0ff328-03e6-46e2-b1c9-aae2e23deff3}">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Processor Time" EXPRESSIONPATH="\Processor(*)\% Processor Time" COLLECTIONVARNAME="CollectionOfPercentProcessorTime" DATATYPE="Integer" />
    <THRESHOLD NAME="More than 50% Processor Utilization" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPercentProcessorTime -Operator 'gt' -Threshold 50
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% Processor Utilization" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfPercentProcessorTime -Operator 'gt' -Threshold 80
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Processor(*)\% Processor Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\% Processor Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPercentProcessorTime -MinThreshold 50 -MaxThreshold 80 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPercentProcessorTime -MinThreshold 80 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[<B>% Processor Time</B> is the percentage of elapsed time that the processor spends to execute a non-Idle thread. It is calculated by measuring the duration of the idle thread is active in the sample interval, and subtracting that time from interval duration. This counter is the primary indicator of processor activity, and displays the average percentage of busy time observed during the sample interval. <B>% Processor Time</B> is the sum of <B>% User Time </B> and <B>% Privileged Time</B> unless there is hardware involvement in the form of interupts and/or DPCs.<BR>
<BR>
This analysis creates a Warning alert for utilization greater than 50% on any processor and creates a critical alert for utilization greater than 80%.<BR>
<BR>

If average processor utilization is high based on the thresholds witin this analysis, then check if it is high user mode CPU or high privileged mode. If high privileged mode CPU is suspected, then see the Privileged Mode CPU Analysis. If a user-mode processor bottleneck is suspected, then consider using a process profiler to analyze the functions causing the high CPU consumption. See <A HREF="http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos">How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment</A> article in the references section for more information.
      <BR>
<B>References:</B>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
<LI><A HREF="http://www.codeplex.com/PerfTesting/Wiki/View.aspx?title=How%20To%3a%20Identify%20a%20Disk%20Performance%20Bottleneck%20Using%20SPA&referringTitle=How%20Tos">How To: Identify Functions causing a High User-mode CPU Bottleneck for Server Applications in a Production Environment</A></LI>
</UL>
<BR>

]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % Privileged Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% Privileged Time" ID="{458b8c41-1cd4-4380-97e5-07aa279f841f}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Privileged Time" COLLECTIONVARNAME="CollectionOfProcessorPercentPrivilegedTimeAll" EXPRESSIONPATH="\Processor(*)\% Privileged Time" DATATYPE="integer" />
    <THRESHOLD NAME="More than 20% privileged (kernel) mode CPU usage" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentPrivilegedTimeAll -Operator 'gt' -Threshold 20        
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 30% privileged (kernel) mode CPU usage" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentPrivilegedTimeAll -Operator 'gt' -Threshold 30
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Processor(*)\% Privileged Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\% Privileged Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentPrivilegedTimeAll -MinThreshold 20 -MaxThreshold 30 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentPrivilegedTimeAll -MinThreshold 30 -MaxThreshold 99.999 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[This counter indicates the percentage of time a thread runs in privileged mode also known as kernel mode. When your application calls operating system functions (for example to perform file or network I/O or to allocate memory), these operating system functions are executed in privileged mode.<BR>
<BR>
High privileged mode CPU indicates that computer is spending too much time in system I/O versus real (user mode) work. % Privileged Time is the percentage of elapsed time that the process threads spent executing code in privileged mode.  When a Windows system service in called, the service will often run in privileged mode to gain access to system-private data. Such data is protected from access by threads executing in user mode. Calls to the system can be explicit or implicit, such as page faults or interrupts. Unlike some early operating systems, Windows uses process boundaries for subsystem protection in addition to the traditional protection of user and privileged modes. Some work done by Windows on behalf of the application might appear in other subsystem processes in addition to the privileged time in the process.<BR>
<BR>
This analysis throws a warning alert if privileged mode CPU is consuming more than 20% of total CPU and a critical alert if consuming More than 30% of total CPU.<br>

<BR>
<B>Next steps</B><BR>
The CPU consumption might be caused by another busy resource such as network, memory, or disk I/O. High privileged mode CPU can also by caused by high amounts of Context Switches/second. See the High Context Switches/second analysis. The <A HREF="http://www.microsoft.com/whdc/system/sysperf/krview.mspx">KernRate (KrView) tool</A> can be used to profile the kernel to see what component is consuming the most kernel resources. To see more information about how KernRate can be used to analyze high priviledge mode CPU problems, see Mark Russinovich's blog entry in the references section below.<BR>
<BR>
<B>References:</B><BR>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
<LI><A HREF="http://blogs.technet.com/markrussinovich/archive/2008/04/07/3031251.aspx">Mark's Blog : The Case of the System Process CPU Spikes</A></LI>
</UL>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface % Network Utilization" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Bytes Total/sec" ID="{2a3b7706-a244-4d0d-a0a8-33f5eddcdee7}">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Bytes Total/sec" EXPRESSIONPATH="\Network Interface(*)\Bytes Total/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfaceBytesTotalPerSec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Current Bandwidth" EXPRESSIONPATH="\Network Interface(*)\Current Bandwidth" COLLECTIONVARNAME="CollectionOfNetworkInterfaceCurrentBandwidth" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\Network Interface(*)\% Network Utilization" EXPRESSIONPATH="\Network Interface(*)\% Network Utilization" COLLECTIONVARNAME="CollectionOfNetworkUtilization" DATATYPE="integer">
      <CODE><![CDATA[
          $CollectionOfNetworkUtilization = @{}
          For ($i=0;$i -lt $CollectionOfNetworkInterfaceBytesTotalPerSec.Count;$i++)
          {
            For ($a=0;$a -lt $CollectionOfNetworkInterfaceCurrentBandwidth.Count;$a++)
            {
              If ($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].CounterInstance -eq $CollectionOfNetworkInterfaceCurrentBandwidth[$a].CounterInstance)
              { 
                $b = $a
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $CollectionOfNetworkInterfaceBytesTotalPerSec[$i].Value.Count;$v++)
            {
              If (($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].QuantizedAvg[$v] -gt 0) -and ($CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v] -gt 0))
              {
                [int]$iPercentageOfNetworkUtilization = (([double]$CollectionOfNetworkInterfaceBytesTotalPerSec[$i].QuantizedAvg[$v] * 8) / [double]$CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v]) * 100
                [void] $alValues.Add($iPercentageOfNetworkUtilization)
              }
              Else
              {
                [void] $alValues.Add(0)
              }
            }
            $sGeneratedInstanceName = "\\$($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].CounterComputer)\$($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].CounterObject)($($CollectionOfNetworkInterfaceBytesTotalPerSec[$i].CounterInstance))\% Network Utilization"
            $CollectionOfNetworkUtilization.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 50% Network Utilization" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilization -Operator 'gt' -Threshold 50
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% Network Utilization" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilization -Operator 'gt' -Threshold 80

        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="% Network Utilization" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\% Network Utilization" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilization -MinThreshold 50 -MaxThreshold 80 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilization -MinThreshold 80 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ % Network Utilization doesn't exist as a normal performance counter, so this analysis uses multiplies <B>\Network Interface(*)\Bytes Total/sec</B> by 8 (to convert it to bits total/sec), divides it by <B>\Network Interface(*)\Current Bandwidth</B>, and multiplies the result by 100 to create a percentage. This analysis throws a warning alert when greater than 50 and throws a critical alert when greater than 80.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Output Queue Length" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Output Queue Length" ID="{c656eb10-a1f1-48d1-bc49-91abbb8bf4a1}">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Output Queue Length" EXPRESSIONPATH="\Network Interface(*)\Output Queue Length" COLLECTIONVARNAME="CollectionOfNetworkInterfaceOutputQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 1 packet is waiting in the output queue" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceOutputQueueLength -Operator 'gt' -Threshold 1
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 2 packets are waiting in the output queue" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceOutputQueueLength -Operator 'gt' -Threshold 2
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Network Interface(*)\Output Queue Length" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\Output Queue Length" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceOutputQueueLength -MinThreshold 1 -MaxThreshold 1.999 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfaceOutputQueueLength -MinThreshold 2 -MaxThreshold 2.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
  </ANALYSIS>
  <!-- % Network Utilization send and receive -->
  <ANALYSIS NAME="Network Interface % Network Utilization Sent" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Bytes Sent/sec" ID="{3f2dd3c0-3b1a-4b2b-84c0-97fd4d26c138}">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Bytes Sent/sec" EXPRESSIONPATH="\Network Interface(*)\Bytes Sent/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfaceBytesSentPerSec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Current Bandwidth" EXPRESSIONPATH="\Network Interface(*)\Current Bandwidth" COLLECTIONVARNAME="CollectionOfNetworkInterfaceCurrentBandwidth" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\Network Interface(*)\% Network Utilization Sent" EXPRESSIONPATH="\Network Interface(*)\% Network Utilization Sent" COLLECTIONVARNAME="CollectionOfNetworkUtilizationSent" DATATYPE="integer">
      <CODE><![CDATA[
          $CollectionOfNetworkUtilizationSent = @{}
          For ($i=0;$i -lt $CollectionOfNetworkInterfaceBytesSentPerSec.Count;$i++)
          {
            For ($a=0;$a -lt $CollectionOfNetworkInterfaceCurrentBandwidth.Count;$a++)
            {
              If ($CollectionOfNetworkInterfaceBytesSentPerSec[$i].CounterInstance -eq $CollectionOfNetworkInterfaceCurrentBandwidth[$a].CounterInstance)
              { 
                $b = $a
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $CollectionOfNetworkInterfaceBytesSentPerSec[$i].Value.Count;$v++)
            {
              If (($CollectionOfNetworkInterfaceBytesSentPerSec[$i].QuantizedAvg[$v] -gt 0) -and ($CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v] -gt 0))
              {
                [int]$iPercentageOfNetworkUtilization = (([double]$CollectionOfNetworkInterfaceBytesSentPerSec[$i].QuantizedAvg[$v] * 8) / [double]$CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v]) * 100
                [void] $alValues.Add($iPercentageOfNetworkUtilization)
              }
              Else
              {
                [void] $alValues.Add(0)
              }
            }
            $sGeneratedInstanceName = "\\$($CollectionOfNetworkInterfaceBytesSentPerSec[$i].CounterComputer)\$($CollectionOfNetworkInterfaceBytesSentPerSec[$i].CounterObject)($($CollectionOfNetworkInterfaceBytesSentPerSec[$i].CounterInstance))\% Network Utilization Sent"
            $CollectionOfNetworkUtilizationSent.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 50% network utilization sent" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilizationSent -Operator 'gt' -Threshold 50
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% network utilization sent" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilizationSent -Operator 'gt' -Threshold 80
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="% Network Utilization Sent" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\% Network Utilization Sent" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilizationSent -MinThreshold 50 -MaxThreshold 80 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilizationSent -MinThreshold 80 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ % Network Utilization Sent doesn't exist as a normal performance counter, so this analysis uses multiplies <B>\Network Interface(*)\Bytes Sent/sec</B> by 8 (to convert it to bits total/sec), divides it by <B>\Network Interface(*)\Current Bandwidth</B>, and multiplies the result by 100 to create a percentage. This analysis throws a warning alert when greater than 50 and throws a critical alert when greater than 80.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface % Network Utilization Received" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Bytes Received/sec" ID="{da746e97-b1f4-42d4-b13d-88f199636989}">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Bytes Received/sec" EXPRESSIONPATH="\Network Interface(*)\Bytes Received/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfaceBytesReceivedPerSec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Current Bandwidth" EXPRESSIONPATH="\Network Interface(*)\Current Bandwidth" COLLECTIONVARNAME="CollectionOfNetworkInterfaceCurrentBandwidth" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\Network Interface(*)\% Network Utilization Received" EXPRESSIONPATH="\Network Interface(*)\% Network Utilization Received" COLLECTIONVARNAME="CollectionOfNetworkUtilizationReceived" DATATYPE="integer">
      <CODE><![CDATA[
          $CollectionOfNetworkUtilizationReceived = @{}
          For ($i=0;$i -lt $CollectionOfNetworkInterfaceBytesReceivedPerSec.Count;$i++)
          {
            For ($a=0;$a -lt $CollectionOfNetworkInterfaceCurrentBandwidth.Count;$a++)
            {
              If ($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].CounterInstance -eq $CollectionOfNetworkInterfaceCurrentBandwidth[$a].CounterInstance)
              { 
                $b = $a
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].Value.Count;$v++)
            {
              If (($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].QuantizedAvg[$v] -gt 0) -and ($CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v] -gt 0))
              {
                [int]$iPercentageOfNetworkUtilization = (([double]$CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].QuantizedAvg[$v] * 8) / [double]$CollectionOfNetworkInterfaceCurrentBandwidth[$b].QuantizedAvg[$v]) * 100
                [void] $alValues.Add($iPercentageOfNetworkUtilization)
              }
              Else
              {
                [void] $alValues.Add(0)
              }
            }
            $sGeneratedInstanceName = "\\$($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].CounterComputer)\$($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].CounterObject)($($CollectionOfNetworkInterfaceBytesReceivedPerSec[$i].CounterInstance))\% Network Utilization Received"
            $CollectionOfNetworkUtilizationReceived.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 50% network utilization received" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilizationReceived -Operator 'gt' -Threshold 50
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% network utilization received" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilizationReceived -Operator 'gt' -Threshold 80

        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="% Network Utilization Received" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\% Network Utilization Received" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilizationReceived -MinThreshold 50 -MaxThreshold 80 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkUtilizationReceived -MinThreshold 80 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ % Network Utilization Received doesn't exist as a normal performance counter, so this analysis uses multiplies <B>\Network Interface(*)\Bytes Received/sec</B> by 8 (to convert it to bits total/sec), divides it by <B>\Network Interface(*)\Current Bandwidth</B>, and multiplies the result by 100 to create a percentage. This analysis throws a warning alert when greater than 50 and throws a critical alert when greater than 80.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="System Processor Queue Length" ENABLED="True" CATEGORY="System" PRIMARYDATASOURCE="\System\Processor Queue Length" ID="{36a4a252-92de-4d0c-9a28-ca817290ec75}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\System\Processor Queue Length" COLLECTIONVARNAME="SystemProcessorQueueLength" EXPRESSIONPATH="\System\Processor Queue Length" DATATYPE="Integer" />
    <THRESHOLD NAME="More than 2 ready threads are queued for each processor" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.
$TempNumberOfProcessors = $NumberOfProcessors
$TempNumberOfProcessors = [Int] $TempNumberOfProcessors
If ($TempNumberOfProcessors -ge 1)
{
$TwoTimesNumberOfProcessors = $TempNumberOfProcessors * 2
}
Else
{
$TwoTimesNumberOfProcessors = 2
}        
StaticThreshold -CollectionOfCounterInstances $SystemProcessorQueueLength -Operator 'gt' -Threshold $TwoTimesNumberOfProcessors]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 10 ready threads are queued for each processor" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.
$TempNumberOfProcessors = $NumberOfProcessors
$TempNumberOfProcessors = [Int] $TempNumberOfProcessors
If ($TempNumberOfProcessors -ge 1)
{
	$TenTimesNumberOfProcessors = $TempNumberOfProcessors * 10
}
Else
{
	$TenTimesNumberOfProcessors = 10
}        
StaticThreshold -CollectionOfCounterInstances $SystemProcessorQueueLength -Operator 'gt' -Threshold $TenTimesNumberOfProcessors]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\System\Processor Queue Length" ISTHRESHOLDSADDED="True" DATASOURCE="\System\Processor Queue Length" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[#// The minus 0.001 allow the values allow the critical values to be at the very top of the chart otherwise the chart control pads it with white space.
#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.
$TempNumberOfProcessors = $NumberOfProcessors
$TempNumberOfProcessors = [Int] $TempNumberOfProcessors
If ($TempNumberOfProcessors -ge 1)
{
	$TwoTimesNumberOfProcessors = ($TempNumberOfProcessors * 2) - 0.001
	$TenTimesNumberOfProcessors = ($TempNumberOfProcessors * 10) - 0.001
}
Else
{
	$TwoTimesNumberOfProcessors = 2 - 0.001
	$TenTimesNumberOfProcessors = 10 - 0.001
}
StaticChartThreshold -CollectionOfCounterInstances $SystemProcessorQueueLength -MinThreshold $TwoTimesNumberOfProcessors -MaxThreshold $TenTimesNumberOfProcessors
 ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[#// The minus 0.001 allow the values allow the critical values to be at the very top of the chart otherwise the chart control pads it with white space.
#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.
$TempNumberOfProcessors = $NumberOfProcessors
$TempNumberOfProcessors = [Int] $TempNumberOfProcessors
If ($TempNumberOfProcessors -ge 1)
{
	$TenTimesNumberOfProcessors = ($TempNumberOfProcessors * 10) - 0.001
	$TwentyTimesNumberOfProcessors = ($TempNumberOfProcessors * 20) - 0.001
}
Else
{
	$TenTimesNumberOfProcessors = 2 - 0.001
	$TwentyTimesNumberOfProcessors = 10 - 0.001
}
StaticChartThreshold -CollectionOfCounterInstances $SystemProcessorQueueLength -MinThreshold $TenTimesNumberOfProcessors -MaxThreshold $TwentyTimesNumberOfProcessors
]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Processor Queue Length (PQL) is the number of threads in the processor queue. Unlike the disk counters, this counter shows ready threads only, not threads that are running. There is a single queue for processor time even on computers with multiple processors. Therefore, if a computer has multiple processors, you need to divide this value by the number of processors servicing the workload. A sustained processor queue of less than 10 threads per processor is normally acceptable, dependent of the workload.<BR>

<BR>

This analysis determines if the average processor queue length exceeds the number of processors. If so, then this could indicate a processor bottleneck. Use this analysis in correlation with Privileged Mode CPU Analysis and Excessive Processor Use by Process analysis.<BR>

<BR>
<b>Note:</b> Due to the way in which this counter is collected, ignore this counter and alerts for it when collected from a virtual computer.<BR>
<BR>

If there are more tasks ready to run than there are processors, threads queue up. The processor queue is the collection of threads that are ready but not able to be executed by the processor because another active thread is currently executing. A sustained or recurring queue of more threads than number of processors is a good indication of a processor bottleneck.<BR>

<BR>

You can use this counter in conjunction with the <B>\Processor\% Processor Time</B> counter to determine if your application can benefit from more CPUs.<BR>

<BR>

<B>Reference:</B>
<UL>
<LI><A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">Measuring .NET Application Performance</A></LI>
</UL>
 ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="System High Context Switching" ENABLED="True" CATEGORY="System" PRIMARYDATASOURCE="\System\Context Switches/sec" ID="{c0eb3777-a89d-4889-bc37-2f5865a928ee}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(_Total)\% Processor Time" COLLECTIONVARNAME="ProcessorPercentProcessorTimeTotal" EXPRESSIONPATH="\Processor(_Total)\% Processor Time" DATATYPE="Integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(_Total)\% Privileged Time" COLLECTIONVARNAME="ProcessorPercentPrivilegedTimeTotal" EXPRESSIONPATH="\Processor(_Total)\% Privileged Time" DATATYPE="Integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\System\Context Switches/sec" COLLECTIONVARNAME="SystemContextSwitchessec" EXPRESSIONPATH="\System\Context Switches/sec" DATATYPE="Integer" />
    <THRESHOLD NAME="More than 2,500 Context Switches/sec per processor, more than 20% ratio of privileged to total CPU, and more than 50% total processor time or more than 10,000 Context Switches/sec" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.
$TempNumberOfProcessors = $NumberOfProcessors


        $TempNumberOfProcessors = [Int] $TempNumberOfProcessors
          If ($TempNumberOfProcessors -ge 1)
          {
            $TwentyFiveHundredTimesNumberOfProcessors = ($TempNumberOfProcessors * 2500)
          }
          Else
          {
            $TwentyFiveHundredTimesNumberOfProcessors = 2500
          }
          For ($i=0;$i -lt $SystemContextSwitchessec.Count;$i++)
          {
            $oCounterInstance = $SystemContextSwitchessec[$i]
            For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
            {
              $IsMinThresholdBroken = $False
              $IsAvgThresholdBroken = $False
              $IsMaxThresholdBroken = $False
              $IsTrendThresholdBroken = $False
              $IsMinEvaluated = $False
              $IsAvgEvaluated = $False
              $IsMaxEvaluated = $False
              $IsTrendEvaluated = $False
              If (($oCounterInstance.QuantizedMin[$t] -ne '-') -and ($oCounterInstance.QuantizedMin[$t] -ne $null))
              {
                If (($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t] -ne '-') -and ($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t] -ne $null))
                {
                  If (($ProcessorPercentPrivilegedTimeTotal[0].QuantizedMin[$t] -ne '-') -and ($ProcessorPercentPrivilegedTimeTotal[0].QuantizedMin[$t] -ne $null))
                  {
                    $PercentageOfPrivilegedModeCPUToTotalCPU = ($($ProcessorPercentPrivilegedTimeTotal[0].QuantizedMin[$t]) * 100) / $($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t])
                    If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 20) -and ($($oCounterInstance.QuantizedMin[$t]) -gt $TwentyFiveHundredTimesNumberOfProcessors) -and ($($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t]) -gt 50))
                    {
                      $IsMinThresholdBroken = $True
                      $IsMinEvaulated = $True
                    }
                    If ($($oCounterInstance.QuantizedMin[$t]) -gt 10000)
                    {
                      $IsMinThresholdBroken = $True
                      $IsMinEvaulated = $True
                    }
                  }
                }
              }
            
              If (($oCounterInstance.QuantizedAvg[$t] -ne '-') -and ($oCounterInstance.QuantizedAvg[$t] -ne $null))
              {
                If (($ProcessorPercentProcessorTimeTotal[0].QuantizedAvg[$t] -ne '-') -and ($ProcessorPercentProcessorTimeTotal[0].QuantizedAvg[$t] -ne $null))
                {
                  If (($ProcessorPercentPrivilegedTimeTotal[0].QuantizedAvg[$t] -ne '-') -and ($ProcessorPercentPrivilegedTimeTotal[0].QuantizedAvg[$t] -ne $null))
                  {
                    $PercentageOfPrivilegedModeCPUToTotalCPU = ($($ProcessorPercentPrivilegedTimeTotal[0].QuantizedAvg[$t]) * 100) / $($ProcessorPercentProcessorTimeTotal[0].QuantizedAvg[$t])
                    If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 20) -and ($($oCounterInstance.QuantizedAvg[$t]) -gt $TwentyFiveHundredTimesNumberOfProcessors) -and ($($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t]) -gt 50))
                    {
                      $IsAvgThresholdBroken = $True
                      $IsAvgEvaulated = $True
                    }
                    If ($($oCounterInstance.QuantizedAvg[$t]) -gt 10000)
                    {
                      $IsAvgThresholdBroken = $True
                      $IsAvgEvaulated = $True
                    }
                  }
                }
              }
              If (($oCounterInstance.QuantizedMax[$t] -ne '-') -and ($oCounterInstance.QuantizedMax[$t] -ne $null))
              {
                If (($ProcessorPercentProcessorTimeTotal[$i].QuantizedMax[$t] -ne '-') -and ($ProcessorPercentProcessorTimeTotal[$i].QuantizedMax[$t] -ne $null))
                {
                  If (($ProcessorPercentPrivilegedTimeTotal[$i].QuantizedMax[$t] -ne '-') -and ($ProcessorPercentPrivilegedTimeTotal[$i].QuantizedMax[$t] -ne $null))
                  {
                    $PercentageOfPrivilegedModeCPUToTotalCPU = ($($ProcessorPercentPrivilegedTimeTotal[0].QuantizedMax[$t]) * 100) / $($ProcessorPercentProcessorTimeTotal[$i].QuantizedMax[$t])
                    If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 20) -and ($($oCounterInstance.QuantizedMax[$t]) -gt $TwentyFiveHundredTimesNumberOfProcessors) -and ($($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t]) -gt 50))
                    {
                      $IsMaxThresholdBroken = $True
                      $IsMaxEvaulated = $True
                    }
                    If ($($oCounterInstance.QuantizedMax[$t]) -gt 10000)
                    {
                      $IsMaxThresholdBroken = $True
                      $IsMaxEvaulated = $True
                    }                    
                  }
                }
              }        
              If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
              {
                  CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
              }
            }
          }]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 5,000 Context Switches/sec per processor, more than 30% ratio of privileged to total CPU, and more than 70% total processor time or more than 20,000 Context Switches/sec" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.
$TempNumberOfProcessors = $NumberOfProcessors

$TempNumberOfProcessors = [Int] $TempNumberOfProcessors
If ($TempNumberOfProcessors -ge 1)
{
	$FiveThousandTimesNumberOfProcessors = ($TempNumberOfProcessors * 5000)
}
Else
{
	$FiveThousandTimesNumberOfProcessors = 5000
}
For ($i=0;$i -lt $SystemContextSwitchessec.Count;$i++)
{
	$oCounterInstance = $SystemContextSwitchessec[$i]
	For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
	{
	  $IsMinThresholdBroken = $False
	  $IsAvgThresholdBroken = $False
	  $IsMaxThresholdBroken = $False
	  $IsTrendThresholdBroken = $False
	  $IsMinEvaluated = $False
	  $IsAvgEvaluated = $False
	  $IsMaxEvaluated = $False
	  $IsTrendEvaluated = $False

	  If (($oCounterInstance.QuantizedMin[$t] -ne '-') -and ($oCounterInstance.QuantizedMin[$t] -ne $null))
	  {
	    If (($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t] -ne '-') -and ($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t] -ne $null))
	    {
	      If (($ProcessorPercentPrivilegedTimeTotal[0].QuantizedMin[$t] -ne '-') -and ($ProcessorPercentPrivilegedTimeTotal[0].QuantizedMin[$t] -ne $null))
	      {
	        $PercentageOfPrivilegedModeCPUToTotalCPU = ($($ProcessorPercentPrivilegedTimeTotal[0].QuantizedMin[$t]) * 100) / $($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t])
	        If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 30) -and ($($oCounterInstance.QuantizedMin[$t]) -gt $FiveThousandTimesNumberOfProcessors) -and ($($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t]) -gt 70))
	        {
	          $IsMinThresholdBroken = $True
	          $IsMinEvaulated = $True
	        }
	        If ($($oCounterInstance.QuantizedMin[$t]) -gt 20000)
	        {
	          $IsMinThresholdBroken = $True
	          $IsMinEvaulated = $True
	        }
	      }
	    }
	  }

	  If (($oCounterInstance.QuantizedAvg[$t] -ne '-') -and ($oCounterInstance.QuantizedAvg[$t] -ne $null))
	  {
	    If (($ProcessorPercentProcessorTimeTotal[0].QuantizedAvg[$t] -ne '-') -and ($ProcessorPercentProcessorTimeTotal[0].QuantizedAvg[$t] -ne $null))
	    {
	      If (($ProcessorPercentPrivilegedTimeTotal[0].QuantizedAvg[$t] -ne '-') -and ($ProcessorPercentPrivilegedTimeTotal[0].QuantizedAvg[$t] -ne $null))
	      {
	        $PercentageOfPrivilegedModeCPUToTotalCPU = ($($ProcessorPercentPrivilegedTimeTotal[0].QuantizedAvg[$t]) * 100) / $($ProcessorPercentProcessorTimeTotal[0].QuantizedAvg[$t])
	        If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 30) -and ($($oCounterInstance.QuantizedAvg[$t]) -gt $FiveThousandTimesNumberOfProcessors) -and ($($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t]) -gt 70))
	        {
	          $IsAvgThresholdBroken = $True
	          $IsAvgEvaulated = $True
	        }
	        If ($($oCounterInstance.QuantizedAvg[$t]) -gt 20000)
	        {
	          $IsAvgThresholdBroken = $True
	          $IsAvgEvaulated = $True
	        }                    
	      }
	    }
	  }
	  If (($oCounterInstance.QuantizedMax[$t] -ne '-') -and ($oCounterInstance.QuantizedMax[$t] -ne $null))
	  {
	    If (($ProcessorPercentProcessorTimeTotal[$i].QuantizedMax[$t] -ne '-') -and ($ProcessorPercentProcessorTimeTotal[$i].QuantizedMax[$t] -ne $null))
	    {
	      If (($ProcessorPercentPrivilegedTimeTotal[$i].QuantizedMax[$t] -ne '-') -and ($ProcessorPercentPrivilegedTimeTotal[$i].QuantizedMax[$t] -ne $null))
	      {
	        $PercentageOfPrivilegedModeCPUToTotalCPU = ($($ProcessorPercentPrivilegedTimeTotal[0].QuantizedMax[$t]) * 100) / $($ProcessorPercentProcessorTimeTotal[$i].QuantizedMax[$t])
	        If (($PercentageOfPrivilegedModeCPUToTotalCPU -gt 30) -and ($($oCounterInstance.QuantizedMax[$t]) -gt $FiveThousandTimesNumberOfProcessors) -and ($($ProcessorPercentProcessorTimeTotal[0].QuantizedMin[$t]) -gt 70))
	        {
	          $IsMaxThresholdBroken = $True
	          $IsMaxEvaulated = $True
	        }
	        If ($($oCounterInstance.QuantizedMax[$t]) -gt 20000)
	        {
	          $IsMaxThresholdBroken = $True
	          $IsMaxEvaulated = $True
	        }                    
	      }
	    }
	  }        
	  If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
	  {
	      CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
	  }
	}
} ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\System\Context Switches/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\System\Context Switches/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.
$TempNumberOfProcessors = $NumberOfProcessors
#// The minus 0.001 allow the values allow the critical values to be at the very top of the chart otherwise the chart control pads it with white space.
$TempNumberOfProcessors = [Int] $TempNumberOfProcessors          
If ($($NumberOfProcessors) -ge 1)
{
	$TwentyFiveHundredTimesNumberOfProcessors = ($TempNumberOfProcessors * 2500) - 0.001
}
Else
{
	$TwentyFiveHundredTimesNumberOfProcessors = 2500 - 0.001
}
$DoubleTwentyFiveHundredTimesNumberOfProcessors = $TwentyFiveHundredTimesNumberOfProcessors * 2
StaticChartThreshold -CollectionOfCounterInstances $SystemContextSwitchessec -MinThreshold $TwentyFiveHundredTimesNumberOfProcessors -MaxThreshold $DoubleTwentyFiveHundredTimesNumberOfProcessors]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[#// The variable NumberOfProcessors has to be replaced by a collection object which doesnt resolve correctly on the math formula, so setting it to a temp variable first.
$TempNumberOfProcessors = $NumberOfProcessors

#// The minus 0.001 allow the values allow the critical values to be at the very top of the chart otherwise the chart control pads it with white space.
$TempNumberOfProcessors = [Int] $TempNumberOfProcessors
If ($TempNumberOfProcessors -ge 1)
{
	$TwentyFiveHundredTimesNumberOfProcessors = ($TempNumberOfProcessors * 2500)
	$FiveThousandTimesNumberOfProcessors = ($TempNumberOfProcessors * 5000)
}
Else
{
	$FiveThousandTimesNumberOfProcessors = 5000
	$TenThousandTimesNumberOfProcessors = 10000
}
$DoubleTwentyFiveHundredTimesNumberOfProcessors = ($TwentyFiveHundredTimesNumberOfProcessors * 2) - 0.001
$DoubleFiveThousandTimesNumberOfProcessors = ($FiveThousandTimesNumberOfProcessors * 2) - 0.001
StaticChartThreshold -CollectionOfCounterInstances $SystemContextSwitchessec -MinThreshold $DoubleTwentyFiveHundredTimesNumberOfProcessors -MaxThreshold $DoubleFiveThousandTimesNumberOfProcessors]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[
Context Switches/sec is the combined rate at which all processors on the computer are switched from one thread to another. Context switches occur when a running thread voluntarily relinquishes the processor, is preempted by a higher priority ready thread, or switches between user-mode and privileged (kernel) mode to use an Executive or subsystem service. It is the sum of Thread\\Context Switches/sec for all threads running on all processors in the computer and is measured in numbers of switches.  There are context switch counters on the System and Thread objects. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.<BR>
<BR>
High context switching is only a problem if overall CPU is high as well. This analysis checks for high CPU, high privileged mode CPU, and high system context switches per sec.<BR>
<BR>
Threshold: As a general rule, context switching rates of greater than 5,000 per second per processor are considered a warning. If context switching rates exceed 10,000 per second per processor, then there is a constraint.<BR>
<BR>
Significance: Context switching happens when a higher priority thread preempts a lower priority thread that is currently running or when a high priority thread blocks. High levels of context switching can occur when many threads share the same priority level. This often indicates that there are too many threads competing for the processors on the system. If you do not see much processor utilization and you see very low levels of context switching, it could indicate that threads are blocked.<BR>
<BR>
<B>Reference:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Private Bytes" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(_Total)\Private Bytes" ID="{bf135d67-22c5-4839-b039-3b8c0e587cd8}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(_Total)\Private Bytes" COLLECTIONVARNAME="ProcessPrivateBytesTotal" EXPRESSIONPATH="\Process(_Total)\Private Bytes" DATATYPE="integer" />
    <THRESHOLD NAME="Possible Memory Leak: More than 250MBs between overall Min and overall Max and an increasing trend of more than 10MBs per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
        $TenMegaBytes = 10485760
        $TwoHundredAndFiftyMegaBytes = 262144000
          For ($i=0;$i -lt $ProcessPrivateBytesTotal.Count;$i++)
          {
            $oCounterInstance = $ProcessPrivateBytesTotal[$i]
            For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
            {
              $IsMinThresholdBroken = $False
              $IsAvgThresholdBroken = $False
              $IsMaxThresholdBroken = $False
              $IsTrendThresholdBroken = $False
              $IsMinEvaluated = $False
              $IsAvgEvaluated = $False
              $IsMaxEvaluated = $False
              $IsTrendEvaluated = $False
            
              If (($oCounterInstance.Min -ne '-') -and ($oCounterInstance.Min -ne $null))
              {
                If (($oCounterInstance.Max -ne '-') -and ($oCounterInstance.Max -ne $null))
                {
                  $MinMaxDifference = $($oCounterInstance.Max) - $($oCounterInstance.Min)                  
                  If (($MinMaxDifference -gt $TwoHundredAndFiftyMegaBytes) -and ($oCounterInstance.QuantizedTrend[$t] -gt $TenMegaBytes))
                  {
                    $IsTrendThresholdBroken = $True
                    $IsTrendEvaluated = $True
                  }
                }
              }
              
              If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
              {
                  CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
              }
            }
          }
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Possible Memory Leak: More than 500MBs between overall Min and overall Max and an increasing trend of more than 100MBs per hour" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        $OneHundredMegaBytes = 104857600
        $FiveHundresMegaBytes = 524288000
          For ($i=0;$i -lt $ProcessPrivateBytesTotal.Count;$i++)
          {
            $oCounterInstance = $ProcessPrivateBytesTotal[$i]
            For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
            {
              $IsMinThresholdBroken = $False
              $IsAvgThresholdBroken = $False
              $IsMaxThresholdBroken = $False
              $IsTrendThresholdBroken = $False
              $IsMinEvaluated = $False
              $IsAvgEvaluated = $False
              $IsMaxEvaluated = $False
              $IsTrendEvaluated = $False
            
              If (($oCounterInstance.Min -ne '-') -and ($oCounterInstance.Min -ne $null))
              {
                If (($oCounterInstance.Max -ne '-') -and ($oCounterInstance.Max -ne $null))
                {
                  $MinMaxDifference = $($oCounterInstance.Max) - $($oCounterInstance.Min)
                  $TwoHundredAndFiftyMegaBytes = 262144000
                  If (($MinMaxDifference -gt $FiveHundresMegaBytes) -and ($oCounterInstance.QuantizedTrend[$t] -gt $OneHundredMegaBytes))
                  {
                    $IsTrendThresholdBroken = $True
                    $IsTrendEvaluated = $True
                  }
                }
              }
              
              If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
              {
                  CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
              }
            }
          }
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Process(_Total)\Private Bytes" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(_Total)\Private Bytes" CHARTLABELS="instance">
    </CHART>
    <DESCRIPTION><![CDATA[This analysis determines if the system leaking memory over time. A process consuming large portions of memory is okay as long as the process returns the memory back to the system. Look for increasing trends in the chart. An increasing trend over a long period of time could indicate a memory leak. Private Bytes is the current size, in bytes, of memory that this process has allocated that cannot be shared with other processes. This analysis checks for a 10 MB per hour and 5 MB per hour increasing trends. Use this analysis in correlation with the Available Memory analysis.<BR>
<BR>
Use this analysis in correlation with the Available Memory analysis. If you suspect a memory leak condition, then install and use the Debug Diag tool. For more information on the Debug Diag Tool, see the references section.<BR>
<BR>
<B>References:</B><BR>

Debug Diagnostic Tool v1.1 http://www.microsoft.com/downloads/details.aspx?FamilyID=28bd5941-c458-46f1-b24d-f60151d875a3&displaylang=en]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Handle Count" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(_Total)\Handle Count" ID="{ff63f07d-dec2-4abc-b99a-d1841d340695}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(_Total)\Handle Count" COLLECTIONVARNAME="ProcessHandleCountTotal" EXPRESSIONPATH="\Process(_Total)\Handle Count" DATATYPE="integer" />
    <CHART CHARTTITLE="\Process(_Total)\Handle Count" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(_Total)\Handle Count" CHARTLABELS="instance" />
    <THRESHOLD NAME="Possible Handle Leak: More than 250 handles between overall Min and overall Max and an increasing trend of more than 100 handles per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
          For ($i=0;$i -lt $ProcessHandleCountTotal.Count;$i++)
          {
            $oCounterInstance = $ProcessHandleCountTotal[$i]
            For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
            {
              $IsMinThresholdBroken = $False
              $IsAvgThresholdBroken = $False
              $IsMaxThresholdBroken = $False
              $IsTrendThresholdBroken = $False
              $IsMinEvaluated = $False
              $IsAvgEvaluated = $False
              $IsMaxEvaluated = $False
              $IsTrendEvaluated = $False
            
              If (($oCounterInstance.Min -ne '-') -and ($oCounterInstance.Min -ne $null))
              {
                If (($oCounterInstance.Max -ne '-') -and ($oCounterInstance.Max -ne $null))
                {
                  $MinMaxDifference = $($oCounterInstance.Max) - $($oCounterInstance.Min)                  
                  If (($MinMaxDifference -gt 250) -and ($oCounterInstance.QuantizedTrend[$t] -gt 100))
                  {
                    $IsTrendThresholdBroken = $True
                    $IsTrendEvaluated = $True
                  }
                }
              }
              
              If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
              {
                  CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
              }
            }
          }
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Possible Handle Leak: More than 500 handles between overall Min and overall Max and an increasing trend of more than 500 handles per hour" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
          For ($i=0;$i -lt $ProcessHandleCountTotal.Count;$i++)
          {
            $oCounterInstance = $ProcessHandleCountTotal[$i]
            For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
            {
              $IsMinThresholdBroken = $False
              $IsAvgThresholdBroken = $False
              $IsMaxThresholdBroken = $False
              $IsTrendThresholdBroken = $False
              $IsMinEvaluated = $False
              $IsAvgEvaluated = $False
              $IsMaxEvaluated = $False
              $IsTrendEvaluated = $False
            
              If (($oCounterInstance.Min -ne '-') -and ($oCounterInstance.Min -ne $null))
              {
                If (($oCounterInstance.Max -ne '-') -and ($oCounterInstance.Max -ne $null))
                {
                  $MinMaxDifference = $($oCounterInstance.Max) - $($oCounterInstance.Min)
                  $TwoHundredAndFiftyMegaBytes = 262144000
                  If (($MinMaxDifference -gt 500) -and ($oCounterInstance.QuantizedTrend[$t] -gt 500))
                  {
                    $IsTrendThresholdBroken = $True
                    $IsTrendEvaluated = $True
                  }
                }
              }
              
              If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
              {
                  CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
              }
            }
          }
        ]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis checks overall system to determine how many handles the system has open to determine if there is a handle leak. Handle leaks can be attributed to memory leak. If this analysis throws alerts, then you need to manually open the performance monitor log and look at the instances <B>\Process(_Total)\Handle Count</B> to determine which process is leaking handles. Note: The normal System Overview analysis checks all of the processes.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Thread Count" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(_Total)\Thread Count" ID="{cc52e99a-9c8a-4b5d-91c7-11dcb2ac9f77}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(_Total)\Thread Count" COLLECTIONVARNAME="ProcessThreadCountTotal" EXPRESSIONPATH="\Process(_Total)\Thread Count" DATATYPE="integer" />
    <THRESHOLD NAME="Possible Thread Leak: More than 250 threads between overall Min and overall Max and an increasing trend of more than 100 threads per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
          For ($i=0;$i -lt $ProcessThreadCountTotal.Count;$i++)
          {
            $oCounterInstance = $ProcessThreadCountTotal[$i]
            For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
            {
              $IsMinThresholdBroken = $False
              $IsAvgThresholdBroken = $False
              $IsMaxThresholdBroken = $False
              $IsTrendThresholdBroken = $False
              $IsMinEvaluated = $False
              $IsAvgEvaluated = $False
              $IsMaxEvaluated = $False
              $IsTrendEvaluated = $False
            
              If (($oCounterInstance.Min -ne '-') -and ($oCounterInstance.Min -ne $null))
              {
                If (($oCounterInstance.Max -ne '-') -and ($oCounterInstance.Max -ne $null))
                {
                  $MinMaxDifference = $($oCounterInstance.Max) - $($oCounterInstance.Min)                  
                  If (($MinMaxDifference -gt 250) -and ($oCounterInstance.QuantizedTrend[$t] -gt 100))
                  {
                    $IsTrendThresholdBroken = $True
                    $IsTrendEvaluated = $True
                  }
                }
              }
              
              If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
              {
                  CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
              }
            }
          }
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Possible Thread Leak: More than 500 threads between overall Min and overall Max and an increasing trend of more than 500 threads per hour" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
          For ($i=0;$i -lt $ProcessThreadCountTotal.Count;$i++)
          {
            $oCounterInstance = $ProcessThreadCountTotal[$i]
            For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
            {
              $IsMinThresholdBroken = $False
              $IsAvgThresholdBroken = $False
              $IsMaxThresholdBroken = $False
              $IsTrendThresholdBroken = $False
              $IsMinEvaluated = $False
              $IsAvgEvaluated = $False
              $IsMaxEvaluated = $False
              $IsTrendEvaluated = $False
            
              If (($oCounterInstance.Min -ne '-') -and ($oCounterInstance.Min -ne $null))
              {
                If (($oCounterInstance.Max -ne '-') -and ($oCounterInstance.Max -ne $null))
                {
                  $MinMaxDifference = $($oCounterInstance.Max) - $($oCounterInstance.Min)
                  $TwoHundredAndFiftyMegaBytes = 262144000
                  If (($MinMaxDifference -gt 500) -and ($oCounterInstance.QuantizedTrend[$t] -gt 500))
                  {
                    $IsTrendThresholdBroken = $True
                    $IsTrendEvaluated = $True
                  }
                }
              }
              
              If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
              {
                  CreateAlert -TimeSliceIndex $t -CounterInstanceObject $oCounterInstance -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
              }
            }
          }
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Process(_Total)\Thread Count" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(_Total)\Thread Count" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[The number of threads currently active in this process. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Every running process has at least one thread.<BR>
<BR>
This analysis checks all of the processes to determine if a process has more than 500 threads and if it is on an increasing trend of 50 threads per hour. A process with a large number of threads and/or an aggressive upward trend could indicate a thread leak which typically results in either a memory leak or high context switching. High context switching will result in high privileged mode CPU. ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk % Free Space" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\% Free Space" ID="{6e4c9856-14cf-48b2-b519-e120b8a21d45}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\% Free Space" COLLECTIONVARNAME="LogicalDiskPercentFreeSpace" EXPRESSIONPATH="\LogicalDisk(*)\% Free Space" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Less than 10% Free Disk Space" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $LogicalDiskPercentFreeSpace -Operator 'lt' -Threshold 10
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 5% Free Disk Space" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $LogicalDiskPercentFreeSpace -Operator 'lt' -Threshold 5
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\% Free Space" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\% Free Space" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskPercentFreeSpace -MinThreshold 5 -MaxThreshold 10 -IsOperatorGreaterThan $False -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskPercentFreeSpace -MinThreshold 0 -MaxThreshold 5 -IsOperatorGreaterThan $False -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[% Free Space is the percentage of total usable space on the selected logical disk drive that was free. Low to no free disk space can cause severe disk performance problems.This analysis checks for less than 10% free disk space (Warning alert) and less than 5% free disk space (Critical alert).]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % Interrupt Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% Interrupt Time" ID="{a2cb1d88-1b9d-4a55-bfb5-92337f23d426}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% Interrupt Time" COLLECTIONVARNAME="ProcessorPercentInterruptTimeALL" EXPRESSIONPATH="\Processor(*)\% Interrupt Time" DATATYPE="integer" />
    <THRESHOLD NAME="More than 30% Interrupt Time" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $ProcessorPercentInterruptTimeALL -Operator 'gt' -Threshold 30
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 50% Interrupt Time" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $ProcessorPercentInterruptTimeALL -Operator 'gt' -Threshold 50
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Processor(*)\% Interrupt Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\% Interrupt Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $ProcessorPercentInterruptTimeALL -MinThreshold 30 -MaxThreshold 50 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $ProcessorPercentInterruptTimeALL -MinThreshold 50 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[% Interrupt Time is the time the processor spends receiving and servicing hardware interrupts during sample intervals. This value is an indirect indicator of the activity of devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication lines, network interface cards and other peripheral devices. These devices normally interrupt the processor when they have completed a task or require attention. Normal thread execution is suspended during interrupts. Most system clocks interrupt the processor every 10 milliseconds, creating a background of interrupt activity. A dramatic increase in this counter indicates potential hardware problems.<BR>
<BR>
This analysis checks for % Interrupt Time greater than 30%. If this occurs, then consider updating devices drivers for hardware that correlates to this alert.<BR>
<BR>
<B>References:</B><BR>
Measuring .NET Application Performance<BR>
<A HREF="http://msdn2.microsoft.com/en-us/library/ms998579.aspx">http://msdn2.microsoft.com/en-us/library/ms998579.aspx</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Read Latency Analysis" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Read" ID="{8839eef1-a97f-443d-b8a7-89079d0d6ff1}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Avg. Disk sec/Read" COLLECTIONVARNAME="PhysicalDiskAvgDisksecReadALL" EXPRESSIONPATH="\PhysicalDisk(*)\Avg. Disk sec/Read" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 15ms physical disk READ response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.015
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25ms physical disk READ response times" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.025
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Avg. Disk sec/Read" ISTHRESHOLDSADDED="True" DATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Read" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecReadALL -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecReadALL -MinThreshold 0.025 -MaxThreshold 0.029999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Read is the average time, in seconds, of a read of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.015 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.025 (25 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Write Latency Analysis" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Write" ID="{d8115038-5c2b-4495-b418-e36510296b43}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Avg. Disk sec/Write" COLLECTIONVARNAME="PhysicalDiskAvgDisksecWriteALL" EXPRESSIONPATH="\PhysicalDisk(*)\Avg. Disk sec/Write" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 15ms physical disk WRITE response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.015
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25ms physical disk WRITE response times" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.025
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Avg. Disk sec/Write" ISTHRESHOLDSADDED="True" DATASOURCE="\PhysicalDisk(*)\Avg. Disk sec/Write" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecWriteALL -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PhysicalDiskAvgDisksecWriteALL -MinThreshold 0.025 -MaxThreshold 0.029999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.015 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.025 (25 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Read Latency Analysis" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Read" ID="{dfb21d00-cf83-49e7-bf63-3d82db3d63c3}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Read" COLLECTIONVARNAME="LogicalDiskAvgDisksecReadALL" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Read" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 15 ms logical disk READ response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="52" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.015
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25 ms logical disk READ response times" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -Operator 'gt' -Threshold 0.025
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Read" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Read" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecReadALL -MinThreshold 0.025 -MaxThreshold 0.029999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Read is the average time, in seconds, of a read of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are less than <B>.015 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.025 (25 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Write Latency Analysis" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Write" ID="{28eaa0b2-0bc2-41f8-8c27-9045b597d001}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk sec/Write" COLLECTIONVARNAME="LogicalDiskAvgDisksecWriteALL" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk sec/Write" DATATYPE="round3">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Greater than 15ms logical disk WRITE response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.015
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Greater than 25ms logical disk WRITE response times" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.025
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk sec/Write" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk sec/Write" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -MinThreshold 0.015 -MaxThreshold 0.025 -UseMaxValue $False        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -MinThreshold 0.025 -MaxThreshold 0.029999 -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="Greater than 600 ms - Slower than a 3.5 inch floppy drive" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <CODE><![CDATA[#// Use PowerShell code to create alerts when the conditions for this threshold are met.
#// Optionally use the variables listed above in the Variables list box.
#// If the condition for this threshold is a static value, then use the StaticThreshold() function.
#// Otherwise, you will need to manually loop through the counter instance collection object.
#// The counter instance collection object has a unique name for each counter data source in this analysis.
#// See the variables in the Variables list box above for more information on the counter instance collection object.

#// Here is a ready to use example on how to use the StaticThreshold() function to define a threshold:
StaticThreshold -CollectionOfCounterInstances $LogicalDiskAvgDisksecWriteALL -Operator 'gt' -Threshold 0.6
#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk sec/Write is the average time, in seconds, of a write of data to the disk. This analysis determines if any of the physical disks are responding slowly.<BR>
<BR>
If the response times are greater than <B>.015 (15 milliseconds)</B>, then the disk subsystem is keeping up with demand, but does not have much overhead left.<BR>
<BR>
If the response times are greater than <B>.025 (25 milliseconds)</B>, then noticeable slow downs and performance issues affecting users may be occurring.<BR>
<BR>
<B>Reference:</B><BR>
Ruling Out Disk-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk % Idle Time" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\% Idle Time" ID="{91e5c328-0ca6-4b1f-a4f5-7f32d9cd357a}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\% Idle Time" COLLECTIONVARNAME="CollectionOfLogicalDiskPercentIdleTimeALL" EXPRESSIONPATH="\LogicalDisk(*)\% Idle Time" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Less than 10% Idle Time - the disk queue has at least 1 outstanding I/O 90% of the time" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskPercentIdleTimeALL -Operator 'lt' -Threshold 10]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\LogicalDisk(*)\% Idle Time" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\% Idle Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskPercentIdleTimeALL -MinThreshold 0 -MaxThreshold 10 -UseMaxValue $False -IsOperatorGreaterThan $False]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[% Idle Time reports the percentage of time during the sample interval that the disk was idle.<BR>
<BR>
This analysis checks for a % Idle Time of less than 10. Zero (0) indicates that the disk contstanly has at least 1 outstanding I/O in the queue.
<BR><BR>
<B>Reference:</B>
<UL>
<LI><A HREF="http://technet.microsoft.com/en-us/library/5bcdd349-dcc6-43eb-9dc3-54175f7061ad.aspx">Ruling Out Disk-Bound Problems</A></LI>
</UL
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Free System Page Table Entries" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Free System Page Table Entries" ID="{0b445fb5-2530-43cb-a7be-79cc43f212bc}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Free System Page Table Entries" COLLECTIONVARNAME="MemoryFreeSystemPageTableEntries" EXPRESSIONPATH="\Memory\Free System Page Table Entries" DATATYPE="Integer" />
    <THRESHOLD NAME="Less than 20,000 Free Page Table Entries (PTE) - The system is low on free PTEs" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $MemoryFreeSystemPageTableEntries -Operator 'lt' -Threshold 20000
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 8,000 Free Page Table Entries - The system is critically low on free PTEs" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $MemoryFreeSystemPageTableEntries -Operator 'lt' -Threshold 8000
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\Free System Page Table Entries" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Free System Page Table Entries" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $MemoryFreeSystemPageTableEntries -MinThreshold 8000 -MaxThreshold 20000 -IsOperatorGreaterThan $False -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $MemoryFreeSystemPageTableEntries -MinThreshold 0 -MaxThreshold 8000 -IsOperatorGreaterThan $False -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Free System Page Table Entries is the number of page table entries not currently in used by the system. This analysis determines if the system is running out of free system page table entries (PTEs) by checking if there is less than 20,000 free PTE's as a Warning and critical if there is less than 8,000 free PTEs. Lack of enough PTEs can result in system wide hangs. Also note that the /3GB switch will lower the amount of free PTEs significantly. <BR>
<BR>
The Performance Monitor Memory\Free System Page Table Entries counter is inaccurate on installations of Windows Server 2003 without Service Pack 1. For more information about this counter, see Microsoft Knowledge Base article 894067. The Performance tool does not accurately show the available Free System Page Table entries in Windows Server 2003 <a href="http://go.microsoft.com/fwlink/?linkid=3052&kbid=894067">http://go.microsoft.com/fwlink/?linkid=3052&amp;kbid=894067</a><BR>
<BR>
<B>Fix for Win2003 SP1 systems with /3GB and low on PTE's:</B> If the system is low on PTE's, running Windows 2003, and using /3GB switch, then consider using the /USERVA switch to give back some of the memory to the kernel. Note, this only works for Free System PTE issues.<BR>
<BR>
For more information on the USERVA switch, go to:
<A HREF="http://support.microsoft.com/kb/316739">How to use the /userva switch with the /3GB switch to tune the User-mode space to a value between 2 GB and 3 GB</A><BR>
<BR>
<B>Reference:</B><BR>
<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">Ruling Out Memory-Bound Problems</A><BR>
<BR>
<A HREF="http://support.microsoft.com/kb/894067">Microsoft Knowledge Base article 894067 The Performance tool does not accurately show the available Free System Page Table entries in Windows Server 2003</A><BR>
<BR>
<A HREF="http://support.microsoft.com/kb/316739">How to use the /userva switch with the /3GB switch to tune the User-mode space to a value between 2 GB and 3 GB</A><BR>
<BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pool Non-Paged Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pool Nonpaged Bytes" ID="{8eb3c4cb-b877-4878-9882-5654fea10320}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pool Nonpaged Bytes" COLLECTIONVARNAME="MemoryPoolNonpagedBytes" EXPRESSIONPATH="\Memory\Pool Nonpaged Bytes" DATATYPE="Integer" />
    <THRESHOLD NAME="More than 60% of Pool Non-Paged Kernel Memory Used" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
        $iTotalMemory = $([Math]::Round($TotalMemory,0))
        If ($($SixtyFourBit) -eq $False)
        {
            If ($($ThreeGBSwitch) -eq $True)
	        {
		        $iMemPoolMax = 128
	        }	
            Else
	        {
		        If ($($iTotalMemory) -eq 1)
		        {
			        $iMemPoolMax = 208
		        }
		        Else
		        {
			        $iMemPoolMax = 256
		        }
	        }
        }	
        Else
        {
	        switch ($($iTotalMemory))
	        {
		        1 {$iMemPoolMax = 872}		
		        2 {$iMemPoolMax = 872}
		        3 {$iMemPoolMax = 872}
		        4 {$iMemPoolMax = 1420}
		        5 {$iMemPoolMax = 1420}
		        6 {$iMemPoolMax = 1420}
		        7 {$iMemPoolMax = 1420}
		        8 {$iMemPoolMax = 3090}
		        9 {$iMemPoolMax = 3090}
		        10 {$iMemPoolMax = 3090}
		        11 {$iMemPoolMax = 3090}
		        12 {$iMemPoolMax = 4720}
		        13 {$iMemPoolMax = 4720}
		        14 {$iMemPoolMax = 4720}
		        15 {$iMemPoolMax = 4720}
		        16 {$iMemPoolMax = 6360}
		        17 {$iMemPoolMax = 6360}
		        18 {$iMemPoolMax = 6360}
		        19 {$iMemPoolMax = 6360}
		        20 {$iMemPoolMax = 6360}
		        21 {$iMemPoolMax = 6360}
		        22 {$iMemPoolMax = 6360}
		        23 {$iMemPoolMax = 6360}
		        24 {$iMemPoolMax = 9640}
		        25 {$iMemPoolMax = 9640}
		        26 {$iMemPoolMax = 9640}
		        27 {$iMemPoolMax = 9640}
		        28 {$iMemPoolMax = 9640}
		        29 {$iMemPoolMax = 9640}
		        30 {$iMemPoolMax = 9640}
		        31 {$iMemPoolMax = 9640}
		        32 {$iMemPoolMax = 13220}
		        default {$iMemPoolMax = 13220}
	        }	
        }
        $MemoryPoolMaxInBytes = $iMemPoolMax * 1024 * 1024
        $SixtyPercentOfMemoryPoolMaximum = $MemoryPoolMaxInBytes * 0.60
        StaticThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -Operator 'gt' -Threshold $SixtyPercentOfMemoryPoolMaximum
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% of Pool Non-Paged Kernel Memory Used" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[
        $iTotalMemory = $([Math]::Round($TotalMemory,0))
        If ($($SixtyFourBit) -eq $False)
        {
            If ($($ThreeGBSwitch) -eq $True)
	        {
		        $iMemPoolMax = 128
	        }	
            Else
	        {
		        If ($($iTotalMemory) -eq 1)
		        {
			        $iMemPoolMax = 208
		        }
		        Else
		        {
			        $iMemPoolMax = 256
		        }
	        }
        }	
        Else
        {
	        switch ($($iTotalMemory))
	        {
		        1 {$iMemPoolMax = 872}		
		        2 {$iMemPoolMax = 872}
		        3 {$iMemPoolMax = 872}
		        4 {$iMemPoolMax = 1420}
		        5 {$iMemPoolMax = 1420}
		        6 {$iMemPoolMax = 1420}
		        7 {$iMemPoolMax = 1420}
		        8 {$iMemPoolMax = 3090}
		        9 {$iMemPoolMax = 3090}
		        10 {$iMemPoolMax = 3090}
		        11 {$iMemPoolMax = 3090}
		        12 {$iMemPoolMax = 4720}
		        13 {$iMemPoolMax = 4720}
		        14 {$iMemPoolMax = 4720}
		        15 {$iMemPoolMax = 4720}
		        16 {$iMemPoolMax = 6360}
		        17 {$iMemPoolMax = 6360}
		        18 {$iMemPoolMax = 6360}
		        19 {$iMemPoolMax = 6360}
		        20 {$iMemPoolMax = 6360}
		        21 {$iMemPoolMax = 6360}
		        22 {$iMemPoolMax = 6360}
		        23 {$iMemPoolMax = 6360}
		        24 {$iMemPoolMax = 9640}
		        25 {$iMemPoolMax = 9640}
		        26 {$iMemPoolMax = 9640}
		        27 {$iMemPoolMax = 9640}
		        28 {$iMemPoolMax = 9640}
		        29 {$iMemPoolMax = 9640}
		        30 {$iMemPoolMax = 9640}
		        31 {$iMemPoolMax = 9640}
		        32 {$iMemPoolMax = 13220}
		        default {$iMemPoolMax = 13220}
	        }	
        }
        $MemoryPoolMaxInBytes = $iMemPoolMax * 1024 * 1024
        $EightyPercentOfMemoryPoolMaximum = $MemoryPoolMaxInBytes * 0.80
        StaticThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -Operator 'gt' -Threshold $EightyPercentOfMemoryPoolMaximum
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\Pool Nonpaged Bytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Pool Nonpaged Bytes" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
        $iTotalMemory = $([Math]::Round($TotalMemory,0))
        If ($($SixtyFourBit) -eq $False)
        {
            If ($($ThreeGBSwitch) -eq $True)
	        {
		        $iMemPoolMax = 128
	        }	
            Else
	        {
		        If ($($iTotalMemory) -eq 1)
		        {
			        $iMemPoolMax = 208
		        }
		        Else
		        {
			        $iMemPoolMax = 256
		        }
	        }
        }	
        Else
        {
	        switch ($($iTotalMemory))
	        {
		        1 {$iMemPoolMax = 872}		
		        2 {$iMemPoolMax = 872}
		        3 {$iMemPoolMax = 262}
		        4 {$iMemPoolMax = 1420}
		        5 {$iMemPoolMax = 1420}
		        6 {$iMemPoolMax = 1420}
		        7 {$iMemPoolMax = 1420}
		        8 {$iMemPoolMax = 3090}
		        9 {$iMemPoolMax = 3090}
		        10 {$iMemPoolMax = 3090}
		        11 {$iMemPoolMax = 3090}
		        12 {$iMemPoolMax = 4720}
		        13 {$iMemPoolMax = 4720}
		        14 {$iMemPoolMax = 4720}
		        15 {$iMemPoolMax = 4720}
		        16 {$iMemPoolMax = 6360}
		        17 {$iMemPoolMax = 6360}
		        18 {$iMemPoolMax = 6360}
		        19 {$iMemPoolMax = 6360}
		        20 {$iMemPoolMax = 6360}
		        21 {$iMemPoolMax = 6360}
		        22 {$iMemPoolMax = 6360}
		        23 {$iMemPoolMax = 6360}
		        24 {$iMemPoolMax = 9640}
		        25 {$iMemPoolMax = 9640}
		        26 {$iMemPoolMax = 9640}
		        27 {$iMemPoolMax = 9640}
		        28 {$iMemPoolMax = 9640}
		        29 {$iMemPoolMax = 9640}
		        30 {$iMemPoolMax = 9640}
		        31 {$iMemPoolMax = 9640}
		        32 {$iMemPoolMax = 13220}
		        default {$iMemPoolMax = 13220}
	        }	
        }
        $MemoryPoolMaxInBytes = $iMemPoolMax * 1024 * 1024
        $SixtyPercentOfMemoryPoolMaximum = $MemoryPoolMaxInBytes * 0.60
        $EightyPercentOfMemoryPoolMaximum = ($MemoryPoolMaxInBytes * 0.80) - 0.001
        StaticChartThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -MinThreshold $SixtyPercentOfMemoryPoolMaximum -MaxThreshold $EightyPercentOfMemoryPoolMaximum -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
        $iTotalMemory = $([Math]::Round($TotalMemory,0))
        If ($($SixtyFourBit) -eq $False)
        {
            If ($($ThreeGBSwitch) -eq $True)
	        {
		        $iMemPoolMax = 128
	        }	
            Else
	        {
		        If ($($iTotalMemory) -eq 1)
		        {
			        $iMemPoolMax = 208
		        }
		        Else
		        {
			        $iMemPoolMax = 256
		        }
	        }
        }	
        Else
        {
	        switch ($($iTotalMemory))
	        {
		        1 {$iMemPoolMax = 872}		
		        2 {$iMemPoolMax = 872}
		        3 {$iMemPoolMax = 262}
		        4 {$iMemPoolMax = 1420}
		        5 {$iMemPoolMax = 1420}
		        6 {$iMemPoolMax = 1420}
		        7 {$iMemPoolMax = 1420}
		        8 {$iMemPoolMax = 3090}
		        9 {$iMemPoolMax = 3090}
		        10 {$iMemPoolMax = 3090}
		        11 {$iMemPoolMax = 3090}
		        12 {$iMemPoolMax = 4720}
		        13 {$iMemPoolMax = 4720}
		        14 {$iMemPoolMax = 4720}
		        15 {$iMemPoolMax = 4720}
		        16 {$iMemPoolMax = 6360}
		        17 {$iMemPoolMax = 6360}
		        18 {$iMemPoolMax = 6360}
		        19 {$iMemPoolMax = 6360}
		        20 {$iMemPoolMax = 6360}
		        21 {$iMemPoolMax = 6360}
		        22 {$iMemPoolMax = 6360}
		        23 {$iMemPoolMax = 6360}
		        24 {$iMemPoolMax = 9640}
		        25 {$iMemPoolMax = 9640}
		        26 {$iMemPoolMax = 9640}
		        27 {$iMemPoolMax = 9640}
		        28 {$iMemPoolMax = 9640}
		        29 {$iMemPoolMax = 9640}
		        30 {$iMemPoolMax = 9640}
		        31 {$iMemPoolMax = 9640}
		        32 {$iMemPoolMax = 13220}
		        default {$iMemPoolMax = 13220}
	        }	
        }
        $MemoryPoolMaxInBytes = $iMemPoolMax * 1024 * 1024
        $EightyPercentOfMemoryPoolMaximum = ($MemoryPoolMaxInBytes * 0.80)
        StaticChartThreshold -CollectionOfCounterInstances $MemoryPoolNonpagedBytes -MinThreshold $EightyPercentOfMemoryPoolMaximum -MaxThreshold $MemoryPoolMaxInBytes -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Pool Nonpaged Bytes is the size, in bytes, of the nonpaged pool, an area of system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated.<BR>
<BR>
This analysis checks to see if the system is becoming close to the maximum Pool Nonpaged memory size. It does this by estimating the pool sizes taking into consideration /3GB, physical memory size, and 32-bit/64-bit, then determining if the value is higher than 60% of the estimated pool size. If the system becomes close to the maximum size, then the system could experience system wide hangs. Checks both 32-bit and 64-bit memory pools. Warning: The /3GB switch option in the boot.ini file significantly reduces the size of this memory pool.<BR>
<BR>
If the system is low on Paged Pool or non-Paged pool memory, then it is recommended to open a support case with Microsoft to address this. Alternatively, you can use a free and public tool called Poolmon.exe to see what DLL's are using kernel memory (see the article below). Most kernel memory leaks can be tracked back to a usermode process. To identify which user mode process is responsible, reboot the system (so you start off with a clean system), start a performance monitor log intending to run for a week or more capturing the Memory and Process objects, then analyze the perfmon log looking for memory leaks and/or handle leaks in one or more of the processes. In any case, migrating to a 64-bit version of Windows should alleviate this issue.
<BR>
<BR>
<B>References</B><BR>
How to Use Memory Pool Monitor (Poolmon.exe) to Troubleshoot Kernel Mode Memory Leaks<BR>
<A HREF="http://support.microsoft.com/kb/177415">http://support.microsoft.com/kb/177415</A><BR>
<BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A><BR>
<BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pool Paged Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pool Paged Bytes" ID="{904560fe-0629-40ed-8514-cb9fbb8dd426}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pool Paged Bytes" COLLECTIONVARNAME="MemoryPoolPagedBytes" EXPRESSIONPATH="\Memory\Pool Paged Bytes" DATATYPE="Integer" />
    <THRESHOLD NAME="More than 60% of Pool Paged Kernel Memory Used" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
        $iTotalMemory = $([Math]::Round($TotalMemory,0))
        If ($($SixtyFourBit) -eq $False)
        {
	If ($($ThreeGBSwitch) -eq $True)
	{
	          switch ($($iTotalMemory))
	          {
		          1 {$iMemPoolMax = 160}		
		          2 {$iMemPoolMax = 256}
		          3 {$iMemPoolMax = 256}
		          4 {$iMemPoolMax = 252}
		          5 {$iMemPoolMax = 252}
		          6 {$iMemPoolMax = 234}
		          7 {$iMemPoolMax = 234}
		          8 {$iMemPoolMax = 220}
		          9 {$iMemPoolMax = 220}
		          10 {$iMemPoolMax = 220}
		          11 {$iMemPoolMax = 220}
		          12 {$iMemPoolMax = 192}
		          13 {$iMemPoolMax = 192}
		          14 {$iMemPoolMax = 192}
		          15 {$iMemPoolMax = 192}
		          16 {$iMemPoolMax = 166}
		          default {$iMemPoolMax = 166}
	          }
	}
	Else
	{
	          switch ($($iTotalMemory))
	          {
		          1 {$iMemPoolMax = 276}		
		          2 {$iMemPoolMax = 352}
		          3 {$iMemPoolMax = 352}
		          4 {$iMemPoolMax = 352}
		          5 {$iMemPoolMax = 352}
		          6 {$iMemPoolMax = 358}
		          7 {$iMemPoolMax = 358}
		          8 {$iMemPoolMax = 358}
		          9 {$iMemPoolMax = 358}
		          10 {$iMemPoolMax = 358}
		          11 {$iMemPoolMax = 358}
		          12 {$iMemPoolMax = 358}
		          13 {$iMemPoolMax = 358}
		          14 {$iMemPoolMax = 358}
		          15 {$iMemPoolMax = 358}
		          16 {$iMemPoolMax = 358}
		          default {$iMemPoolMax = 358}
	          }
	}
	#// Assuming HotAdd memory is enabled.
	$iMemPoolMax = $iMemPoolMax - 100
        }	
        Else
        {
	        switch ($($iTotalMemory))
	        {
		        1 {$iMemPoolMax = 3564}		
		        2 {$iMemPoolMax = 3564}
		        3 {$iMemPoolMax = 3564}
		        4 {$iMemPoolMax = 5837}
		        5 {$iMemPoolMax = 5837}
		        6 {$iMemPoolMax = 5837}
		        7 {$iMemPoolMax = 5837}
		        8 {$iMemPoolMax = 12657}
		        9 {$iMemPoolMax = 12657}
		        10 {$iMemPoolMax = 12657}
		        11 {$iMemPoolMax = 12657}
		        12 {$iMemPoolMax = 19364}
		        13 {$iMemPoolMax = 19364}
		        14 {$iMemPoolMax = 19364}
		        15 {$iMemPoolMax = 19364}
		        16 {$iMemPoolMax = 39496}
		        17 {$iMemPoolMax = 39496}
		        18 {$iMemPoolMax = 39496}
		        19 {$iMemPoolMax = 39496}
		        20 {$iMemPoolMax = 39496}
		        21 {$iMemPoolMax = 39496}
		        22 {$iMemPoolMax = 39496}
		        23 {$iMemPoolMax = 39496}
		        24 {$iMemPoolMax = 39496}
		        25 {$iMemPoolMax = 39496}
		        26 {$iMemPoolMax = 39496}
		        27 {$iMemPoolMax = 39496}
		        28 {$iMemPoolMax = 39496}
		        29 {$iMemPoolMax = 39496}
		        30 {$iMemPoolMax = 39496}
		        31 {$iMemPoolMax = 39496}
		        32 {$iMemPoolMax = 54180}
		        default {$iMemPoolMax = 54180}
	        }	
        }
        $MemoryPoolMaxInBytes = $iMemPoolMax * 1024 * 1024
        $SixtyPercentOfMemoryPoolMaximum = $MemoryPoolMaxInBytes * 0.60
        StaticThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -Operator 'gt' -Threshold $SixtyPercentOfMemoryPoolMaximum
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 80% of Pool Paged Kernel Memory Used" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <CODE><![CDATA[
        $iTotalMemory = $([Math]::Round($TotalMemory,0))
        If ($($SixtyFourBit) -eq $False)
        {
          If ($($ThreeGBSwitch) -eq $True)
	        {
	          switch ($($iTotalMemory))
	          {
		          1 {$iMemPoolMax = 160}		
		          2 {$iMemPoolMax = 256}
		          3 {$iMemPoolMax = 256}
		          4 {$iMemPoolMax = 252}
		          5 {$iMemPoolMax = 252}
		          6 {$iMemPoolMax = 234}
		          7 {$iMemPoolMax = 234}
		          8 {$iMemPoolMax = 220}
		          9 {$iMemPoolMax = 220}
		          10 {$iMemPoolMax = 220}
		          11 {$iMemPoolMax = 220}
		          12 {$iMemPoolMax = 192}
		          13 {$iMemPoolMax = 192}
		          14 {$iMemPoolMax = 192}
		          15 {$iMemPoolMax = 192}
		          16 {$iMemPoolMax = 166}
		          default {$iMemPoolMax = 166}
	          }
          }
          Else
          {
	          switch ($($iTotalMemory))
	          {
		          1 {$iMemPoolMax = 276}		
		          2 {$iMemPoolMax = 352}
		          3 {$iMemPoolMax = 352}
		          4 {$iMemPoolMax = 352}
		          5 {$iMemPoolMax = 352}
		          6 {$iMemPoolMax = 358}
		          7 {$iMemPoolMax = 358}
		          8 {$iMemPoolMax = 358}
		          9 {$iMemPoolMax = 358}
		          10 {$iMemPoolMax = 358}
		          11 {$iMemPoolMax = 358}
		          12 {$iMemPoolMax = 358}
		          13 {$iMemPoolMax = 358}
		          14 {$iMemPoolMax = 358}
		          15 {$iMemPoolMax = 358}
		          16 {$iMemPoolMax = 358}
		          default {$iMemPoolMax = 358}
	          }
          }
	#// Assuming HotAdd memory is enabled.
	$iMemPoolMax = $iMemPoolMax - 100
        }	
        Else
        {
	        switch ($($iTotalMemory))
	        {
		        1 {$iMemPoolMax = 3564}		
		        2 {$iMemPoolMax = 3564}
		        3 {$iMemPoolMax = 3564}
		        4 {$iMemPoolMax = 5837}
		        5 {$iMemPoolMax = 5837}
		        6 {$iMemPoolMax = 5837}
		        7 {$iMemPoolMax = 5837}
		        8 {$iMemPoolMax = 12657}
		        9 {$iMemPoolMax = 12657}
		        10 {$iMemPoolMax = 12657}
		        11 {$iMemPoolMax = 12657}
		        12 {$iMemPoolMax = 19364}
		        13 {$iMemPoolMax = 19364}
		        14 {$iMemPoolMax = 19364}
		        15 {$iMemPoolMax = 19364}
		        16 {$iMemPoolMax = 39496}
		        17 {$iMemPoolMax = 39496}
		        18 {$iMemPoolMax = 39496}
		        19 {$iMemPoolMax = 39496}
		        20 {$iMemPoolMax = 39496}
		        21 {$iMemPoolMax = 39496}
		        22 {$iMemPoolMax = 39496}
		        23 {$iMemPoolMax = 39496}
		        24 {$iMemPoolMax = 39496}
		        25 {$iMemPoolMax = 39496}
		        26 {$iMemPoolMax = 39496}
		        27 {$iMemPoolMax = 39496}
		        28 {$iMemPoolMax = 39496}
		        29 {$iMemPoolMax = 39496}
		        30 {$iMemPoolMax = 39496}
		        31 {$iMemPoolMax = 39496}
		        32 {$iMemPoolMax = 54180}
		        default {$iMemPoolMax = 54180}
	        }	
        }
        $MemoryPoolMaxInBytes = $iMemPoolMax * 1024 * 1024
        $EightyPercentOfMemoryPoolMaximum = $MemoryPoolMaxInBytes * 0.80
        StaticThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -Operator 'gt' -Threshold $EightyPercentOfMemoryPoolMaximum
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\Pool Paged Bytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Pool Paged Bytes" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
        $iTotalMemory = $([Math]::Round($TotalMemory,0))
        If ($($SixtyFourBit) -eq $False)
        {
          If ($($ThreeGBSwitch) -eq $True)
	        {
	          switch ($($iTotalMemory))
	          {
		          1 {$iMemPoolMax = 160}		
		          2 {$iMemPoolMax = 256}
		          3 {$iMemPoolMax = 256}
		          4 {$iMemPoolMax = 252}
		          5 {$iMemPoolMax = 252}
		          6 {$iMemPoolMax = 234}
		          7 {$iMemPoolMax = 234}
		          8 {$iMemPoolMax = 220}
		          9 {$iMemPoolMax = 220}
		          10 {$iMemPoolMax = 220}
		          11 {$iMemPoolMax = 220}
		          12 {$iMemPoolMax = 192}
		          13 {$iMemPoolMax = 192}
		          14 {$iMemPoolMax = 192}
		          15 {$iMemPoolMax = 192}
		          16 {$iMemPoolMax = 166}
		          default {$iMemPoolMax = 166}
	          }
          }
          Else
          {
	          switch ($($iTotalMemory))
	          {
		          1 {$iMemPoolMax = 276}		
		          2 {$iMemPoolMax = 352}
		          3 {$iMemPoolMax = 352}
		          4 {$iMemPoolMax = 352}
		          5 {$iMemPoolMax = 352}
		          6 {$iMemPoolMax = 358}
		          7 {$iMemPoolMax = 358}
		          8 {$iMemPoolMax = 358}
		          9 {$iMemPoolMax = 358}
		          10 {$iMemPoolMax = 358}
		          11 {$iMemPoolMax = 358}
		          12 {$iMemPoolMax = 358}
		          13 {$iMemPoolMax = 358}
		          14 {$iMemPoolMax = 358}
		          15 {$iMemPoolMax = 358}
		          16 {$iMemPoolMax = 358}
		          default {$iMemPoolMax = 358}
	          }
          }
	#// Assuming HotAdd memory is enabled.
	$iMemPoolMax = $iMemPoolMax - 100
        }	
        Else
        {
	        switch ($($iTotalMemory))
	        {
		        1 {$iMemPoolMax = 3564}		
		        2 {$iMemPoolMax = 3564}
		        3 {$iMemPoolMax = 3564}
		        4 {$iMemPoolMax = 5837}
		        5 {$iMemPoolMax = 5837}
		        6 {$iMemPoolMax = 5837}
		        7 {$iMemPoolMax = 5837}
		        8 {$iMemPoolMax = 12657}
		        9 {$iMemPoolMax = 12657}
		        10 {$iMemPoolMax = 12657}
		        11 {$iMemPoolMax = 12657}
		        12 {$iMemPoolMax = 19364}
		        13 {$iMemPoolMax = 19364}
		        14 {$iMemPoolMax = 19364}
		        15 {$iMemPoolMax = 19364}
		        16 {$iMemPoolMax = 39496}
		        17 {$iMemPoolMax = 39496}
		        18 {$iMemPoolMax = 39496}
		        19 {$iMemPoolMax = 39496}
		        20 {$iMemPoolMax = 39496}
		        21 {$iMemPoolMax = 39496}
		        22 {$iMemPoolMax = 39496}
		        23 {$iMemPoolMax = 39496}
		        24 {$iMemPoolMax = 39496}
		        25 {$iMemPoolMax = 39496}
		        26 {$iMemPoolMax = 39496}
		        27 {$iMemPoolMax = 39496}
		        28 {$iMemPoolMax = 39496}
		        29 {$iMemPoolMax = 39496}
		        30 {$iMemPoolMax = 39496}
		        31 {$iMemPoolMax = 39496}
		        32 {$iMemPoolMax = 54180}
		        default {$iMemPoolMax = 54180}
	        }	
        }
        $MemoryPoolMaxInBytes = $iMemPoolMax * 1024 * 1024
        $SixtyPercentOfMemoryPoolMaximum = $MemoryPoolMaxInBytes * 0.60
        $EightyPercentOfMemoryPoolMaximum = ($MemoryPoolMaxInBytes * 0.80) - 0.001
        StaticChartThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -MinThreshold $SixtyPercentOfMemoryPoolMaximum -MaxThreshold $EightyPercentOfMemoryPoolMaximum -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
        $iTotalMemory = $([Math]::Round($TotalMemory,0))
        If ($($SixtyFourBit) -eq $False)
        {
          If ($($ThreeGBSwitch) -eq $True)
	        {
	          switch ($($iTotalMemory))
	          {
		          1 {$iMemPoolMax = 160}		
		          2 {$iMemPoolMax = 256}
		          3 {$iMemPoolMax = 256}
		          4 {$iMemPoolMax = 252}
		          5 {$iMemPoolMax = 252}
		          6 {$iMemPoolMax = 234}
		          7 {$iMemPoolMax = 234}
		          8 {$iMemPoolMax = 220}
		          9 {$iMemPoolMax = 220}
		          10 {$iMemPoolMax = 220}
		          11 {$iMemPoolMax = 220}
		          12 {$iMemPoolMax = 192}
		          13 {$iMemPoolMax = 192}
		          14 {$iMemPoolMax = 192}
		          15 {$iMemPoolMax = 192}
		          16 {$iMemPoolMax = 166}
		          default {$iMemPoolMax = 166}
	          }
          }
          Else
          {
	          switch ($($iTotalMemory))
	          {
		          1 {$iMemPoolMax = 276}		
		          2 {$iMemPoolMax = 352}
		          3 {$iMemPoolMax = 352}
		          4 {$iMemPoolMax = 352}
		          5 {$iMemPoolMax = 352}
		          6 {$iMemPoolMax = 358}
		          7 {$iMemPoolMax = 358}
		          8 {$iMemPoolMax = 358}
		          9 {$iMemPoolMax = 358}
		          10 {$iMemPoolMax = 358}
		          11 {$iMemPoolMax = 358}
		          12 {$iMemPoolMax = 358}
		          13 {$iMemPoolMax = 358}
		          14 {$iMemPoolMax = 358}
		          15 {$iMemPoolMax = 358}
		          16 {$iMemPoolMax = 358}
		          default {$iMemPoolMax = 358}
	          }
          }
	#// Assuming HotAdd memory is enabled.
	$iMemPoolMax = $iMemPoolMax - 100
        }	
        Else
        {
	        switch ($($iTotalMemory))
	        {
		        1 {$iMemPoolMax = 3564}		
		        2 {$iMemPoolMax = 3564}
		        3 {$iMemPoolMax = 3564}
		        4 {$iMemPoolMax = 5837}
		        5 {$iMemPoolMax = 5837}
		        6 {$iMemPoolMax = 5837}
		        7 {$iMemPoolMax = 5837}
		        8 {$iMemPoolMax = 12657}
		        9 {$iMemPoolMax = 12657}
		        10 {$iMemPoolMax = 12657}
		        11 {$iMemPoolMax = 12657}
		        12 {$iMemPoolMax = 19364}
		        13 {$iMemPoolMax = 19364}
		        14 {$iMemPoolMax = 19364}
		        15 {$iMemPoolMax = 19364}
		        16 {$iMemPoolMax = 39496}
		        17 {$iMemPoolMax = 39496}
		        18 {$iMemPoolMax = 39496}
		        19 {$iMemPoolMax = 39496}
		        20 {$iMemPoolMax = 39496}
		        21 {$iMemPoolMax = 39496}
		        22 {$iMemPoolMax = 39496}
		        23 {$iMemPoolMax = 39496}
		        24 {$iMemPoolMax = 39496}
		        25 {$iMemPoolMax = 39496}
		        26 {$iMemPoolMax = 39496}
		        27 {$iMemPoolMax = 39496}
		        28 {$iMemPoolMax = 39496}
		        29 {$iMemPoolMax = 39496}
		        30 {$iMemPoolMax = 39496}
		        31 {$iMemPoolMax = 39496}
		        32 {$iMemPoolMax = 54180}
		        default {$iMemPoolMax = 54180}
	        }	
        }
        $MemoryPoolMaxInBytes = $iMemPoolMax * 1024 * 1024
        $EightyPercentOfMemoryPoolMaximum = ($MemoryPoolMaxInBytes * 0.80)
        StaticChartThreshold -CollectionOfCounterInstances $MemoryPoolPagedBytes -MinThreshold $EightyPercentOfMemoryPoolMaximum -MaxThreshold $MemoryPoolMaxInBytes -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[This analysis checks to see if the system is becoming close to the maximum Pool paged memory size. Pool Paged Bytes is the size, in bytes, of the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used.<BR>
<BR>
This analysis checks to see if the system is becoming close to the maximum Pool Paged memory size. It does this by estimating the pool sizes taking into consideration /3GB, physical memory size, and 32-bit/64-bit, then determining if the value is higher than 60% of the estimated pool size. If the system becomes close to the maximum size, then the system could experience system wide hangs. Checks both 32-bit and 64-bit memory pools. Warning: The /3GB switch option in the boot.ini file significantly reduces the size of this memory pool.<BR>
<BR>
If the system is low on Paged Pool or non-Paged pool memory, then it is recommended to open a support case with Microsoft to address this. Alternatively, you can use a free and public tool called Poolmon.exe to see what DLL's are using kernel memory (see the article below). Most kernel memory leaks can be tracked back to a usermode process. To identify which user mode process is responsible, reboot the system (so you start off with a clean system), start a performance monitor log intending to run for a week or more capturing the Memory and Process objects, then analyze the perfmon log looking for memory leaks and/or handle leaks in one or more of the processes. In any case, migrating to a 64-bit version of Windows should alleviate this issue.<BR>
<BR>
<B>Reference:</B><BR>
How to Use Memory Pool Monitor (Poolmon.exe) to Troubleshoot Kernel Mode Memory Leaks<BR>
<A HREF="http://support.microsoft.com/kb/177415">http://support.microsoft.com/kb/177415</A><BR>
<BR>
Ruling Out Memory-Bound Problems<BR>
<A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx</A><BR>
<BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages/sec" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pages/sec" ID="{0956e8c1-c91e-4765-9e4e-541f8079f502}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pages/sec" COLLECTIONVARNAME="CollectionOfMemoryPagessec" EXPRESSIONPATH="\Memory\Pages/sec" DATATYPE="Integer" />
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Available MBytes" EXPRESSIONPATH="\Memory\Available MBytes" COLLECTIONVARNAME="CollectionOfAvailableMBytes" DATATYPE="Integer" />
    <THRESHOLD NAME="More than 1000 pages/sec with less than 100MBs of Available MBytes" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        For ($a=0;$a -lt $CollectionOfAvailableMBytes.Count;$a++)
        {
          For ($b=0;$b -lt $CollectionOfMemoryPagessec.Count;$b++)
          {
            If ($CollectionOfAvailableMBytes[$a].CounterComputer -eq $CollectionOfMemoryPagessec[$b].CounterComputer)
            {
              $i = $a
            }
          }
          For ($t=0;$t -lt $alQuantizedTime.Count;$t++)
          {
            $IsMinThresholdBroken = $False
            $IsAvgThresholdBroken = $False
            $IsMaxThresholdBroken = $False
            $IsTrendThresholdBroken = $False
            $IsMinEvaluated = $False
            $IsAvgEvaluated = $False
            $IsMaxEvaluated = $False
            $IsTrendEvaluated = $False
            If (($CollectionOfAvailableMBytes[$a].QuantizedMin[$t] -ne '-') -and ($CollectionOfAvailableMBytes[$a].QuantizedMin[$t] -ne $null) -and ($CollectionOfMemoryPagessec[$i].QuantizedAvg[$t] -ne $null) -and ($CollectionOfMemoryPagessec[$i].QuantizedAvg[$t] -ne $null))
            {
              If (($CollectionOfAvailableMBytes[$a].QuantizedMin[$t] -lt 100) -and ($CollectionOfMemoryPagessec[$i].QuantizedAvg[$t] -gt 1000))
              {
                $IsAvgThresholdBroken = $True
                $IsAvgEvaluated = $True
              }
            }
            If (($IsMinThresholdBroken -eq $True) -or ($IsAvgThresholdBroken -eq $True) -or ($IsMaxThresholdBroken -eq $True) -or ($IsTrendThresholdBroken -eq $True))
            {
                CreateAlert -TimeSliceIndex $t -CounterInstanceObject $CollectionOfMemoryPagessec[$i] -IsMinThresholdBroken $IsMinThresholdBroken -IsAvgThresholdBroken $IsAvgThresholdBroken -IsMaxThresholdBroken $IsMaxThresholdBroken -IsTrendThresholdBroken $IsTrendThresholdBroken -IsMinEvaluated $IsMinEvaulated -IsAvgEvaluated $IsAvgEvaulated -IsMaxEvaluated $IsMaxEvaulated -IsTrendEvaluated $IsTrendEvaulated
            }
          }
        }
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\Pages/sec" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Pages/sec" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemoryPagessec -MinThreshold 1000 -MaxThreshold 1999.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[This analysis checks to see if the Pages/sec is high while the system is in a low memory condition. If it is sustained at a high amount, then the system is <B>might</B> be running out of memory by trying to page the memory to the disk. Keep in mind that all hard page faults are counted in the pages/sec counter such as hard page faults caused by memory mapped files instead of page file hits. 
      According to Wikipedia, memory-mapped files are a segment of virtual memory which has been assigned a direct byte-for-byte correlation with some portion of a file or file-like resource. This resource is typically a file that is physically present on-disk, but can also be a device, shared memory object, or other resource that the operating system can reference through a file descriptor.
In other words, applications like Microsoft Word and Microsoft PowerPoint will not load entire documents into RAM. Instead, they memory map the file, so that when you navigate through the document, it loads portions of the document as needed. The act of loading portions of the document from disk to RAM as a memory mapped file causes a hard page fault which is counted in the pages/sec counter. See the article <A HREF="http://blogs.technet.com/clinth/archive/2009/07/16/the-case-of-the-phantom-hard-page-faults.aspx">The Case of the Phantom Hard Page Faults</A>. To determine if the hard page faults are actually hitting the page file, use Process Monitor with Advanced Ouput enabled to see how often the page file(s) are hit.<BR> 
Pages/sec is the rate at which pages are read from or written to disk to resolve hard page faults. It is the sum of Memory\Pages Input/sec and Memory\Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory\Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files.<BR>
<BR>
This counter should always be below 1000, therefore this analysis checks for values above 1000. Use this analysis in correlation with Available Memory Analysis and Memory Leak Analysis. If all are throwing alerts at the same time, then this may indicate the system is running out of memory and the suspected processes involved and follow analysis steps mentioned in the Memory Leak analysis.<BR>
<BR>
<B>Reference</B><BR>
<UL>
<LI><A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">Ruling Out Memory-Bound Problems<BR></A></LI>
<LI><A HREF="http://blogs.technet.com/clinth/archive/2009/07/16/the-case-of-the-phantom-hard-page-faults.aspx">The Case of the Phantom Hard Page Faults<BR></A></LI>
</UL>
<BR>
      ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Process Working Set" ENABLED="True" CATEGORY="Process" PRIMARYDATASOURCE="\Process(_Total)\Working Set" ID="{e32af772-a24e-4a01-abe8-cd4f9d98253a}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Process(_Total)\Working Set" COLLECTIONVARNAME="ProcessWorkingSetTotal" EXPRESSIONPATH="\Process(_Total)\Working Set" DATATYPE="integer" />
    <THRESHOLD NAME="The working set of all processes combined is increasing at a rate greater than 100MBs per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        $OneHundredMegaBytes = 104857600
        StaticThreshold -CollectionOfCounterInstances $ProcessWorkingSetTotal -Operator 'gt' -Threshold $OneHundredMegaBytes -IsTrendOnly $True
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Process(_Total)\Working Set" ISTHRESHOLDSADDED="False" DATASOURCE="\Process(_Total)\Working Set" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Working Set is the current size, in bytes, of the Working Set of a process. The Working Set is the set of memory pages touched recently by the threads in the process. It is the amount of RAM consumbed by each process. If free memory in the computer is above a threshold, pages are left in the Working Set of a process even if they are not in use.  When free memory falls below a threshold, pages are trimmed from Working Sets. If they are needed they will then be soft-faulted back into the Working Set before leaving main memory.<BR>
This analysis checks for an increasing trend of 100 MB or more per hour in all of the processes combined. This could be an aggressive working set (RAM usage) leak, but keep in mind that this is only tracking the amount of RAM used by all of the processes and does not include committed memory that has been paged out. This is why Private Bytes is a better counter to use for general memory leaks. With that said, Working Set is a helpful counter to have. Use this analysis in correlation with Available Memory Analysis.<BR>
<BR>
<B>Reference:</B><BR>
<UL>
<LI><A HREF="http://technet.microsoft.com/en-us/library/7a44b064-8872-4edf-aac7-36b2a17f662a.aspx">Ruling Out Memory-Bound Problems<BR></A></LI>
<LI><A HREF="http://blogs.technet.com/clinth/archive/2009/07/07/the-case-of-the-out-of-memory-biztalk-server.aspx">The Case of the Out of Memory BizTalk Server</A></LI>
</UL>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory System Cache Resident Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\System Cache Resident Bytes" ID="{11674a2f-1d1f-42ac-910b-2e6aa50cee79}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\System Cache Resident Bytes" COLLECTIONVARNAME="CollectionOfMemorySystemCacheResidentBytes" EXPRESSIONPATH="\Memory\System Cache Resident Bytes" DATATYPE="integer" />
    <THRESHOLD NAME="System Cache Resident Bytes is consumsing more than 50 percent of RAM" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <CODE><![CDATA[
        $FiftyPercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024) * 0.50
        StaticThreshold -CollectionOfCounterInstances $CollectionOfMemorySystemCacheResidentBytes -Operator 'gt' -Threshold $FiftyPercentOfPhysicalMemory
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\System Cache Resident Bytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\System Cache Resident Bytes" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          $FiftyPercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024) * 0.50
          $NinetyPercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024) * 0.90
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemorySystemCacheResidentBytes -MinThreshold $FiftyPercentOfPhysicalMemory -MaxThreshold $NinetyPercentOfPhysicalMemory -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          $NinetyPercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024) * 0.90
          $OneHundredPercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024)
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemorySystemCacheResidentBytes -MinThreshold $NinetyPercentOfPhysicalMemory -MaxThreshold $OneHundredPercentOfPhysicalMemory -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[System Cache Resident Bytes is the size, in bytes, of the pageable operating system code in the file system cache. This value includes only current physical pages and does not include any virtual memory pages not currently resident. It does equal the System Cache value shown in Task Manager. As a result, this value may be smaller than the actual amount of virtual memory in use by the file system cache. This value is a component of Memory\\System Code Resident Bytes which represents all pageable operating system code that is currently in physical memory. This counter displays the last observed value only; it is not an average.<BR>
<BR>
This analysis checks if System Cache Resident Bytes is consuming more than 50 percent of RAM. Under load, a server might use the System Cache in order to cache I/O activity such as disk. Use in correlation with Process IO Data Operations/sec and Process IO Other Operations/sec Analyses.<BR>
<BR>
<B>References</B><BR>
File Cache Performance and Tuning http://technet.microsoft.com/en-us/library/bb742613.aspx
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Cache Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Cache Bytes" ID="{bf4e3072-8303-464a-be7a-4fd4d808f934}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Cache Bytes" COLLECTIONVARNAME="CollectionOfMemoryCacheBytes" EXPRESSIONPATH="\Memory\Cache Bytes" DATATYPE="integer" />
    <THRESHOLD NAME="System Cache is consumsing more than 75 percent of RAM" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        $SeventyFivePercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024) * 0.75
        StaticThreshold -CollectionOfCounterInstances $CollectionOfMemoryCacheBytes -Operator 'gt' -Threshold $SeventyFivePercentOfPhysicalMemory
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\Cache Bytes" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\Cache Bytes" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          $SeventyFivePercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024) * 0.75
          $NinetyPercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024) * 0.90
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemoryCacheBytes -MinThreshold $SeventyFivePercentOfPhysicalMemory -MaxThreshold $NinetyPercentOfPhysicalMemory -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          $NinetyPercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024) * 0.90
          $OneHundredPercentOfPhysicalMemory = $([Int]$TotalMemory * 1024 * 1024 * 1024)
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfMemoryCacheBytes -MinThreshold $NinetyPercentOfPhysicalMemory -MaxThreshold $OneHundredPercentOfPhysicalMemory -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Cache Bytes is the sum of the Memory\\System Cache Resident Bytes, Memory\\System Driver Resident Bytes, Memory\\System Code Resident Bytes, and Memory\\Pool Paged Resident Bytes counters.  This counter displays the last observed value only; it is not an average. ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Paging File % Usage" ENABLED="True" CATEGORY="Paging File" PRIMARYDATASOURCE="\Paging File(*)\% Usage" ID="{9d4009d1-8698-44a4-83d9-2bc77b01094f}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Paging File(*)\% Usage" COLLECTIONVARNAME="PagingFilePercentUsageALL" EXPRESSIONPATH="\Paging File(*)\% Usage" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="More than 70% Page file usage" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $PagingFilePercentUsageALL -Operator 'gt' -Threshold 70
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 90% Page file usage" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $PagingFilePercentUsageALL -Operator 'gt' -Threshold 90
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Paging File(*)\% Usage" ISTHRESHOLDSADDED="True" DATASOURCE="\Paging File(*)\% Usage" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PagingFilePercentUsageALL -MinThreshold 70 -MaxThreshold 90 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $PagingFilePercentUsageALL -MinThreshold 90 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[The amount of the Page File instance in use in percent.  See also Process\\Page File Bytes.<BR>
<BR>
This analysis checks if the percentage of usage is greater than 70%.<BR>
<BR>
<B>Reference</B><BR>
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP<BR>
<A HREF="http://support.microsoft.com/kb/889654">http://support.microsoft.com/kb/889654</A><BR>
<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory % Committed Bytes In Use" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\% Committed Bytes In Use" ID="{f1b3e1f5-274b-488b-9982-b54b3e5d7ee5}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\% Committed Bytes In Use" COLLECTIONVARNAME="MemoryPercentCommittedBytesInUse" EXPRESSIONPATH="\Memory\% Committed Bytes In Use" DATATYPE="integer" />
    <THRESHOLD NAME="More than 70% the Commit Limit is in use" CONDITION="Warning" COLOR="Yellow" PRIORITY="50" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
         StaticThreshold -CollectionOfCounterInstances $MemoryPercentCommittedBytesInUse -Operator 'gt' -Threshold 70
         ]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="More than 90% the Commit Limit is in use" CONDITION="Critical" COLOR="Red" PRIORITY="100" ID="">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $MemoryPercentCommittedBytesInUse -Operator 'gt' -Threshold 90
        ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Memory\% Committed Bytes In Use" ISTHRESHOLDSADDED="True" DATASOURCE="\Memory\% Committed Bytes In Use" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $MemoryPercentCommittedBytesInUse -MinThreshold 70 -MaxThreshold 90 -UseMaxValue $False
        ]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $MemoryPercentCommittedBytesInUse -MinThreshold 90 -MaxThreshold 99.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[% Committed Bytes In Use is the ratio of Memory\Committed Bytes to the Memory\Commit Limit. Committed memory is the physical memory (RAM plus all of the page files) in use for which space has been reserved in the paging file should it need to be written to disk. The commit limit is the sum of physical RAM and the size of all of the paging files.  If the paging file is enlarged, the commit limit increases, and the ratio is reduced). This counter displays the current percentage value only; it is not an average.<BR>
<BR>
This analysis checks if the amount of Commited memory is becoming close to the Commit Limit (RAM plus total page file sizes), If so, then identify if you have a memory leak. If no memory leak is identified, then consider adding more physical RAM or increase the size of your page files.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Disk Transfers/sec" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Disk Transfers/sec" ID="{c72eb5e3-1d3f-4de7-9a04-cce57b59fa3c}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Disk Transfers/sec" COLLECTIONVARNAME="LogicalDiskDiskTransferssecALL" EXPRESSIONPATH="\LogicalDisk(*)\Disk Transfers/sec" MINVARNAME="MinLogicalDisk_DiskTransferssec" AVGVARNAME="AvgLogicalDisk_DiskTransferssec" MAXVARNAME="MaxLogicalDisk_DiskTransferssec" TRENDVARNAME="TrendLogicalDisk_DiskTransferssec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Transfers/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Disk Transfers/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Disk Transfers/sec is the rate of read and write operations on the disk.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Server Pool Nonpaged Failures" ENABLED="True" CATEGORY="Server" PRIMARYDATASOURCE="\Server\Pool Nonpaged Failures" ID="{df1afb2e-810f-402d-9615-48656add7e40}" FROMALLCOUNTERSTATS="False">
    <DESCRIPTION><![CDATA[The number of times allocations from nonpaged pool have failed.  Indicates that the computer's physical memory is too small.]]></DESCRIPTION>
    <DATASOURCE TYPE="CounterLog" NAME="\Server\Pool Nonpaged Failures" COLLECTIONVARNAME="ServerPoolNonpagedFailures" EXPRESSIONPATH="\Server\Pool Nonpaged Failures" DATATYPE="integer" />
    <CHART CHARTTITLE="\Server\Pool Nonpaged Failures" ISTHRESHOLDSADDED="False" DATASOURCE="\Server\Pool Nonpaged Failures" CHARTLABELS="instance" />
  </ANALYSIS>
  <ANALYSIS NAME="Server Pool Paged Failures" ENABLED="True" CATEGORY="Server" PRIMARYDATASOURCE="\Server\Pool Paged Failures" ID="{5f8fefaf-0d9c-42aa-836b-d2bef0a5f08d}" FROMALLCOUNTERSTATS="False">
    <DESCRIPTION><![CDATA[The number of times allocations from paged pool have failed.  Indicates that the computer's physical memory or paging file are too small.]]></DESCRIPTION>
    <DATASOURCE TYPE="CounterLog" NAME="\Server\Pool Paged Failures" COLLECTIONVARNAME="ServerPoolPagedFailures" EXPRESSIONPATH="\Server\Pool Paged Failures" DATATYPE="integer" />
    <CHART CHARTTITLE="\Server\Pool Paged Failures" ISTHRESHOLDSADDED="False" DATASOURCE="\Server\Pool Paged Failures" CHARTLABELS="instance" />
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages Output/sec" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pages Output/sec" ID="{f77c4131-a0e5-4573-9fe1-212f3466f537}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pages Output/sec" COLLECTIONVARNAME="MemoryPagesOutputsec" EXPRESSIONPATH="\Memory\Pages Output/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Pages Output/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Pages Output/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Pages Output/sec is the rate at which pages are written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code. A high rate of pages output might indicate a memory shortage. Windows writes more pages back to disk to free up space when physical memory is in short supply.  This counter shows the number of pages, and can be compared to other counts of pages, without conversion.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Transition Pages RePurposed/sec" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Transition Pages RePurposed/sec" ID="{36d93462-3e5a-42b9-aab6-ea33082caae9}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Transition Pages RePurposed/sec" COLLECTIONVARNAME="MemoryTransitionPagesRePurposedsec" EXPRESSIONPATH="\Memory\Transition Pages RePurposed/sec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Transition Pages RePurposed/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Transition Pages RePurposed/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Transition Pages RePurposed is the rate at which the number of transition cache pages were reused for a different purpose.  These pages would have otherwise remained in the page cache to provide a (fast) soft fault (instead of retrieving it from backing store) in the event the page was accessed in the future.  Note these pages can contain private or sharable memory.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets Outbound Errors" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Packets Outbound Errors" ID="{d2572721-c446-4331-a0c6-06319be62169}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Packets Outbound Errors" COLLECTIONVARNAME="CollectionOfNetworkInterfacePacketsOutboundErrorsALL" EXPRESSIONPATH="\Network Interface(*)\Packets Outbound Errors" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <THRESHOLD NAME="Network Interface Packet Errors occurring" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
      <CODE><![CDATA[
        StaticThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfacePacketsOutboundErrorsALL -Operator 'gt' -Threshold 1
         ]]></CODE>
    </THRESHOLD>
    <CHART CHARTTITLE="\Network Interface(*)\Packets Outbound Errors" ISTHRESHOLDSADDED="True" DATASOURCE="\Network Interface(*)\Packets Outbound Errors" CHARTLABELS="instance">
      <SERIES NAME="Critical">
        <CODE><![CDATA[
          StaticChartThreshold -CollectionOfCounterInstances $CollectionOfNetworkInterfacePacketsOutboundErrorsALL -MinThreshold 1 -MaxThreshold 1.999 -UseMaxValue $True
        ]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[Packets Outbound Errors is the number of outbound packets that could not be transmitted because of errors.<BR>
<BR>
If errors are occuring during this analysis, network connectivity could be affected with a potential for random Outlook RPC dialog boxes. See <A HREF="http://technet.microsoft.com/en-us/library/aa997363.aspx">http://technet.microsoft.com/en-us/library/aa997363.aspx</A> and <A HREF="http://technet.microsoft.com/en-us/library/aa995850.asp">http://technet.microsoft.com/en-us/library/aa995850.asp</A> for more information<BR>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Committed Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Committed Bytes" ID="{edc8cfd9-e14b-4d5b-b5c1-cbb4a73e90ae}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Committed Bytes" COLLECTIONVARNAME="CollectionOfMemoryCommittedBytes" EXPRESSIONPATH="\Memory\Committed Bytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Committed Bytes" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Committed Bytes" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Committed Bytes is the amount of committed virtual memory, in bytes. Committed memory is the memory which has space reserved in RAM and on the disk paging file(s). There can be one or more paging files on each physical drive. This counter displays the last observed value only; it is not an average.<BR>
    This analysis checks if the amount of total committed memory (Commit Charge) exceeds the amount of physical RAM installed. If so, the page file needs to be used to help store the committed memory and performance might degrade. To alleviate this, try to identify which process is consuming the most committed memory by looking at process Private Bytes and looking for a potential memory leak (the consumption of memory over a long period of time without releasing it). Adding more RAM to the computer will help alleviate this issue, but if it is a memory leak, then the problem might return.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Read/Write Ratio" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Disk Reads/sec" ID="{c5bc515f-da40-4aa6-8341-2596347a5c5b}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Disk Reads/sec" COLLECTIONVARNAME="CollectionOfLogicalDiskDiskReadsPerSec" EXPRESSIONPATH="\LogicalDisk(*)\Disk Reads/sec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Disk Writes/sec" COLLECTIONVARNAME="CollectionOfLogicalDiskDiskWritesPerSec" EXPRESSIONPATH="\LogicalDisk(*)\Disk Writes/sec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\LogicalDisk(*)\Read Write Ratio" EXPRESSIONPATH="\LogicalDisk(*)\Read Write Ratio" COLLECTIONVARNAME="CollectionOfPalGeneratedReadWriteRatio" DATATYPE="integer">
      <CODE><![CDATA[
          $CollectionOfPalGeneratedReadWriteRatio = @{}
          For ($i=0;$i -lt $CollectionOfLogicalDiskDiskReadsPerSec.Count;$i++)
          {
            For ($a=0;$a -lt $CollectionOfLogicalDiskDiskWritesPerSec.Count;$a++)
            {
              If ($CollectionOfLogicalDiskDiskReadsPerSec[$i].CounterInstance -eq $CollectionOfLogicalDiskDiskWritesPerSec[$a].CounterInstance)
              { 
                $b = $a
              }
            }
            $alValues = New-Object System.Collections.ArrayList
            For ($v=0;$v -lt $CollectionOfLogicalDiskDiskReadsPerSec[$i].Value.Count;$v++)
            {
              If (($CollectionOfLogicalDiskDiskReadsPerSec[$i].QuantizedAvg[$v] -gt 0) -and ($CollectionOfLogicalDiskDiskWritesPerSec[$b].QuantizedAvg[$v] -gt 0))
              {
                [int]$iPercentageOfReadsToWrites = ([double]$CollectionOfLogicalDiskDiskReadsPerSec[$i].QuantizedAvg[$v] / ([double]$CollectionOfLogicalDiskDiskReadsPerSec[$i].QuantizedAvg[$v] + [double]$CollectionOfLogicalDiskDiskWritesPerSec[$b].QuantizedAvg[$v])) * 100
                [void] $alValues.Add($iPercentageOfReadsToWrites)
              }
              Else
              {
                [void] $alValues.Add(0)
              }
            }
            $sGeneratedInstanceName = "\\$($CollectionOfLogicalDiskDiskReadsPerSec[$i].CounterComputer)\$($CollectionOfLogicalDiskDiskReadsPerSec[$i].CounterObject)($($CollectionOfLogicalDiskDiskReadsPerSec[$i].CounterInstance))\Read Write Ratio"
            $CollectionOfPalGeneratedReadWriteRatio.Add($sGeneratedInstanceName,$alValues)
          }
        ]]></CODE>
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Read Write Ratio" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Read Write Ratio" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Reads/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Disk Reads/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Writes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Disk Writes/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[
    This analysis shows the ratio of reads to writes for each logical disk. For example, a value of 25 means 25 percent of all of the I/O per second is read I/O and 75 percent is write I/O.
    ]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Bytes/Read" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk Bytes/Read" ID="{395c9f00-777d-4860-bd73-0c1464beb513}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Bytes/Read" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskBytesPerRead" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Bytes/Read" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk Bytes/Read" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Avg. Disk Bytes/Read" CHARTLABELS="instance" />
    <THRESHOLD NAME="Greater than or equal to 64K I/O Sizes - the larger the I/O size, the longer the response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDiskBytesPerRead -Operator 'ge' -Threshold 65536]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis shows the size of logical disk reads per second. The size of an I/O request packets (IRP) can have a direct affect on the average response times from the disk. This analysis checks for I/O request sizes of 64 KB or larger. Correlate this analysis with the <B>Avg. Disk Sec/Read</B> and <B>Avg. Disk Sec/Write</B> analyses.<BR>
<BR>
References:
<UL>
<LI><A HREF="http://www.1105newsletters.com/t.do?id=8093380:213921">How to Speak SAN-ish</A></LI>
</UL>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Bytes/Write" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk Bytes/Write" ID="{4d4bd0b0-2b5e-498f-8c8c-a03eb885a102}" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Bytes/Write" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskBytesPerWrite" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Bytes/Write" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk Bytes/Write" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Avg. Disk Bytes/Write" CHARTLABELS="instance" />
    <THRESHOLD NAME="Greater than or equal to 64K I/O Sizes - the larger the I/O size, the longer the response times" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDiskBytesPerWrite -Operator 'ge' -Threshold 65536]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[This analysis shows the size of logical disk writes per second. The size of an I/O request packets (IRP) can have a direct affect on the average response times from the disk. This analysis checks for I/O request sizes of 64 KB or larger. Correlate this analysis with the <B>Avg. Disk Sec/Read</B> and <B>Avg. Disk Sec/Write</B> analyses.<BR>
<BR>
Reference:
<UL>
<LI><A HREF="http://www.1105newsletters.com/t.do?id=8093380:213921">How to Speak SAN-ish</A></LI>
</UL>]]></DESCRIPTION>
  </ANALYSIS>
  <!--
  <ANALYSIS NAME="PlaceHolder" ENABLED="True" CATEGORY="PlaceHolder" PRIMARYDATASOURCE="PlaceHolder"  ID="PlaceHolder">
    <DATASOURCE TYPE="CounterLog" NAME="PlaceHolder" EXPRESSIONPATH="PlaceHolder" COLLECTIONVARNAME="CollectionOf" DATATYPE="Integer" />
    <CHART CHARTTITLE="PlaceHolder" ISTHRESHOLDSADDED="True" DATASOURCE="PlaceHolder" CHARTLABELS="instance">
      <SERIES NAME="Warning" TYPE="Line" COLLECTIONMINVARNAME="MinWarningSeriesCollection" COLLECTIONMAXVARNAME="MaxWarningSeriesCollection" >
        <CODE>
          <![CDATA[          
          ForEach ($InstanceOfPlaceHolder in $CollectionOfPlaceHolder)
          {
            ForEach ($iValue in $InstanceOfPlaceHolder.Value)
            {
              [void] $MinWarningSeriesCollection.Add(75)
              [void] $MaxWarningSeriesCollection.Add(90)
            }
          }
        ]]>
        </CODE>
      </SERIES>
      <SERIES NAME="Critical" TYPE="Line" COLLECTIONMINVARNAME="MinCriticalSeriesCollection" COLLECTIONMAXVARNAME="MaxCriticalSeriesCollection" >
        <CODE>
          <![CDATA[
          ForEach ($InstanceOfPlaceHolder in $CollectionOfPlaceHolder)
          {
            ForEach ($iValue in $InstanceOfPlaceHolder.Value)
            {
              [void] $MinCriticalSeriesCollection.Add(90)
              [void] $MaxCriticalSeriesCollection.Add(99.99)
            }
          }
        ]]>
        </CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[ ]]></DESCRIPTION>
  </ANALYSIS>
-->
  <ANALYSIS NAME="PhysicalDisk Current Disk Queue Length" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Current Disk Queue Length" ID="0cd5788d-1855-42c2-b2ce-9eee52411c72" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Current Disk Queue Length" COLLECTIONVARNAME="CollectionOfPhysicalDiskCurrentDiskQueueLength" EXPRESSIONPATH="\PhysicalDisk(*)\Current Disk Queue Length" TRENDVARNAME="TrendPhysicalDiskCurrentDiskQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Current Disk Queue Length" ISTHRESHOLDSADDED="False" DATASOURCE="\PhysicalDisk(*)\Current Disk Queue Length" CHARTLABELS="instance" />
    <THRESHOLD NAME="Experimental: HBA Queue Depth might be restricted to 32 - Consider increasing the HBA queue depth if applicable" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfPhysicalDiskCurrentDiskQueueLength -Operator 'ge' -Threshold 32]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks. For good performance, this difference should average less than two.<BR>
<BR>
If the server is using an HBA (Host Bus Adapter: This is used to connect to a Storage Area Network SAN) and if the Current Disk Queue Length goes up to 32 frequently, then consider increasing the queue depth on the HBA to allow more concurrent I/O to the SAN. Please consult your SAN administrator before making any changes.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Avg. Disk Queue Length" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Avg. Disk Queue Length" ID="f4902104-0539-4fb5-8dbc-b2b15c0ec060" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Avg. Disk Queue Length" COLLECTIONVARNAME="CollectionOfLogicalDiskAvgDiskQueueLength" EXPRESSIONPATH="\LogicalDisk(*)\Avg. Disk Queue Length" TRENDVARNAME="TrendLogicalDiskAvgDiskQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Avg. Disk Queue Length" ISTHRESHOLDSADDED="True" DATASOURCE="\LogicalDisk(*)\Avg. Disk Queue Length" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDiskQueueLength -MinThreshold 2 -MaxThreshold 9.999 -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="More than 2 I/O's are waiting on the logical disk" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskAvgDiskQueueLength -Operator 'gt' -Threshold 2]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk Queue Length is the average number of both read and write requests that were queued or "in-flight" for the selected disk during the sample interval.<BR>
<BR>
This counter typically has a threshold of number of spindles + 2. Due to high end disk virtualization, it is difficult to determine the true number of physical spindles behind the logical disk or LUN. Therefore, this threshold will generically throw a Warning alert for an average disk queue length greater than 2.<BR>
<BR>
References:
<UL>
<LI><A HREF="http://www.1105newsletters.com/t.do?id=8093380:213921">How to Speak SAN-ish</A></LI>
</UL>
]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % DPC Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% DPC Time" ID="93c6731f-1538-4f0d-8c52-b294e1592ac4" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% DPC Time" COLLECTIONVARNAME="CollectionOfProcessorPercentDPCTime" EXPRESSIONPATH="\Processor(*)\% DPC Time" TRENDVARNAME="TrendProcessorPercentDPCTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor(*)\% DPC Time" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\% DPC Time" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentDPCTime -MinThreshold 20 -MaxThreshold 99.999 -UseMaxValue $False]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="More than 20% time in Deferred Procedure Calls (DPC) - likely busy or poorly written drivers" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfProcessorPercentDPCTime -Operator 'gt' -Threshold 20]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[% DPC Time is the percentage of time that the processor spent receiving and servicing deferred procedure calls (DPCs) during the sample interval. DPCs are interrupts that run at a lower priority than standard interrupts. % DPC Time is a component of % Privileged Time because DPCs are executed in privileged mode. They are counted separately and are not a component of the interrupt counters. This counter displays the average busy time as a percentage of the sample time.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Commit Limit" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Commit Limit" ID="0e688e18-1edb-4ca5-9445-b17dbb37fd61" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Commit Limit" COLLECTIONVARNAME="CollectionOfMemoryCommitLimit" EXPRESSIONPATH="\Memory\Commit Limit" TRENDVARNAME="TrendMemoryCommitLimit" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Commit Limit" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Commit Limit" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Commit Limit is the amount of virtual memory that can be committed without having to extend the paging file(s).  It is measured in bytes. Committed memory is the physical memory which has space reserved on the disk paging files. There can be one paging file on each logical drive). If the paging file(s) are be expanded, this limit increases accordingly.  This counter displays the last observed value only; it is not an average.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Avg. Disk Queue Length" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Avg. Disk Queue Length" ID="51260b28-3103-4629-ac4d-08437f0170c1" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Avg. Disk Queue Length" COLLECTIONVARNAME="CollectionOfPhysicalDiskAvgDiskQueueLength" EXPRESSIONPATH="\PhysicalDisk(*)\Avg. Disk Queue Length" TRENDVARNAME="TrendPhysicalDiskAvgDiskQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Avg. Disk Queue Length" ISTHRESHOLDSADDED="True" DATASOURCE="\PhysicalDisk(*)\Avg. Disk Queue Length" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfPhysicalDiskAvgDiskQueueLength -MinThreshold 2 -MaxThreshold 4 -IsOperatorGreaterThan $True -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <THRESHOLD NAME="More than 2 I/O's are waiting on the physical disk" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfPhysicalDiskAvgDiskQueueLength -Operator 'gt' -Threshold 2]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Avg. Disk Queue Length is the average number of both read and write requests that were queued for the selected disk during the sample interval.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Current Disk Queue Length" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Current Disk Queue Length" ID="421dfe15-2ff0-4f32-b319-505aed5e6dd5" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Current Disk Queue Length" COLLECTIONVARNAME="CollectionOfLogicalDiskCurrentDiskQueueLength" EXPRESSIONPATH="\LogicalDisk(*)\Current Disk Queue Length" TRENDVARNAME="TrendLogicalDiskCurrentDiskQueueLength" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Current Disk Queue Length" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Current Disk Queue Length" CHARTLABELS="instance" />
    <THRESHOLD NAME="Experimental: 32 or greater current disk I/O's queued. If using an HBA, then consider adjusting the queue depth." CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskCurrentDiskQueueLength -Operator 'ge' -Threshold 32]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Current Disk Queue Length is the number of requests outstanding on the disk at the time the performance data is collected. It also includes requests in service at the time of the collection. This is a instantaneous snapshot, not an average over the time interval. Multi-spindle disk devices can have multiple requests that are active at one time, but other concurrent requests are awaiting service. This counter might reflect a transitory high or low queue length, but if there is a sustained load on the disk drive, it is likely that this will be consistently high. Requests experience delays proportional to the length of this queue minus the number of spindles on the disks.<BR>
<BR>
This analysis checks if the number of I/O request packets (IRPs) in the disk queue are at 32 or higher. Many SAN vendors use 32 as a default setting for the Host Bus Adapter (HBA) which interfaces into the fibre channel network to connect to one or more SANs. If the queue depth (simultaneous in-flight I/O)  is reached frequently, then the queue depth might need to be increased.<BR>
<BR>
Reference:
<UL>
<LI><A HREF="http://www.1105newsletters.com/t.do?id=8093380:213921">How to Speak SAN-ish</A></LI>
</UL>]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Pages Input/sec" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Pages Input/sec" ID="8448cabb-a4c6-4b2d-8beb-0427f284ad90" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Pages Input/sec" COLLECTIONVARNAME="CollectionOfMemoryPagesInputsec" EXPRESSIONPATH="\Memory\Pages Input/sec" TRENDVARNAME="TrendMemoryPagesInputsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Pages Input/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Pages Input/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="Greater than 1000 page inputs per second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfMemoryPagesInputsec -Operator 'gt' -Threshold 1000]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Pages Input/sec is the rate at which pages are read from disk to resolve hard page faults. Hard page faults occur when a process refers to a page in virtual memory that is not in its working set or elsewhere in physical memory, and must be retrieved from disk. When a page is faulted, the system tries to read multiple contiguous pages into memory to maximize the benefit of the read operation. Compare the value of Memory\\Pages Input/sec to the value of  Memory\\Page Reads/sec to determine the average number of pages read into memory during each read operation.

This analysis checks for more than 1000 page inputs per second. If there is a lot of page inputs per second, then it could be normal file I/O reading from the disk as memory mapped files, or it could be reading from the page file. This counter is not an indicator of a lack of memory condition unless there is a lot of memory pressure corresponding to this alert.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Memory Free &amp; Zero Page List Bytes" ENABLED="True" CATEGORY="Memory" PRIMARYDATASOURCE="\Memory\Free &amp; Zero Page List Bytes" ID="c7af5191-3b22-4479-9a1c-1c30684b95f1" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Memory\Free &amp; Zero Page List Bytes" COLLECTIONVARNAME="CollectionOfMemoryFree&amp;ZeroPageListBytes" EXPRESSIONPATH="\Memory\Free &amp; Zero Page List Bytes" TRENDVARNAME="TrendMemoryFree&amp;ZeroPageListBytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Memory\Free &amp; Zero Page List Bytes" ISTHRESHOLDSADDED="False" DATASOURCE="\Memory\Free &amp; Zero Page List Bytes" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Free & Zero Page List Bytes is the amount of physical memory, in bytes, that is assigned to the free and zero page lists. This memory does not contain cached data. It is immediately available for allocation to a process or for system use. For a full explanation of the memory manager, refer to MSDN and/or the System Performance and Troubleshooting Guide chapter in the Windows Server 2003 Resource Kit.<BR>
<BR>
If the size of the Free and Zero page list is large, then it is a good indicator of too much RAM installed on the computer. A large amount of Free and Zero page list size is normal for computers that have been recently powered on or booted. As the system accesses the hard disk placing pages of memory into the working sets of processes, eventually many of those pages of memory will be discarded or paged out. When that happens, the memory is often placed on the Standby list. A large Standby list is preferable because it uses the extra RAM as a disk cache. Available memory is the sum of the Free, Zero, and Standby page lists, so a high amount of available memory with a low amount of Zero and Free is preferred because the system is using the extra RAM as disk cache.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Bytes Total/sec" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Bytes Total/sec" ID="1f05beca-dd49-476f-92b2-f782944740d9" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Bytes Total/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfaceBytesTotalsec" EXPRESSIONPATH="\Network Interface(*)\Bytes Total/sec" TRENDVARNAME="TrendNetworkInterfaceBytesTotalsec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\Network Interface(*)\Bytes Total/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Bytes Total/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Bytes Total/sec is the rate at which bytes are sent and received over each network adapter, including framing characters. Network Interface\Bytes Total/sec is a sum of Network Interface\Bytes Received/sec and Network Interface\Bytes Sent/sec.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor % User Time" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\% User Time" ID="5d6b712d-8483-4abe-aa47-2e7daa83695e" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\% User Time" COLLECTIONVARNAME="CollectionOfProcessorPercentUserTime" EXPRESSIONPATH="\Processor(*)\% User Time" TRENDVARNAME="TrendProcessorPercentUserTime" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor(*)\% User Time" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor(*)\% User Time" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[<B>% User Time</B> is the percentage of elapsed time the processor spends in the user mode. User mode is a restricted processing mode designed for applications, environment subsystems, and integral subsystems.  The alternative, privileged mode, is designed for operating system components and allows direct access to hardware and all memory.  The operating system switches application threads to privileged mode to access operating system services. This counter displays the average busy time as a percentage of the sample time.<BR>

<BR>

This analysis provides statistics only. Threads running on a processor will be in either user mode measured using <B>% User Time</B> or in priviledge/kernel mode measured using <B>% Privileged Time</B>. High <B>% User Time</B> indicates a high amount of application code is being executed. This is desirable versus too much time in privileged mode. See the Processor <B>% Privileged Time</B> analysis for more information.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="System System Calls/sec" ENABLED="True" CATEGORY="System" PRIMARYDATASOURCE="\System\System Calls/sec" ID="e55e6b58-57ca-4583-a7be-e5f8ca502f7a" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\System\System Calls/sec" COLLECTIONVARNAME="CollectionOfSystemSystemCallssec" EXPRESSIONPATH="\System\System Calls/sec" TRENDVARNAME="TrendSystemSystemCallssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\System\System Calls/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\System\System Calls/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[System Calls/sec is the combined rate of calls to operating system service routines by all processes running on the computer. These routines perform all of the basic scheduling and synchronization of activities on the computer, and provide access to non-graphic devices, memory management, and name space management. This counter displays the difference between the values observed in the last two samples, divided by the duration of the sample interval.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Cache Lazy Write Flushes/sec" ENABLED="True" CATEGORY="Cache" PRIMARYDATASOURCE="\Cache\Lazy Write Flushes/sec" ID="14aa1191-dcc9-4b35-a6bb-b5bdcadca9b3" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Cache\Lazy Write Flushes/sec" COLLECTIONVARNAME="CollectionOfCacheLazyWriteFlushessec" EXPRESSIONPATH="\Cache\Lazy Write Flushes/sec" TRENDVARNAME="TrendCacheLazyWriteFlushessec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Cache\Lazy Write Flushes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Cache\Lazy Write Flushes/sec" CHARTLABELS="instance" />
    <THRESHOLD NAME="More than 100 Lazy Write flushes/second" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfCacheLazyWriteFlushessec -Operator 'gt' -Threshold 100]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Lazy Write Flushes/sec is the rate at which the Lazy Writer thread has written to disk.  Lazy Writing is the process of updating the disk after the page has been changed in memory, so that the application that changed the file does not have to wait for the disk write to be complete before proceeding.  More than one page can be transferred by each write operation.<BR>
<BR>
The lazy writer writes 20% of the dirty pages every second, but increases the number of lazy write flushes if it is unable to keep up with the rate of dirty pages.
<BR>
This analysis checks for more than 100 lazy write flushes/second which might indicate that the lazy writer is falling behind in writing to the disk.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Cache Dirty Pages" ENABLED="True" CATEGORY="Cache" PRIMARYDATASOURCE="\Cache\Dirty Pages" ID="ee5a30e9-d101-4a83-bce0-88f7a8759fc8" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Cache\Dirty Pages" COLLECTIONVARNAME="CollectionOfCacheDirtyPages" EXPRESSIONPATH="\Cache\Dirty Pages" TRENDVARNAME="TrendCacheDirtyPages" DATATYPE="integer" />
    <CHART CHARTTITLE="\Cache\Dirty Pages" ISTHRESHOLDSADDED="False" DATASOURCE="\Cache\Dirty Pages" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Total number of dirty pages on the system cache]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Disk Bytes/sec" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Disk Bytes/sec" ID="3a533e62-26fc-4c00-b05d-0036d434913f" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Disk Bytes/sec" COLLECTIONVARNAME="CollectionOfLogicalDiskDiskBytessec" EXPRESSIONPATH="\LogicalDisk(*)\Disk Bytes/sec" TRENDVARNAME="TrendLogicalDiskDiskBytessec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\LogicalDisk(*)\Disk Bytes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Disk Bytes/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations. A mirror pair (RAID1) 7200 RPM disk drives can deliver roughly 20 MB per second throughput.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Disk Bytes/sec" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Disk Bytes/sec" ID="043cf51b-1fa0-4e28-86c3-cd0e6f12cc99" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Disk Bytes/sec" COLLECTIONVARNAME="CollectionOfPhysicalDiskDiskBytessec" EXPRESSIONPATH="\PhysicalDisk(*)\Disk Bytes/sec" TRENDVARNAME="TrendPhysicalDiskDiskBytessec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Disk Bytes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\PhysicalDisk(*)\Disk Bytes/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Disk Bytes/sec is the rate bytes are transferred to or from the disk during write or read operations.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information Parking Status" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\Parking Status" ID="7a14d59e-1aec-465f-bfad-6283bc2d9ad6" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\Parking Status" COLLECTIONVARNAME="CollectionOfProcessorInformationParkingStatus" EXPRESSIONPATH="\Processor Information(*)\Parking Status" TRENDVARNAME="TrendProcessorInformationParkingStatus" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\Parking Status" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\Parking Status" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Parking Status represents whether a processor is parked or not.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor Information % of Maximum Frequency" ENABLED="True" CATEGORY="Processor Information" PRIMARYDATASOURCE="\Processor Information(*)\% of Maximum Frequency" ID="dff534ed-4263-4a28-93a1-e14a94607594" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor Information(*)\% of Maximum Frequency" COLLECTIONVARNAME="CollectionOfProcessorInformationPercentofMaximumFrequency" EXPRESSIONPATH="\Processor Information(*)\% of Maximum Frequency" TRENDVARNAME="TrendProcessorInformationPercentofMaximumFrequency" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor Information(*)\% of Maximum Frequency" ISTHRESHOLDSADDED="False" DATASOURCE="\Processor Information(*)\% of Maximum Frequency" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[% of Maximum Frequency is the percentage of the current processor's maximum frequency.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="LogicalDisk Free Megabytes" ENABLED="True" CATEGORY="LogicalDisk" PRIMARYDATASOURCE="\LogicalDisk(*)\Free Megabytes" ID="2e903f60-42e2-4760-9c52-38f8ba7c12e5" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\LogicalDisk(*)\Free Megabytes" COLLECTIONVARNAME="CollectionOfLogicalDiskFreeMegabytes" EXPRESSIONPATH="\LogicalDisk(*)\Free Megabytes" TRENDVARNAME="TrendLogicalDiskFreeMegabytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\LogicalDisk(*)\Free Megabytes" ISTHRESHOLDSADDED="False" DATASOURCE="\LogicalDisk(*)\Free Megabytes" CHARTLABELS="instance" />
    <THRESHOLD NAME="Less than 4 GB of free disk space" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskFreeMegabytes -Operator 'lt' -Threshold 4000]]></CODE>
    </THRESHOLD>
    <THRESHOLD NAME="Less than 500 MB of free disk space" CONDITION="Critical" COLOR="Red" PRIORITY="100">
      <DESCRIPTION><![CDATA[]]></DESCRIPTION>
      <CODE><![CDATA[StaticThreshold -CollectionOfCounterInstances $CollectionOfLogicalDiskFreeMegabytes -Operator 'lt' -Threshold 500]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Free Megabytes displays the unallocated space, in megabytes, on the disk drive in megabytes. One megabyte is equal to 1,048,576 bytes.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Processor DPC Rate" ENABLED="True" CATEGORY="Processor" PRIMARYDATASOURCE="\Processor(*)\DPC Rate" ID="0a22b344-a3f9-4445-bf62-7c429df68231" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Processor(*)\DPC Rate" COLLECTIONVARNAME="CollectionOfProcessorDPCRate" EXPRESSIONPATH="\Processor(*)\DPC Rate" TRENDVARNAME="TrendProcessorDPCRate" DATATYPE="integer" />
    <CHART CHARTTITLE="\Processor(*)\DPC Rate" ISTHRESHOLDSADDED="True" DATASOURCE="\Processor(*)\DPC Rate" CHARTLABELS="instance">
      <SERIES NAME="Warning">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorDPCRate -MinThreshold 10 -MaxThreshold 20 -IsOperatorGreaterThan $True -UseMaxValue $False]]></CODE>
      </SERIES>
      <SERIES NAME="Critical">
        <CODE><![CDATA[StaticChartThreshold -CollectionOfCounterInstances $CollectionOfProcessorDPCRate -MinThreshold 20 -MaxThreshold 29.999 -IsOperatorGreaterThan $True -UseMaxValue $True]]></CODE>
      </SERIES>
    </CHART>
    <DESCRIPTION><![CDATA[DPC Rate is the rate at which deferred procedure calls (DPCs) were added to the processors DPC queues between the timer ticks of the processor clock. DPCs are interrupts that run at alower priority than standard interrupts.  Each processor has its own DPC queue. This counter measures the rate that DPCs were added to the queue, not the number of DPCs in the queue. This counter displays the last observed value only; it is not an average.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Current Bandwidth" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Current Bandwidth" ID="48ae886e-4c85-4620-b15a-055b577da047" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Current Bandwidth" COLLECTIONVARNAME="CollectionOfNetworkInterfaceCurrentBandwidth" EXPRESSIONPATH="\Network Interface(*)\Current Bandwidth" TRENDVARNAME="TrendNetworkInterfaceCurrentBandwidth" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Current Bandwidth" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Current Bandwidth" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Current Bandwidth is an estimate of the current bandwidth of the network interface in bits per second (BPS).  For interfaces that do not vary in bandwidth or for those where no accurate estimation can be made, this value is the nominal bandwidth.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets/sec" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Packets/sec" ID="56ec51bc-6d8e-46b3-beb0-5bace1fdf247" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Packets/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfacePacketssec" EXPRESSIONPATH="\Network Interface(*)\Packets/sec" TRENDVARNAME="TrendNetworkInterfacePacketssec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Packets/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Packets/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Packets/sec is the rate at which packets are sent and received on the network interface.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets Sent/sec" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Packets Sent/sec" ID="d5eed88b-db20-4baa-9ee7-9e462b610e5c" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Packets Sent/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfacePacketsSentsec" EXPRESSIONPATH="\Network Interface(*)\Packets Sent/sec" TRENDVARNAME="TrendNetworkInterfacePacketsSentsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Packets Sent/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Packets Sent/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Packets Sent/sec is the rate at which packets are sent on the network interface.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Interface Packets Received/sec" ENABLED="True" CATEGORY="Network Interface" PRIMARYDATASOURCE="\Network Interface(*)\Packets Received/sec" ID="8fb77984-90c3-4c99-91d8-ab7e3599d561" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Interface(*)\Packets Received/sec" COLLECTIONVARNAME="CollectionOfNetworkInterfacePacketsReceivedsec" EXPRESSIONPATH="\Network Interface(*)\Packets Received/sec" TRENDVARNAME="TrendNetworkInterfacePacketsReceivedsec" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Interface(*)\Packets Received/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Interface(*)\Packets Received/sec" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Packets Received/sec is the rate at which packets are received on the network interface.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="Network Inspection System\Average inspection latency  Average inspection latency (sec/bytes)" ENABLED="True" CATEGORY="Network Inspection System" PRIMARYDATASOURCE="\Network Inspection System\Average inspection latency (sec/bytes)" ID="c9a15142-ba6f-40a8-976a-76854d77011d" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\Network Inspection System\Average inspection latency (sec/bytes)" COLLECTIONVARNAME="CollectionOfNetworkInspectionSystemAverageinspectionlatencyAverageinspectionlatencysecbytes" EXPRESSIONPATH="\Network Inspection System\Average inspection latency (sec/bytes)" TRENDVARNAME="TrendNetworkInspectionSystemAverageinspectionlatencyAverageinspectionlatencysecbytes" DATATYPE="integer" />
    <CHART CHARTTITLE="\Network Inspection System\Average inspection latency (sec/bytes)" ISTHRESHOLDSADDED="False" DATASOURCE="\Network Inspection System\Average inspection latency (sec/bytes)" CHARTLABELS="instance" />
    <DESCRIPTION><![CDATA[Average time spent inspecting data (sec/bytes)]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="PhysicalDisk Calculated IOPS" ENABLED="True" CATEGORY="PhysicalDisk" PRIMARYDATASOURCE="\PhysicalDisk(*)\Disk Reads/sec" ID="55cf8ed2-887c-4c36-a768-6b313928692c" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Disk Reads/sec" COLLECTIONVARNAME="CollectionOfPhysicalDiskDiskReadssec" EXPRESSIONPATH="\PhysicalDisk(*)\Disk Reads/sec" TRENDVARNAME="TrendPhysicalDiskDiskReadssec" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <CHART CHARTTITLE="\PhysicalDisk(*)\Disk Reads/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\PhysicalDisk(*)\Disk Reads/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\PhysicalDisk(*)\Disk Writes/sec" ISTHRESHOLDSADDED="False" DATASOURCE="\PhysicalDisk(*)\Disk Writes/sec" CHARTLABELS="instance" />
    <CHART CHARTTITLE="\PhysicalDisk(*)\Calculated IOPS" ISTHRESHOLDSADDED="False" DATASOURCE="\PhysicalDisk(*)\Calculated IOPS" CHARTLABELS="instance" />
    <DATASOURCE TYPE="CounterLog" NAME="\PhysicalDisk(*)\Disk Writes/sec" EXPRESSIONPATH="\PhysicalDisk(*)\Disk Writes/sec" COLLECTIONVARNAME="CollectionOfPhysicalDiskDiskWritessecAll" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
    </DATASOURCE>
    <DATASOURCE TYPE="Generated" NAME="\PhysicalDisk(*)\Calculated IOPS" EXPRESSIONPATH="\PhysicalDisk(*)\Calculated IOPS" COLLECTIONVARNAME="CollectionOfPhysicalDiskCalculatedIOPSAll" DATATYPE="integer">
      <EXCLUDE INSTANCE="_Total" />
      <CODE><![CDATA[
$CollectionOfPhysicalDiskCalculatedIOPSAll = @{}
For ($i=0;$i -lt $CollectionOfPhysicalDiskDiskReadssec.Count;$i++)
{
	$alValues = New-Object System.Collections.ArrayList
	For ($v=0;$v -lt $CollectionOfPhysicalDiskDiskReadssec[$i].Value.Count;$v++)
	{
        $iWriteMultiplier = 1
        $aRAID1Drives = $RAID1Drives.Split(',')
        For ($i1=0;$i1 -lt $aRAID1Drives.Count;$i1++)
        {
            If ($CollectionOfPhysicalDiskDiskWritessecAll[$i].CounterInstance.Contains($aRAID1Drives[$i1]))
            {
                $iWriteMultiplier = 2
            }
        }
        $aRAID5Drives = $RAID5Drives.Split(',')
        For ($i5=0;$i5 -lt $aRAID5Drives.Count;$i5++)
        {
            If ($CollectionOfPhysicalDiskDiskWritessecAll[$i].CounterInstance.Contains($aRAID5Drives[$i5]))
            {
                $iWriteMultiplier = 4
            }
        }
        If (($CollectionOfPhysicalDiskDiskReadssec[$i].Value[$v] -gt 0) -and ($CollectionOfPhysicalDiskDiskWritessecAll[$i].Value[$v] -gt 0))
        {
          [System.Int64] $iIOPS = [math]::Round($([double]$CollectionOfPhysicalDiskDiskReadssec[$i].Value[$v] + ([double]$CollectionOfPhysicalDiskDiskWritessecAll[$i].Value[$v] * [System.Int32]$iWriteMultiplier)),0)
        }
        Else
        {
          [System.Int64] $iIOPS = 0
        }
        
        #$CollectionOfPhysicalDiskDiskReadssec[$i].Value[$v] >> .\debugoutput.txt
        #$CollectionOfPhysicalDiskDiskWritessecAll[$i].Value[$v] >> .\debugoutput.txt
        #$iIOPS >> .\debugoutput.txt
        #$iWriteMultiplier >> .\debugoutput.txt        
        #'=========================' >> .\debugoutput.txt
        
		If ($iIOPS -gt 0)
		{            
			[void] $alValues.Add($iIOPS)
		}
		Else
		{
			[void] $alValues.Add(0)
		}

	}
	$sGeneratedInstanceName = "\\$($CollectionOfPhysicalDiskDiskReadssec[$i].CounterComputer)\$($CollectionOfPhysicalDiskDiskReadssec[$i].CounterObject)($($CollectionOfPhysicalDiskDiskReadssec[$i].CounterInstance))\Calculated IOPS"
	$CollectionOfPhysicalDiskCalculatedIOPSAll.Add($sGeneratedInstanceName,$alValues)
}
        ]]></CODE>
    </DATASOURCE>
    <DESCRIPTION><![CDATA[Disk Reads/sec is the rate of read operations on the disk.]]></DESCRIPTION>
  </ANALYSIS>
  <ANALYSIS NAME="TCPv4 Connection Failures" ENABLED="True" CATEGORY="TCPv4" PRIMARYDATASOURCE="\TCPv4\Connection Failures" ID="02c86473-f7fe-4cb7-8eb3-f9a0625d982f" FROMALLCOUNTERSTATS="False">
    <DATASOURCE TYPE="CounterLog" NAME="\TCPv4\Connection Failures" COLLECTIONVARNAME="CollectionOfTCPv4ConnectionFailures" EXPRESSIONPATH="\TCPv4\Connection Failures" TRENDVARNAME="TrendTCPv4ConnectionFailures" DATATYPE="integer" />
    <CHART CHARTTITLE="\TCPv4\Connection Failures" ISTHRESHOLDSADDED="False" DATASOURCE="\TCPv4\Connection Failures" CHARTLABELS="instance" />
    <THRESHOLD NAME="More than 10 TCP connection failures per hour" CONDITION="Warning" COLOR="Yellow" PRIORITY="50">
      <CODE><![CDATA[#// Use PowerShell code to create alerts when the conditions for this threshold are met.
#// Optionally use the variables listed above in the Variables list box.
#// If the condition for this threshold is a static value, then use the StaticThreshold() function.
#// Otherwise, you will need to manually loop through the counter instance collection object.
#// The counter instance collection object has a unique name for each counter data source in this analysis.
#// See the variables in the Variables list box above for more information on the counter instance collection object.

#// Here is a ready to use example on how to use the StaticThreshold() function to define a threshold:
StaticThreshold -CollectionOfCounterInstances $CollectionOfTCPv4ConnectionFailures -Operator 'gt' -Threshold 10 -IsTrendOnly $True
  

#// The -Operator parameter accepts gt for greater than, ge for greater than or equal to, lt for less than,
#//  and le for less than or equal to. -Threshold is the static value for the threshold.]]></CODE>
    </THRESHOLD>
    <DESCRIPTION><![CDATA[Connection Failures is the number of times TCP connections have made a direct transition to the CLOSED state from the SYN-SENT state or the SYN-RCVD state, plus the number of times TCP connections have made a direct transition to the LISTEN state from the SYN-RCVD state.]]></DESCRIPTION>
  </ANALYSIS>
  <INHERITANCE FILEPATH="" />
</PAL>